0001   0000             ; ===========================================================================
0002   0000             ; ЌЂ‘’ђЋ‰ЉЂ
0003   0000             
0004   0000             STD_RAMFOS = 0				; ‘Є®¬ЇЁ«Ёа®ў вм бв ­¤ ав­л© RAMFOS
0005   0000             
0006   0000             #if STD_RAMFOS==0
0007   0000             
0008   0000             DATE_IN_RAM		= 1		; 0      ђ §¬Ґй вм ¤ вг ў ®б­®ў­®© ®ЇҐа вЁў­®© Ї ¬пвЁ (ў®§¬®¦­  а Ў®в  ЎҐ§ „Ћ‡“)
0009   0000             NO_ROM_ENTRY		= 1		; 0      ‘в ­¤ ав­лҐ Їа®Ја ¬¬л ў ўЁ¤Ґ д ©«®ў
0010   0000             NO_BACK_LINKS		= 0		; 0	 ЌҐ ЁбЇ®«м§®ў вм ббл«ЄЁ ­ § ¤ ў бвагЄвгаҐ д ©«®ў
0011   0000             NO_PRINTER		= 1		; 0 	 ЋвЄ«озЁвм ЇаЁ­вҐа
0012   0000             NO_MXDOS		= 1		; 0 	 ЋвЄ«озЁвм § Јаг§Єг б ¤ЁбЄҐвл (ў з бв­®cвЁ MXDOS)
0013   0000             SD_ENABLED		= 0		; 0      ‚Є«озҐ­  Ї®¤¤Ґа¦Є  SD Є авл
0014   0000             OPEN_ANY_FILE		= 1		; 0 	 ЋвЄалў вм д ©« б «оЎл¬ а биЁаҐ­ЁҐ¬ (Ђ ­Ґ в®«мЄ® TXT ў аҐ¤ Єв®аҐ)
0015   0000             ALL_CHARS		= 1		; 0	 ЏҐз вм ўбҐе бЁ¬ў®«®ў §­ Є®ЈҐ­Ґа в®а  зҐаҐ§ ESC
0016   0000             RKS_LOADER		= 1		; 0      ‡ ЇгбЄ вм RKS д ©«л
0017   0000             BIG_ROM			= 1		; 0 	 €бЇ®«м§®ў вм ўбҐ 64 ЉЎ Џ‡“ ‘ЇҐжЁ «Ёбв  Њ•2 Ї®¤ ROM-¤ЁбЄ
0018   0000             WORK_WITHOUT_ARAM	= 1		; 0      …б«Ё „Ћ‡“ ­Ґ ­ ©¤Ґ­®, в® ЁбЇ®«м§®ў вм ЎгдҐа ў Ћ‡“ а §¬Ґа®¬ б н¬г ЇҐаҐ¬Ґ­­го
0019   0000             ROM_PAGE_START		= 01880h	; 04000h ЏҐаўл© Ў ©в бва ­Ёжл Џ‡“
0020   0000             ROM_PAGE_END		= 0FFF0h	; 0C000h Џ®б«Ґ¤­Ё© Ў ©в бва ­Ёжл Џ‡“ + 1
0021   0000             CURSOR_BLINK_SPEED	= 767		; 767    ‡ ¤Ґа¦Є  ¬ЁЈ ­Ёп Єгаб®а 
0022   0000             ARAM_MAX_PAGE           = 0Fh		; 6      Њ ЄбЁ¬ «м­®Ґ Є®«-ў® бва ­Ёж а биЁаҐ­­®© Ї ¬пвЁ (¬ Єб 0Fh)
0023   0000             ARAM_PAGE_END		= 0FFBBh        ; 0FFBBh Љ®­Ґж бва ­Ёжл „Ћ‡“ (36 Ў ©в ­ҐЁбЇ®«м§гҐ¬®Ј® Ћ‡“ Ї®б«Ґ)
0024   0000             DLG_START_PAGE		= 80h		; 0      ЏаЁ § ЇгбЄҐ Ї®Є § вм ¤ЁбЄ
0025   0000             INIT_SCREEN_COLOR	= 0F1h		; 100h	 –ўҐв, Є®в®ал¬ § «Ёў Ґвбп нЄа ­ ЇаЁ Ё­ЁжЁ «Ё§ жЁЁ. 100h - § «Ёў Ґвбп вҐЄгйЁ¬ жўҐв®¬, Є®в®ал© ЇаЁ вҐЇ«®© ЇҐаҐ§ Јаг§ЄҐ ¬®¦Ґв Ўлвм «оЎл¬.
0026   0000             FAST_PRINT		= 1		;	 Ѓлбва п дг­ЄжЁп ўлў®¤  вҐЄбв . ’ Є ¦Ґ ўлў®¤Ёв вҐЄбв бва®ЄЁ ЎҐ§ а §алў®ў. € ­Ґ Ї®авЁв жўҐв  бЁ¬ў®«®ў Їа ўҐҐ.
0027   0000             TRUE_CHECK_ARAM		= 1		; 0      €бЇЇа ў«Ґ­­ п дг­ЄжЁп ®ЇаҐ¤Ґ«Ґ­Ёп ®ЎмҐ¬  „Ћ‡“
0028   0000             NICE			= 1
0029   0000             COLOR_SUPPORT		= 1		; 0	“бв ­®ўЄ  жўҐв  Ї® г¬®«з ­Ёо ЇаЁ ®зЁбвЄҐ б«г¦ҐЎ­ле бва®Є Ё нЄа ­ 
0030   0000             NO_PRINT_STATUS_BUG	= 1
0031   0000             DLG_CURSOR_AT_TOP	= 0
0032   0000             NO_ROM_SWITCH_BUG	= 1		; 0	Њ®¦­® Ўл«® ўлЎа вм ­Ґ ­г«Ґўго бва ­Ёжг Џ‡“
0033   0000             RELOCATE_FILE_FUNCTIONS = 1		; 0     ЏҐаҐ­ҐбвЁ ­ҐЄ®в®алҐ дг­ЄжЁЁ Ё§ F800 ў C800
0034   0000             
0035   0000~            #else
0036   0000~            
0037   0000~            DATE_IN_RAM		= 0
0038   0000~            NO_ROM_ENTRY		= 0
0039   0000~            NO_BACK_LINKS		= 0
0040   0000~            NO_PRINTER		= 0
0041   0000~            NO_MXDOS		= 0
0042   0000~            OPEN_ANY_FILE		= 0
0043   0000~            ALL_CHARS		= 0
0044   0000~            RKS_LOADER		= 0
0045   0000~            BIG_ROM			= 0
0046   0000~            WORK_WITHOUT_ARAM	= 0
0047   0000~            ROM_PAGE_START		= 04000h
0048   0000~            ROM_PAGE_END		= 0C000h
0049   0000~            CURSOR_BLINK_SPEED	= 767
0050   0000~            ARAM_MAX_PAGE           = 6
0051   0000~            ARAM_PAGE_END		= 0FFBBh
0052   0000~            DLG_START_PAGE		= 0
0053   0000~            INIT_SCREEN_COLOR	= 100h
0054   0000~            FAST_PRINT		= 0
0055   0000~            TRUE_CHECK_ARAM		= 0
0056   0000~            NICE			= 0
0057   0000~            COLOR_SUPPORT		= 0
0058   0000~            NO_PRINT_STATUS_BUG	= 0
0059   0000~            DLG_CURSOR_AT_TOP	= 0
0060   0000~            RELOCATE_FILE_FUNCTIONS = 0
0061   0000~            NO_ROM_SWITCH_BUG	= 0
0062   0000~            
0063   0000             #endif
0064   0000             
0065   0000             ; ===========================================================================
0066   0000             ; ЏЋђ’› ‚‚Ћ„Ђ-‚›‚Ћ„Ђ
0067   0000             
0068   0000             IO_KEYB_A		= 0FFE0h
0069   0000             IO_KEYB_B		= 0FFE1h
0070   0000             IO_KEYB_C		= 0FFE2h
0071   0000             IO_KEYB_MODE		= 0FFE3h
0072   0000             IO_EXT_A		= 0FFE4h
0073   0000             IO_EXT_B		= 0FFE5h
0074   0000             IO_EXT_C		= 0FFE6h
0075   0000             IO_EXT_MODE		= 0FFE7h
0076   0000             IO_FLOPPY_CMD		= 0FFE8h
0077   0000             IO_FLOPPY_SECTOR	= 0FFEAh
0078   0000             IO_FLOPPY_DATA		= 0FFEBh
0079   0000             IO_TIMER		= 0FFECh
0080   0000             IO_FLOPPY_TRIG		= 0FFF0h
0081   0000             IO_FLOPPY_HEAD		= 0FFF2h
0082   0000             IO_COLOR		= 0FFF8h
0083   0000             IO_PAGE_RAM		= 0FFFCh
0084   0000             IO_PAGE_ARAM		= 0FFFDh
0085   0000             IO_PAGE_ROM		= 0FFFEh
0086   0000             IO_PAGE_STD		= 0FFFFh
0087   0000             
0088   0000             ; ===========================================================================
0089   0000             ; ‘Џ…–€Ђ‹њЌ›… ЉЋ„› ‘€Њ‚Ћ‹Ћ‚
0090   0000             
0091   0000             C_BEEP		= 7
0092   0000             C_LEFT		= 8
0093   0000             C_CLEARSCREEN	= 1Fh
0094   0000             C_PUSHCOLOR	= 88h
0095   0000             C_POPCOLOR	= 89h
0096   0000             C_INVERSE	= 8Bh
0097   0000             C_NORMAL	= 8Ch
0098   0000             C_PUSHCURSORL	= 8Dh
0099   0000             C_TOPLINE	= 8Fh
0100   0000             C_POPCURSORL	= 8Eh
0101   0000             C_BOTTOMLINE	= 90h
0102   0000             C_PUSHCURSORS	= 93h
0103   0000             C_POPCURSORS	= 94h
0104   0000             C_SCROLLUPEX	= 9Ah
0105   0000             
0106   0000             ; ===========================================================================
0107   0000             ; ЉЋЌ‘’ЂЌ’› Ќ…‹њ‡џ Њ…Ќџ’њ
0108   0000             
0109   0000             CHAR_HEIGHT	  	= 8
0110   0000             LINE_HEIGHT	 	= 10
0111   0000             SCREEN_HEIGHT	 	= 250
0112   0000             FILE_HEADER_SIZE	= 30
0113   0000             STACK_TOP		= 0D2FFh
0114   0000             RAM_TOP			= 8FFFh
0115   0000             
0116   0000             ; ===========================================================================
0117   0000             ; Џ…ђ…Њ…ЌЌ›…
0118   0000             
0119   C000             .org 0C000h
0120   C000             
0121   C000             charGen:
0122   C000             
0123   C000             .include "chargen.inc"
0001+  C000             ;+---------------------------------------------------------------------------
0002+  C000             ; RAMFOS
0003+  C000             ; Знакогенератор
0004+  C000             ;
0005+  C000             ; 2013-11-01 Дизассемблировано и доработано vinxru
0006+  C000             ;----------------------------------------------------------------------------
0007+  C000             
0008+  C000             ; Новая функция вывода текста использует шрифты высотой в 10 пикселей
0009+  C000             #if FAST_PRINT
0010+  C000             #define DY 80h
0011+  C000~            #else
0012+  C000~            #define DY 0
0013+  C000             #endif
0014+  C000             
0015+  C000 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 0
0015+  C004 00 00 00 00 
0016+  C008 B8 38 38 38 	.db DY|038h,038h,038h,038h,000h,000h,000h,DY|000h ; 1
0016+  C00C 00 00 00 80 
0017+  C010 87 07 07 07 	.db DY|007h,007h,007h,007h,000h,000h,000h,DY|000h ; 2
0017+  C014 00 00 00 80 
0018+  C018 BF 3F 3F 3F 	.db DY|03Fh,03Fh,03Fh,03Fh,000h,000h,000h,DY|000h ; 3
0018+  C01C 00 00 00 80 
0019+  C020 80 00 00 00 	.db DY|000h,000h,000h,000h,007h,007h,007h,DY|007h ; 4
0019+  C024 07 07 07 87 
0020+  C028 B8 38 38 38 	.db DY|038h,038h,038h,038h,007h,007h,007h,DY|007h ; 5
0020+  C02C 07 07 07 87 
0021+  C030 87 07 07 07 	.db DY|007h,007h,007h,007h,007h,007h,007h,DY|007h ; 6
0021+  C034 07 07 07 87 
0022+  C038 BF 3F 3F 3F 	.db DY|03Fh,03Fh,03Fh,03Fh,007h,007h,007h,DY|007h ; 7
0022+  C03C 07 07 07 87 
0023+  C040             #if ALL_CHARS
0024+  C040 B0 30 30 30 	.db DY|030h,030h,030h,030h,030h,030h,030h,DY|030h ; 8+
0024+  C044 30 30 30 B0 
0025+  C048~            #else
0026+  C048~            	.db 000h,000h,000h,000h,000h,000h,000h,000h
0027+  C048             #endif
0028+  C048 0C 0C 3F 2D 	.db 00Ch,00Ch,03Fh,02Dh,00Ch,00Ch,012h,021h ; 9
0028+  C04C 0C 0C 12 21 
0029+  C050             #if ALL_CHARS
0030+  C050 83 03 03 03 	.db DY|003h,003h,003h,003h,003h,003h,003h,DY|003h ; 10+
0030+  C054 03 03 03 83 
0031+  C058~            #else
0032+  C058~            	.db 000h,000h,000h,000h,000h,000h,000h,000h
0033+  C058             #endif
0034+  C058 0C 1E 3F 0C 	.db 00Ch,01Eh,03Fh,00Ch,00Ch,00Ch,00Ch,000h ; 11
0034+  C05C 0C 0C 0C 00 
0035+  C060             #if ALL_CHARS
0036+  C060 B0 30 30 30 	.db DY|030h,030h,030h,030h,030h,030h,030h,DY|03Fh ; 12+
0036+  C064 30 30 30 BF 
0037+  C068~            #else
0038+  C068~            	.db 000h,000h,000h,000h,000h,000h,000h,000h
0039+  C068             #endif
0040+  C068             #if ALL_CHARS
0041+  C068 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,DY|03Fh ; 13
0041+  C06C 00 00 00 BF 
0042+  C070~            #else
0043+  C070~            	.db 000h,000h,000h,000h,000h,000h,000h,000h
0044+  C070             #endif
0045+  C070 08 0C 3E 3F 	.db 008h,00Ch,03Eh,03Fh,03Eh,00Ch,008h,000h ; 14
0045+  C074 3E 0C 08 00 
0046+  C078 0C 0C 0C 0C 	.db 00Ch,00Ch,00Ch,00Ch,03Fh,01Eh,00Ch,000h ; 15
0046+  C07C 3F 1E 0C 00 
0047+  C080 80 00 00 00 	.db DY|000h,000h,000h,000h,038h,038h,038h,DY|038h ; 16
0047+  C084 38 38 38 B8 
0048+  C088 B8 38 38 38 	.db DY|038h,038h,038h,038h,038h,038h,038h,DY|038h ; 17
0048+  C08C 38 38 38 B8 
0049+  C090 87 07 07 07 	.db DY|007h,007h,007h,007h,038h,038h,038h,DY|038h ; 18
0049+  C094 38 38 38 B8 
0050+  C098 BF 3F 3F 3F 	.db DY|03Fh,03Fh,03Fh,03Fh,038h,038h,038h,DY|038h ; 19
0050+  C09C 38 38 38 B8 
0051+  C0A0 80 00 00 00 	.db DY|000h,000h,000h,000h,03Fh,03Fh,03Fh,DY|03Fh ; 20
0051+  C0A4 3F 3F 3F BF 
0052+  C0A8 B8 38 38 38 	.db DY|038h,038h,038h,038h,03Fh,03Fh,03Fh,DY|03Fh ; 21
0052+  C0AC 3F 3F 3F BF 
0053+  C0B0 87 07 07 07 	.db DY|007h,007h,007h,007h,03Fh,03Fh,03Fh,DY|03Fh ; 22
0053+  C0B4 3F 3F 3F BF 
0054+  C0B8 BF 3F 3F 3F 	.db DY|03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,DY|03Fh ; 23
0054+  C0BC 3F 3F 3F BF 
0055+  C0C0             #if ALL_CHARS
0056+  C0C0 83 03 03 03 	.db DY|003h,003h,003h,003h,003h,003h,003h,DY|03Fh ; 24+
0056+  C0C4 03 03 03 BF 
0057+  C0C8~            #else
0058+  C0C8~            	.db 000h,000h,000h,000h,000h,000h,000h,000h
0059+  C0C8             #endif
0060+  C0C8             #if ALL_CHARS
0061+  C0C8 A0 20 20 20 	.db DY|020h,020h,020h,020h,020h,020h,020h,DY|020h ; 25+
0061+  C0CC 20 20 20 A0 
0062+  C0D0~            #else
0063+  C0D0~            	.db 000h,000h,000h,000h,000h,000h,000h,000h
0064+  C0D0             #endif
0065+  C0D0 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 26
0065+  C0D4 00 00 00 00 
0066+  C0D8 0C 0C 0C 0C 	.db 00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch ; 27
0066+  C0DC 0C 0C 0C 0C 
0067+  C0E0 00 00 00 3F 	.db 000h,000h,000h,03Fh,03Fh,000h,000h,000h ; 28
0067+  C0E4 3F 00 00 00 
0068+  C0E8 04 0C 1F 3F 	.db 004h,00Ch,01Fh,03Fh,01Fh,00Ch,004h,000h ; 29
0068+  C0EC 1F 0C 04 00 
0069+  C0F0 00 3E 3C 3C 	.db 000h,03Eh,03Ch,03Ch,03Eh,027h,002h,000h ; 30
0069+  C0F4 3E 27 02 00 
0070+  C0F8 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 31
0070+  C0FC 00 00 00 00 
0071+  C100 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,000h,000h ; 32
0071+  C104 00 00 00 00 
0072+  C108 04 04 04 04 	.db 004h,004h,004h,004h,004h,000h,004h,000h ; 33
0072+  C10C 04 00 04 00 
0073+  C110 0A 0A 0A 00 	.db 00Ah,00Ah,00Ah,000h,000h,000h,000h,000h ; 34
0073+  C114 00 00 00 00 
0074+  C118 0A 0A 1F 0A 	.db 00Ah,00Ah,01Fh,00Ah,01Fh,00Ah,00Ah,000h ; 35
0074+  C11C 1F 0A 0A 00 
0075+  C120 00 11 0E 0A 	.db 000h,011h,00Eh,00Ah,00Eh,011h,000h,000h ; 36
0075+  C124 0E 11 00 00 
0076+  C128 18 19 02 04 	.db 018h,019h,002h,004h,008h,013h,003h,000h ; 37
0076+  C12C 08 13 03 00 
0077+  C130 04 0A 0A 0C 	.db 004h,00Ah,00Ah,00Ch,015h,012h,00Dh,000h ; 38
0077+  C134 15 12 0D 00 
0078+  C138 06 06 02 04 	.db 006h,006h,002h,004h,000h,000h,000h,000h ; 39
0078+  C13C 00 00 00 00 
0079+  C140 02 04 08 08 	.db 002h,004h,008h,008h,008h,004h,002h,000h ; 40
0079+  C144 08 04 02 00 
0080+  C148 08 04 02 02 	.db 008h,004h,002h,002h,002h,004h,008h,000h ; 41
0080+  C14C 02 04 08 00 
0081+  C150 00 04 15 0E 	.db 000h,004h,015h,00Eh,015h,004h,000h,000h ; 42
0081+  C154 15 04 00 00 
0082+  C158 00 04 04 1F 	.db 000h,004h,004h,01Fh,004h,004h,000h,000h ; 43
0082+  C15C 04 04 00 00 
0083+  C160 00 00 00 00 	.db 000h,000h,000h,000h,00Ch,00Ch,004h,008h ; 44
0083+  C164 0C 0C 04 08 
0084+  C168 00 00 00 1F 	.db 000h,000h,000h,01Fh,000h,000h,000h,000h ; 45
0084+  C16C 00 00 00 00 
0085+  C170 00 00 00 00 	.db 000h,000h,000h,000h,000h,00Ch,00Ch,000h ; 46
0085+  C174 00 0C 0C 00 
0086+  C178 00 01 02 04 	.db 000h,001h,002h,004h,008h,010h,000h,000h ; 47
0086+  C17C 08 10 00 00 
0087+  C180 0E 11 13 15 	.db 00Eh,011h,013h,015h,019h,011h,00Eh,000h ; 48
0087+  C184 19 11 0E 00 
0088+  C188 04 0C 04 04 	.db 004h,00Ch,004h,004h,004h,004h,00Eh,000h ; 49
0088+  C18C 04 04 0E 00 
0089+  C190 0E 11 01 06 	.db 00Eh,011h,001h,006h,008h,010h,01Fh,000h ; 50
0089+  C194 08 10 1F 00 
0090+  C198 1F 01 02 06 	.db 01Fh,001h,002h,006h,001h,011h,00Eh,000h ; 51
0090+  C19C 01 11 0E 00 
0091+  C1A0 02 06 0A 12 	.db 002h,006h,00Ah,012h,01Fh,002h,002h,000h ; 52
0091+  C1A4 1F 02 02 00 
0092+  C1A8 1F 10 1E 01 	.db 01Fh,010h,01Eh,001h,001h,011h,00Eh,000h ; 53
0092+  C1AC 01 11 0E 00 
0093+  C1B0 07 08 10 1E 	.db 007h,008h,010h,01Eh,011h,011h,00Eh,000h ; 54
0093+  C1B4 11 11 0E 00 
0094+  C1B8 1F 01 02 04 	.db 01Fh,001h,002h,004h,008h,008h,008h,000h ; 55
0094+  C1BC 08 08 08 00 
0095+  C1C0 0E 11 11 0E 	.db 00Eh,011h,011h,00Eh,011h,011h,00Eh,000h ; 56
0095+  C1C4 11 11 0E 00 
0096+  C1C8 0E 11 11 0F 	.db 00Eh,011h,011h,00Fh,001h,002h,01Ch,000h ; 57
0096+  C1CC 01 02 1C 00 
0097+  C1D0 00 0C 0C 00 	.db 000h,00Ch,00Ch,000h,000h,00Ch,00Ch,000h ; 58
0097+  C1D4 00 0C 0C 00 
0098+  C1D8 0C 0C 00 00 	.db 00Ch,00Ch,000h,000h,00Ch,00Ch,004h,008h ; 59
0098+  C1DC 0C 0C 04 08 
0099+  C1E0 02 04 08 10 	.db 002h,004h,008h,010h,008h,004h,002h,000h ; 60
0099+  C1E4 08 04 02 00 
0100+  C1E8 00 00 1F 00 	.db 000h,000h,01Fh,000h,01Fh,000h,000h,000h ; 61
0100+  C1EC 1F 00 00 00 
0101+  C1F0 08 04 02 01 	.db 008h,004h,002h,001h,002h,004h,008h,000h ; 62
0101+  C1F4 02 04 08 00 
0102+  C1F8 0E 11 01 02 	.db 00Eh,011h,001h,002h,004h,000h,004h,000h ; 63
0102+  C1FC 04 00 04 00 
0103+  C200 0E 11 13 15 	.db 00Eh,011h,013h,015h,017h,010h,00Eh,000h ; 64
0103+  C204 17 10 0E 00 
0104+  C208 04 0A 11 11 	.db 004h,00Ah,011h,011h,01Fh,011h,011h,000h ; 65
0104+  C20C 1F 11 11 00 
0105+  C210 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 66
0105+  C214 11 11 1E 00 
0106+  C218 0E 11 10 10 	.db 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 67
0106+  C21C 10 11 0E 00 
0107+  C220 1E 09 09 09 	.db 01Eh,009h,009h,009h,009h,009h,01Eh,000h ; 68
0107+  C224 09 09 1E 00 
0108+  C228 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 69
0108+  C22C 10 10 1F 00 
0109+  C230 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,010h,010h,010h,000h ; 70
0109+  C234 10 10 10 00 
0110+  C238 0E 11 10 10 	.db 00Eh,011h,010h,010h,013h,011h,00Fh,000h ; 71
0110+  C23C 13 11 0F 00 
0111+  C240 11 11 11 1F 	.db 011h,011h,011h,01Fh,011h,011h,011h,000h ; 72
0111+  C244 11 11 11 00 
0112+  C248 0E 04 04 04 	.db 00Eh,004h,004h,004h,004h,004h,00Eh,000h ; 73
0112+  C24C 04 04 0E 00 
0113+  C250 01 01 01 01 	.db 001h,001h,001h,001h,011h,011h,00Eh,000h ; 74
0113+  C254 11 11 0E 00 
0114+  C258 11 12 14 18 	.db 011h,012h,014h,018h,014h,012h,011h,000h ; 75
0114+  C25C 14 12 11 00 
0115+  C260 10 10 10 10 	.db 010h,010h,010h,010h,010h,011h,01Fh,000h ; 76
0115+  C264 10 11 1F 00 
0116+  C268 11 1B 15 15 	.db 011h,01Bh,015h,015h,011h,011h,011h,000h ; 77
0116+  C26C 11 11 11 00 
0117+  C270 11 11 19 15 	.db 011h,011h,019h,015h,013h,011h,011h,000h ; 78
0117+  C274 13 11 11 00 
0118+  C278 0E 11 11 11 	.db 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 79
0118+  C27C 11 11 0E 00 
0119+  C280 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 80
0119+  C284 10 10 10 00 
0120+  C288 0E 11 11 11 	.db 00Eh,011h,011h,011h,015h,012h,00Dh,000h ; 81
0120+  C28C 15 12 0D 00 
0121+  C290 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,014h,012h,011h,000h ; 82
0121+  C294 14 12 11 00 
0122+  C298 0E 11 10 0E 	.db 00Eh,011h,010h,00Eh,001h,011h,00Eh,000h ; 83
0122+  C29C 01 11 0E 00 
0123+  C2A0 1F 04 04 04 	.db 01Fh,004h,004h,004h,004h,004h,004h,000h ; 84
0123+  C2A4 04 04 04 00 
0124+  C2A8 11 11 11 11 	.db 011h,011h,011h,011h,011h,011h,00Eh,000h ; 85
0124+  C2AC 11 11 0E 00 
0125+  C2B0 11 11 11 0A 	.db 011h,011h,011h,00Ah,00Ah,004h,004h,000h ; 86
0125+  C2B4 0A 04 04 00 
0126+  C2B8 11 11 11 15 	.db 011h,011h,011h,015h,015h,015h,00Ah,000h ; 87
0126+  C2BC 15 15 0A 00 
0127+  C2C0 11 11 0A 04 	.db 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 88
0127+  C2C4 0A 11 11 00 
0128+  C2C8 11 11 0A 04 	.db 011h,011h,00Ah,004h,004h,004h,004h,000h ; 89
0128+  C2CC 04 04 04 00 
0129+  C2D0 1F 01 02 0E 	.db 01Fh,001h,002h,00Eh,008h,010h,01Fh,000h ; 90
0129+  C2D4 08 10 1F 00 
0130+  C2D8 0E 08 08 08 	.db 00Eh,008h,008h,008h,008h,008h,00Eh,000h ; 91
0130+  C2DC 08 08 0E 00 
0131+  C2E0 00 10 08 04 	.db 000h,010h,008h,004h,002h,001h,000h,000h ; 92
0131+  C2E4 02 01 00 00 
0132+  C2E8 0E 02 02 02 	.db 00Eh,002h,002h,002h,002h,002h,00Eh,000h ; 93
0132+  C2EC 02 02 0E 00 
0133+  C2F0 0E 11 00 00 	.db 00Eh,011h,000h,000h,000h,000h,000h,000h ; 94
0133+  C2F4 00 00 00 00 
0134+  C2F8 00 00 00 00 	.db 000h,000h,000h,000h,000h,000h,01Fh,000h ; 95
0134+  C2FC 00 00 1F 00 
0135+  C300 00 08 04 02 	.db 000h,008h,004h,002h,000h,000h,000h,000h ; 96
0135+  C304 00 00 00 00 
0136+  C308 00 00 0E 01 	.db 000h,000h,00Eh,001h,00Fh,011h,00Fh,000h ; 97
0136+  C30C 0F 11 0F 00 
0137+  C310 10 10 10 1E 	.db 010h,010h,010h,01Eh,011h,011h,01Eh,000h ; 98
0137+  C314 11 11 1E 00 
0138+  C318 00 00 0F 10 	.db 000h,000h,00Fh,010h,010h,010h,00Fh,000h ; 99
0138+  C31C 10 10 0F 00 
0139+  C320 01 01 01 0F 	.db 001h,001h,001h,00Fh,011h,011h,00Fh,000h ; 100
0139+  C324 11 11 0F 00 
0140+  C328 00 00 0E 11 	.db 000h,000h,00Eh,011h,01Fh,010h,00Fh,000h ; 101
0140+  C32C 1F 10 0F 00 
0141+  C330 03 04 04 1F 	.db 003h,004h,004h,01Fh,004h,004h,004h,000h ; 102
0141+  C334 04 04 04 00 
0142+  C338 00 00 0F 11 	.db 000h,000h,00Fh,011h,00Fh,001h,011h,00Eh ; 103
0142+  C33C 0F 01 11 0E 
0143+  C340 10 10 10 1E 	.db 010h,010h,010h,01Eh,011h,011h,011h,000h ; 104
0143+  C344 11 11 11 00 
0144+  C348 00 04 00 0C 	.db 000h,004h,000h,00Ch,004h,004h,00Eh,000h ; 105
0144+  C34C 04 04 0E 00 
0145+  C350 02 00 02 02 	.db 002h,000h,002h,002h,002h,012h,00Ch,000h ; 106
0145+  C354 02 12 0C 00 
0146+  C358 10 10 12 14 	.db 010h,010h,012h,014h,018h,014h,012h,000h ; 107
0146+  C35C 18 14 12 00 
0147+  C360 0C 04 04 04 	.db 00Ch,004h,004h,004h,004h,004h,00Eh,000h ; 108
0147+  C364 04 04 0E 00 
0148+  C368 00 00 15 1F 	.db 000h,000h,015h,01Fh,015h,015h,015h,000h ; 109
0148+  C36C 15 15 15 00 
0149+  C370 00 00 1E 11 	.db 000h,000h,01Eh,011h,011h,011h,011h,000h ; 110
0149+  C374 11 11 11 00 
0150+  C378 00 00 0E 11 	.db 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 111
0150+  C37C 11 11 0E 00 
0151+  C380 00 00 1E 11 	.db 000h,000h,01Eh,011h,011h,01Eh,010h,010h ; 112
0151+  C384 11 1E 10 10 
0152+  C388 00 00 0F 11 	.db 000h,000h,00Fh,011h,011h,00Fh,001h,001h ; 113
0152+  C38C 11 0F 01 01 
0153+  C390 00 00 17 18 	.db 000h,000h,017h,018h,010h,010h,010h,000h ; 114
0153+  C394 10 10 10 00 
0154+  C398 00 00 0F 10 	.db 000h,000h,00Fh,010h,00Eh,001h,01Eh,000h ; 115
0154+  C39C 0E 01 1E 00 
0155+  C3A0 08 08 1E 08 	.db 008h,008h,01Eh,008h,008h,008h,007h,000h ; 116
0155+  C3A4 08 08 07 00 
0156+  C3A8 00 00 11 11 	.db 000h,000h,011h,011h,011h,011h,00Fh,000h ; 117
0156+  C3AC 11 11 0F 00 
0157+  C3B0 00 00 11 11 	.db 000h,000h,011h,011h,00Ah,00Ah,004h,000h ; 118
0157+  C3B4 0A 0A 04 00 
0158+  C3B8 00 00 11 11 	.db 000h,000h,011h,011h,015h,015h,00Ah,000h ; 119
0158+  C3BC 15 15 0A 00 
0159+  C3C0 00 00 11 0A 	.db 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 120
0159+  C3C4 04 0A 11 00 
0160+  C3C8 00 00 11 0A 	.db 000h,000h,011h,00Ah,004h,004h,004h,000h ; 121
0160+  C3CC 04 04 04 00 
0161+  C3D0 00 00 1F 02 	.db 000h,000h,01Fh,002h,004h,008h,01Fh,000h ; 122
0161+  C3D4 04 08 1F 00 
0162+  C3D8 03 04 04 08 	.db 003h,004h,004h,008h,004h,004h,003h,000h ; 123
0162+  C3DC 04 04 03 00 
0163+  C3E0 04 04 04 04 	.db 004h,004h,004h,004h,004h,004h,004h,000h ; 124
0163+  C3E4 04 04 04 00 
0164+  C3E8 18 04 04 02 	.db 018h,004h,004h,002h,004h,004h,018h,000h ; 125
0164+  C3EC 04 04 18 00 
0165+  C3F0 1F 00 00 00 	.db 01Fh,000h,000h,000h,000h,000h,000h,000h ; 126
0165+  C3F4 00 00 00 00 
0166+  C3F8 1F 1F 1F 1F 	.db 01Fh,01Fh,01Fh,01Fh,01Fh,01Fh,01Fh,01Fh ; 127
0166+  C3FC 1F 1F 1F 1F 
0167+  C400 00 00 12 15 	.db 000h,000h,012h,015h,01Dh,015h,012h,000h ; 128
0167+  C404 1D 15 12 00 
0168+  C408 00 00 0C 02 	.db 000h,000h,00Ch,002h,00Eh,012h,00Fh,000h ; 129
0168+  C40C 0E 12 0F 00 
0169+  C410 01 0E 18 1E 	.db 001h,00Eh,018h,01Eh,011h,011h,00Eh,000h ; 130
0169+  C414 11 11 0E 00 
0170+  C418 00 00 12 12 	.db 000h,000h,012h,012h,012h,012h,01Fh,001h ; 131
0170+  C41C 12 12 1F 01 
0171+  C420 00 00 06 0A 	.db 000h,000h,006h,00Ah,00Ah,00Ah,01Fh,011h ; 132
0171+  C424 0A 0A 1F 11 
0172+  C428 00 00 0E 11 	.db 000h,000h,00Eh,011h,01Fh,010h,00Fh,000h ; 133
0172+  C42C 1F 10 0F 00 
0173+  C430 00 04 0E 15 	.db 000h,004h,00Eh,015h,015h,015h,00Eh,004h ; 134
0173+  C434 15 15 0E 04 
0174+  C438 00 00 1F 10 	.db 000h,000h,01Fh,010h,010h,010h,010h,000h ; 135
0174+  C43C 10 10 10 00 
0175+  C440 00 00 11 0A 	.db 000h,000h,011h,00Ah,004h,00Ah,011h,000h ; 136
0175+  C444 04 0A 11 00 
0176+  C448 00 00 11 13 	.db 000h,000h,011h,013h,015h,019h,011h,000h ; 137
0176+  C44C 15 19 11 00 
0177+  C450 00 04 11 13 	.db 000h,004h,011h,013h,015h,019h,011h,000h ; 138
0177+  C454 15 19 11 00 
0178+  C458 00 00 11 12 	.db 000h,000h,011h,012h,014h,01Ch,013h,000h ; 139
0178+  C45C 14 1C 13 00 
0179+  C460 00 00 07 09 	.db 000h,000h,007h,009h,009h,009h,019h,000h ; 140
0179+  C464 09 09 19 00 
0180+  C468 00 00 11 1B 	.db 000h,000h,011h,01Bh,015h,011h,011h,000h ; 141
0180+  C46C 15 11 11 00 
0181+  C470 00 00 11 11 	.db 000h,000h,011h,011h,01Fh,011h,011h,000h ; 142
0181+  C474 1F 11 11 00 
0182+  C478 00 00 0E 11 	.db 000h,000h,00Eh,011h,011h,011h,00Eh,000h ; 143
0182+  C47C 11 11 0E 00 
0183+  C480 00 00 1F 11 	.db 000h,000h,01Fh,011h,011h,011h,011h,000h ; 144
0183+  C484 11 11 11 00 
0184+  C488 00 00 0F 11 	.db 000h,000h,00Fh,011h,00Fh,009h,011h,000h ; 145
0184+  C48C 0F 09 11 00 
0185+  C490 00 00 1E 11 	.db 000h,000h,01Eh,011h,011h,01Eh,010h,010h ; 146
0185+  C494 11 1E 10 10 
0186+  C498 00 00 0E 11 	.db 000h,000h,00Eh,011h,010h,011h,00Eh,000h ; 147
0186+  C49C 10 11 0E 00 
0187+  C4A0 00 00 1F 04 	.db 000h,000h,01Fh,004h,004h,004h,004h,000h ; 148
0187+  C4A4 04 04 04 00 
0188+  C4A8 00 00 11 11 	.db 000h,000h,011h,011h,00Fh,001h,01Eh,000h ; 149
0188+  C4AC 0F 01 1E 00 
0189+  C4B0 00 00 15 15 	.db 000h,000h,015h,015h,00Eh,015h,015h,000h ; 150
0189+  C4B4 0E 15 15 00 
0190+  C4B8 00 00 1C 12 	.db 000h,000h,01Ch,012h,01Eh,011h,01Eh,000h ; 151
0190+  C4BC 1E 11 1E 00 
0191+  C4C0 00 00 10 10 	.db 000h,000h,010h,010h,01Eh,011h,01Eh,000h ; 152
0191+  C4C4 1E 11 1E 00 
0192+  C4C8 00 00 11 11 	.db 000h,000h,011h,011h,01Dh,015h,01Dh,000h ; 153
0192+  C4CC 1D 15 1D 00 
0193+  C4D0 00 00 0E 11 	.db 000h,000h,00Eh,011h,006h,011h,00Eh,000h ; 154
0193+  C4D4 06 11 0E 00 
0194+  C4D8 00 00 15 15 	.db 000h,000h,015h,015h,015h,015h,01Fh,000h ; 155
0194+  C4DC 15 15 1F 00 
0195+  C4E0 00 00 1E 01 	.db 000h,000h,01Eh,001h,00Fh,001h,01Eh,000h ; 156
0195+  C4E4 0F 01 1E 00 
0196+  C4E8 00 00 15 15 	.db 000h,000h,015h,015h,015h,015h,01Fh,001h ; 157
0196+  C4EC 15 15 1F 01 
0197+  C4F0 00 00 11 11 	.db 000h,000h,011h,011h,00Fh,001h,001h,000h ; 158
0197+  C4F4 0F 01 01 00 
0198+  C4F8 00 00 18 08 	.db 000h,000h,018h,008h,00Eh,009h,00Eh,000h ; 159
0198+  C4FC 0E 09 0E 00 
0199+  C500 12 15 15 1D 	.db 012h,015h,015h,01Dh,015h,015h,012h,000h ; 160
0199+  C504 15 15 12 00 
0200+  C508 04 0A 11 11 	.db 004h,00Ah,011h,011h,01Fh,011h,011h,000h ; 161
0200+  C50C 1F 11 11 00 
0201+  C510 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,011h,011h,01Eh,000h ; 162
0201+  C514 11 11 1E 00 
0202+  C518 12 12 12 12 	.db 012h,012h,012h,012h,012h,012h,01Fh,001h ; 163
0202+  C51C 12 12 1F 01 
0203+  C520 06 0A 0A 0A 	.db 006h,00Ah,00Ah,00Ah,00Ah,00Ah,01Fh,011h ; 164
0203+  C524 0A 0A 1F 11 
0204+  C528 1F 10 10 1E 	.db 01Fh,010h,010h,01Eh,010h,010h,01Fh,000h ; 165
0204+  C52C 10 10 1F 00 
0205+  C530 04 1F 15 15 	.db 004h,01Fh,015h,015h,01Fh,004h,004h,000h ; 166
0205+  C534 1F 04 04 00 
0206+  C538 1F 11 10 10 	.db 01Fh,011h,010h,010h,010h,010h,010h,000h ; 167
0206+  C53C 10 10 10 00 
0207+  C540 11 11 0A 04 	.db 011h,011h,00Ah,004h,00Ah,011h,011h,000h ; 168
0207+  C544 0A 11 11 00 
0208+  C548 11 11 13 15 	.db 011h,011h,013h,015h,019h,011h,011h,000h ; 169
0208+  C54C 19 11 11 00 
0209+  C550 15 11 13 15 	.db 015h,011h,013h,015h,019h,011h,011h,000h ; 170
0209+  C554 19 11 11 00 
0210+  C558 11 12 14 18 	.db 011h,012h,014h,018h,014h,012h,011h,000h ; 171
0210+  C55C 14 12 11 00 
0211+  C560 03 05 09 09 	.db 003h,005h,009h,009h,009h,009h,019h,000h ; 172
0211+  C564 09 09 19 00 
0212+  C568 11 1B 15 15 	.db 011h,01Bh,015h,015h,011h,011h,011h,000h ; 173
0212+  C56C 11 11 11 00 
0213+  C570 11 11 11 1F 	.db 011h,011h,011h,01Fh,011h,011h,011h,000h ; 174
0213+  C574 11 11 11 00 
0214+  C578 0E 11 11 11 	.db 00Eh,011h,011h,011h,011h,011h,00Eh,000h ; 175
0214+  C57C 11 11 0E 00 
0215+  C580 1F 11 11 11 	.db 01Fh,011h,011h,011h,011h,011h,011h,000h ; 176
0215+  C584 11 11 11 00 
0216+  C588 0F 11 11 0F 	.db 00Fh,011h,011h,00Fh,005h,009h,011h,000h ; 177
0216+  C58C 05 09 11 00 
0217+  C590 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,010h,010h,010h,000h ; 178
0217+  C594 10 10 10 00 
0218+  C598 0E 11 10 10 	.db 00Eh,011h,010h,010h,010h,011h,00Eh,000h ; 179
0218+  C59C 10 11 0E 00 
0219+  C5A0 1F 04 04 04 	.db 01Fh,004h,004h,004h,004h,004h,004h,000h ; 180
0219+  C5A4 04 04 04 00 
0220+  C5A8 11 11 11 0A 	.db 011h,011h,011h,00Ah,004h,008h,010h,000h ; 181
0220+  C5AC 04 08 10 00 
0221+  C5B0 11 15 15 0E 	.db 011h,015h,015h,00Eh,015h,015h,011h,000h ; 182
0221+  C5B4 15 15 11 00 
0222+  C5B8 1E 11 11 1E 	.db 01Eh,011h,011h,01Eh,011h,011h,01Eh,000h ; 183
0222+  C5BC 11 11 1E 00 
0223+  C5C0 10 10 10 1E 	.db 010h,010h,010h,01Eh,011h,011h,01Eh,000h ; 184
0223+  C5C4 11 11 1E 00 
0224+  C5C8 11 11 11 19 	.db 011h,011h,011h,019h,015h,015h,019h,000h ; 185
0224+  C5CC 15 15 19 00 
0225+  C5D0 0E 11 01 06 	.db 00Eh,011h,001h,006h,001h,011h,00Eh,000h ; 186
0225+  C5D4 01 11 0E 00 
0226+  C5D8 11 15 15 15 	.db 011h,015h,015h,015h,015h,015h,01Fh,000h ; 187
0226+  C5DC 15 15 1F 00 
0227+  C5E0 0E 11 01 07 	.db 00Eh,011h,001h,007h,001h,011h,00Eh,000h ; 188
0227+  C5E4 01 11 0E 00 
0228+  C5E8 15 15 15 15 	.db 015h,015h,015h,015h,015h,015h,01Fh,001h ; 189
0228+  C5EC 15 15 1F 01 
0229+  C5F0 11 11 11 1F 	.db 011h,011h,011h,01Fh,001h,001h,001h,000h ; 190
0229+  C5F4 01 01 01 00 
0230+  C5F8 3F 3F 3F 3F 	.db 03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh,03Fh
0230+  C5FC 3F 3F 3F 3F 
0231+  C600             
0232+  C600             #undef DY0124   C600             
0125   C600             keybMap:
0126   C600             
0127   C600 81 0C 19 1A 		.db 81h, 0ch, 19h, 1ah, 20h, 20h, 20h, 08h, 09h, 18h, 0ah, 0dh ; ЌЁ¦­пп бва®Є  Є« ўЁ вгал
0127   C604 20 20 20 08 
0127   C608 09 18 0A 0D 
0128   C60C 00 C0       v_charGenPtr:	.dw charGen
0129   C60E 00 C6       v_keybMap:	.dw keybMap
0130   C610 51 5E 53 4D 		.db 51h, 5Eh, 53h, 4Dh,	49h, 54h, 58h, 42h, 40h, 2Ch, 2Fh, 5Fh ; Q^SMITXB@,/_
0130   C614 49 54 58 42 
0130   C618 40 2C 2F 5F 
0131   C61C BB FF       v_aramPageEnd:	.dw ARAM_PAGE_END
0132   C61E 00 00       v_aramPageStart:.dw 0
0133   C620 46 59 57 41 		.db 46h, 59h, 57h, 41h,	50h, 52h, 4Fh, 4Ch, 44h, 56h, 5Ch, 2Eh; FYWAPROLDV\.
0133   C624 50 52 4F 4C 
0133   C628 44 56 5C 2E 
0134   C62C 00          v_koi8:		.db 0	; ЉЋ€-7=FF / ЉЋ€-8=00
0135   C62D 00          v_rusLat:	.db 0	; ђ“‘=FF / LAT=00
0136   C62E 00          v_capsLock:	.db 0	; BP=00 / HP=02
0137   C62F 00          v_printerEcho:	.db 0
0138   C630 4A 43 55 4B 		.db 4Ah, 43h, 55h, 4Bh, 45h, 4Eh, 47h, 5Bh, 5Dh, 5Ah, 48h, 3Ah ; JCUKENG[]ZH:
0138   C634 45 4E 47 5B 
0138   C638 5D 5A 48 3A 
0139   C63C B1          v_selColor:	.db 0B1h
0140   C63D 00          v_aramMaxPage:	.db 0			; Ќ®¬Ґа	Ї®б«Ґ¤­Ґ© бва ­Ёжл RAM-¤ЁбЄ 
0141   C63E 00 00       v_cursorPos:	.dw 0			; Џ®«®¦Ґ­ЁҐ Єгаб®а  ў ЇЁЄбҐ«пе
0142   C640 3B 31 32 33 		.db 3Bh, 31h, 32h, 33h,	34h, 35h, 36h, 37h, 38h, 39h, 30h, 2Dh ; ;1234567890-
0142   C644 34 35 36 37 
0142   C648 38 39 30 2D 
0143   C64C 05 0A       v_beepConfig:	.dw 0A05h
0144   C64E 00 00       v_oldBeep:	.dw 0
0145   C650 1B 8A 00 01 		.db 1Bh, 8Ah, 0, 1, 2, 3, 4, 5,	6, 8Bh,	8Ch, 1Fh ; ‚Ґае­пп бва®Є  Є« ўЁ вгал
0145   C654 02 03 04 05 
0145   C658 06 8B 8C 1F 
0146   C65C 00          v_clearScreenByte:.db 0
0147   C65D 00          		.db 0
0148   C65E 0F          v_aramMaxPageI	.db ARAM_MAX_PAGE
0149   C65F 30          v_tapeMode:	.db '0'
0150   C660 2C 32       v_tapePulseB:	.dw 322Ch	; 1200 Ѓ®¤
0151   C662 12 18       v_tapePulseA:	.dw 1812h
0152   C664 1B 21       v_tapePulseB2:	.dw 211Bh	; 1800 Ѓ®¤
0153   C666 09 0F       v_tapePulseA2:	.dw 0F09h
0154   C668 12 18       v_tapePulseB3:	.dw 1812h	; 2400 Ѓ®¤
0155   C66A 05 0B       v_tapePulseA3:	.dw 0B05h
0156   C66C             v_tapePresets:
0157   C66C             
0158   C66C             ; ===========================================================================
0159   C66C             ; ЉЋ„
0160   C66C             
0161   C66C             .org 0C66Ch
0162   C66C             
0163   C66C             .include "tapeReadPilot.inc"
0001+  C66C             ;----------------------------------------------------------------------------
0002+  C66C             ; RAMFOS
0003+  C66C             ; Стандартная точка входа C824
0004+  C66C             ; Чтение пилот тона с ленты
0005+  C66C             ;
0006+  C66C             ; 2013-11-01 Дизассемблировано vinxru
0007+  C66C             ;----------------------------------------------------------------------------
0008+  C66C             
0009+  C66C E5          tapeReadPilot:	push	h
0010+  C66D D5          		push	d
0011+  C66E C5          		push	b
0012+  C66F             
0013+  C66F             		; Промежуточный адрес возврата
0014+  C66F 21 A2 CB    		lxi	h, popa_ret
0015+  C672 E5          		push	h
0016+  C673             
0017+  C673             		; Порт магнитофона
0018+  C673 21 E1 FF    		lxi	h, IO_KEYB_B
0019+  C676             
0020+  C676 1E 01       		mvi	e, 1		
0021+  C678 16 00       loc_C678:	 mvi	d, 0
0022+  C67A 41          loc_C67A:	 mov	b, c
0023+  C67B CD AB C6    		 call	tapeWaitC3
0024+  C67E 79          		 mov	a, c
0025+  C67F 90          		 sub	b
0026+  C680 D2 84 C6    		 jnc	loc_C684
0027+  C683 2F          		  cma
0028+  C684 FE 03       loc_C684:	 cpi	3
0029+  C686 D2 78 C6    		jnc	loc_C678
0030+  C689 15          		dcr	d
0031+  C68A C2 7A C6    		jnz	loc_C67A
0032+  C68D             
0033+  C68D CD AB C6    		call	tapeWaitC3
0034+  C690             
0035+  C690             		; Повторить D раз
0036+  C690 01 00 01    		lxi	b, 100h		
0037+  C693 CD AD C6    loc_C693:	 call	tapeWait
0038+  C696 03          		 inx	b
0039+  C697 03          		 inx	b
0040+  C698 15          		 dcr	d
0041+  C699 C2 93 C6    		jnz	loc_C693
0042+  C69C             
0043+  C69C 69          		mov	l, c
0044+  C69D 60          		mov	h, b
0045+  C69E B7          		ora	a
0046+  C69F             
0047+  C69F             		; bc >>= 1
0048+  C69F 78          		mov	a, b
0049+  C6A0 1F          		rar
0050+  C6A1 47          		mov	b, a
0051+  C6A2 79          		mov	a, c
0052+  C6A3 1F          		rar
0053+  C6A4 4F          		mov	c, a
0054+  C6A5             
0055+  C6A5 09          		dad	b
0056+  C6A6 6B          		mov	l, e
0057+  C6A7 22 F0 D1    		shld	v_tape
0058+  C6AA C9          		ret
0164   C6AB             .include "tapeWait.inc"
0001+  C6AB             ;+---------------------------------------------------------------------------
0002+  C6AB             ; RAMFOS
0003+  C6AB             ; Ожидание изменения порта магнитофона и замер времени в bс
0004+  C6AB             ;
0005+  C6AB             ; 2013-11-01 Дизассемблировано vinxru
0006+  C6AB             ;----------------------------------------------------------------------------
0007+  C6AB             
0008+  C6AB 0E 03       tapeWaitC3:	mvi	c, 3
0009+  C6AD 7B          tapeWait:	mov	a, e
0010+  C6AE EE 01       		xri	1
0011+  C6B0 5F          		mov	e, a		
0012+  C6B1 03          tapeWait_0:	 inx	b
0013+  C6B2 7E          		 mov	a, m
0014+  C6B3 AB          		 xra	e
0015+  C6B4 E2 B1 C6    		jpo	tapeWait_0
0016+  C6B7 0F          		rrc
0017+  C6B8 0F          		rrc
0018+  C6B9 D8          		rc
0019+  C6BA E1          		pop	h
0020+  C6BB C3 0B C7    		jmp	tapeError0165   C6BE             .include "tapeRead.inc"
0001+  C6BE             ;----------------------------------------------------------------------------
0002+  C6BE             ; RAMFOS
0003+  C6BE             ; Стандартная точка входа C806
0004+  C6BE             ; Чтение байта с лента
0005+  C6BE             ;
0006+  C6BE             ; 2013-11-01 Дизассемблировано vinxru
0007+  C6BE             ;----------------------------------------------------------------------------
0008+  C6BE             
0009+  C6BE E5          tapeRead:	push	h
0010+  C6BF D5          		push	d
0011+  C6C0 C5          		push	b
0012+  C6C1             
0013+  C6C1             		; Промежуточный адрес возврата
0014+  C6C1 21 A2 CB    		lxi	h, popa_ret
0015+  C6C4 E5          		push	h
0016+  C6C5             
0017+  C6C5 2A F0 D1    		lhld	v_tape
0018+  C6C8 EB          		xchg
0019+  C6C9 21 E1 FF    		lxi	h, 0FFE1h
0020+  C6CC             
0021+  C6CC 06 08       		mvi	b, 8
0022+  C6CE CD AB C6    tapeRead_0:	 call	tapeWaitC3
0023+  C6D1 79          		 mov	a, c
0024+  C6D2 BA          		 cmp	d
0025+  C6D3 DA CE C6    		 jc	tapeRead_0
0026+  C6D6 CD AB C6    		 call	tapeWaitC3
0027+  C6D9 79          		 mov	a, c
0028+  C6DA BA          		 cmp	d
0029+  C6DB DA CE C6    		jc	tapeRead_0
0030+  C6DE             
0031+  C6DE CD AB C6    tapeRead_1:	 call	tapeWaitC3
0032+  C6E1 3A F1 D1    		 lda	v_tape+1
0033+  C6E4 B9          		 cmp	c
0034+  C6E5 3F          		 cmc
0035+  C6E6 7A          		 mov	a, d
0036+  C6E7 1F          		 rar
0037+  C6E8 57          		 mov	d, a
0038+  C6E9 CD AB C6    		 call	tapeWaitC3
0039+  C6EC 05          		 dcr	b
0040+  C6ED C2 DE C6    		jnz	tapeRead_1
0041+  C6F0             
0042+  C6F0 CD AB C6    		call	tapeWaitC3
0043+  C6F3 7B          		mov	a, e
0044+  C6F4 EE 01       		xri	1
0045+  C6F6 32 F0 D1    		sta	v_tape
0046+  C6F9 3A F1 D1    		lda	v_tape+1
0047+  C6FC B9          		cmp	c
0048+  C6FD 3F          		cmc
0049+  C6FE 17          		ral
0050+  C6FF 4F          		mov	c, a
0051+  C700 7A          		mov	a, d
0052+  C701 B7          		ora	a
0053+  C702 F5          		push	psw
0054+  C703 D1          		pop	d
0055+  C704 7B          		mov	a, e
0056+  C705 1F          		rar
0057+  C706 1F          		rar
0058+  C707 A9          		xra	c
0059+  C708 1F          		rar
0060+  C709 7A          		mov	a, d
0061+  C70A D0          		rnc
0062+  C70B             
0063+  C70B 3E 3F       tapeError:	mvi	a, 3Fh
0064+  C70D 37          		stc
0065+  C70E C9          		ret
0166   C70F             .include "tapeWritePilot.inc"
0001+  C70F             ;+---------------------------------------------------------------------------
0002+  C70F             ; RAMFOS
0003+  C70F             ; Стандартная точка входа C827
0004+  C70F             ; Запись пилот тона на магнитофон
0005+  C70F             ;
0006+  C70F             ; Сохраняет регистры BC,DE,HL
0007+  C70F             ;
0008+  C70F             ; 2013-11-01 Дизассемблировано vinxru
0009+  C70F             ;----------------------------------------------------------------------------
0010+  C70F             
0011+  C70F             tapeWritePilot:	; Сохраняем BC, HL
0012+  C70F E5          		push	h
0013+  C710 C5          		push	b		
0014+  C711             
0015+  C711             		; Длительность пилот-тона BC. Странный кусок кода.
0016+  C711             		; bc = (40 - v_tapePulseAL)*514
0017+  C711 2A 62 C6    		lhld	v_tapePulseA
0018+  C714 3E 28       		mvi	a, 40
0019+  C716 94          		sub	h
0020+  C717 87          		add	a
0021+  C718 47          		mov	b, a
0022+  C719 4F          		mov	c, a		
0023+  C71A             
0024+  C71A             tapeWritePilot_0:
0025+  C71A             		 ; Уменьшаем BC 
0026+  C71A 0B          		 dcx	b
0027+  C71B             
0028+  C71B             		 ; Задержка, регистры ничего полезного не содержат
0029+  C71B 29          		 dad	h
0030+  C71C 78          		 mov	a, b
0031+  C71D             
0032+  C71D             		 ; Импульс А
0033+  C71D CD 66 C7    		 call	tapePulseA		 
0034+  C720             
0035+  C720             		 ; Повторять пока BC не нулевое
0036+  C720 78          		 mov	a, b
0037+  C721 B1          		 ora	c
0038+  C722 C2 1A C7    		jnz	tapeWritePilot_0
0039+  C725             
0040+  C725             		; Восстаналиваем BC, HL
0041+  C725 C1          		pop	b
0042+  C726 E1          		pop	h
0043+  C727 C9          		ret
0167   C728             .include "tapeWrite.inc"
0001+  C728             ;+---------------------------------------------------------------------------
0002+  C728             ; RAMFOS
0003+  C728             ; Стандартная точка входа C80С
0004+  C728             ; Запись байта на магнитофон
0005+  C728             ;
0006+  C728             ; На входе
0007+  C728             ;  С - байт
0008+  C728             ;  A - укорочение первого импульса *15 тактов
0009+  C728             ;
0010+  C728             ; Сохраняет регистры BC,DE,HL
0011+  C728             ;
0012+  C728             ; 2013-11-01 Дизассемблировано vinxru
0013+  C728             ;----------------------------------------------------------------------------
0014+  C728             
0015+  C728 E5          tapeWrite:	push	h
0016+  C729 C5          		push	b
0017+  C72A 2A 60 C6    		 lhld	v_tapePulseB
0018+  C72D C6 03       		 adi	3
0019+  C72F 2F          		 cma
0020+  C730 85          		 add	l
0021+  C731 6F          		 mov	l, a
0022+  C732 CD 6C C7    		 call	tapePulse
0023+  C735 B7          		 ora	a
0024+  C736 B7          		 ora	a
0025+  C737 06 08       		 mvi	b, 8				
0026+  C739 CD 4D C7    tapeWrite_0:	  call	tapePulseBit
0027+  C73C 05          		  dcr	b
0028+  C73D C2 39 C7    		 jnz	tapeWrite_0
0029+  C740 CD 59 C7    		 call	tapeWriteEnd
0030+  C743 E5          		 push	h
0031+  C744 E5          		 push	h
0032+  C745 CD 66 C7    		  call	tapePulseA
0033+  C748 E1          		 pop	h
0034+  C749 E1          		 pop	h
0035+  C74A C1          		pop	b
0036+  C74B E1          		pop	h
0037+  C74C C9          		ret
0038+  C74D             
0039+  C74D             ; ---------------------------------------------------------------------------
0040+  C74D             
0041+  C74D 79          tapePulseBit:	mov	a, c
0042+  C74E 0F          		rrc
0043+  C74F 4F          		mov	c, a
0044+  C750 DA 66 C7    		jc	tapePulseA
0045+  C753 2A 60 C6    tapePulseB:	lhld	v_tapePulseB
0046+  C756 C3 6C C7    		jmp	tapePulse
0047+  C759             
0048+  C759             ; ---------------------------------------------------------------------------
0049+  C759             
0050+  C759 79          tapeWriteEnd:	mov	a, c
0051+  C75A B7          		ora	a
0052+  C75B 4F          		mov	c, a
0053+  C75C E2 53 C7    		jpo	tapePulseB
0054+  C75F 2A 62 C6    		lhld	v_tapePulseA
0055+  C762 2D          		dcr	l
0056+  C763 CD 6C C7    		call	tapePulse
0057+  C766 2A 62 C6    tapePulseA:	lhld	v_tapePulseA
0058+  C769 C3 6C C7    		jmp	tapePulse
0168   C76C             .include "tapePulse.inc"
0001+  C76C             ;----------------------------------------------------------------------------
0002+  C76C             ; RAMFOS
0003+  C76C             ; Запись бита на магнитофон
0004+  C76C             ;
0005+  C76C             ; 2013-11-01 Дизассемблировано vinxru
0006+  C76C             ;----------------------------------------------------------------------------
0007+  C76C             
0008+  C76C             tapePulse:	; Задержка на L
0009+  C76C 2D          		dcr	l		
0010+  C76D F2 6C C7    		jp	tapePulse
0011+  C770             
0012+  C770             		; Высокий уровень
0013+  C770 3E 0F       		mvi	a, 0Fh		
0014+  C772 32 E3 FF    		sta	IO_KEYB_MODE	
0015+  C775             
0016+  C775             		; Задержка на H	
0017+  C775 25          tapePulse_0:	dcr	h		
0018+  C776 F2 75 C7    		jp	tapePulse_0
0019+  C779             
0020+  C779             		; Низкий уровень
0021+  C779 3E 0E       		mvi	a, 0Eh		
0022+  C77B 32 E3 FF    		sta	IO_KEYB_MODE
0023+  C77E C9          		ret0169   C77F             .include "strToHex.inc"
0001+  C77F             ;+---------------------------------------------------------------------------
0002+  C77F             ; RAMFOS
0003+  C77F             ; Преобразвоние строки в 16-ричное число
0004+  C77F             ;
0005+  C77F             ; На входе
0006+  C77F             ;  de - Строка
0007+  C77F             ;
0008+  C77F             ; На выходе
0009+  C77F             ;  bc       - Сохраняется
0010+  C77F             ;  de       - Следующий символ за запятой или концом строки
0011+  C77F             ;  jz       - Ошибка
0012+  C77F             ;  jnz, jc  - Конец строки
0013+  C77F             ;  jnz, jnc - Пробел или запятая
0014+  C77F             ;  hl       - Число
0015+  C77F             ;
0016+  C77F             ; 2013-11-01 Дизассемблировано vinxru
0017+  C77F             ;----------------------------------------------------------------------------
0018+  C77F             
0019+  C77F C5          strToHex:	push	b
0020+  C780 CD 85 C7    		 call	strToHex2
0021+  C783 C1          		pop	b
0022+  C784 C9          		ret
0023+  C785             
0024+  C785             ; ---------------------------------------------------------------------------
0025+  C785             
0026+  C785 21 00 00    strToHex2:	lxi	h, 0		
0027+  C788 06 00       		mvi	b, 0		
0028+  C78A             
0029+  C78A             strToHex2_loop:	; Чтение символа
0030+  C78A 1A          		ldax	d
0031+  C78B 13          		inx	d
0032+  C78C             
0033+  C78C             		; Если конец строки, выходим с флагами NZ, C
0034+  C78C FE 0D       		cpi	0Dh
0035+  C78E CA B0 C8    		jz	ora_a_stc_ret
0036+  C791             
0037+  C791             		; Если пробел или запятая, выходим с флагами NZ, NC
0038+  C791 FE 2C       		cpi	','
0039+  C793 CA 0D CF    		jz	ora_a_ret		
0040+  C796 FE 20       		cpi	' '
0041+  C798 CA 0D CF    		jz	ora_a_ret
0042+  C79B             
0043+  C79B             		; Если некорректный символ, выходим с флагами С,Z
0044+  C79B D6 30       		sui	'0'
0045+  C79D FA AA C8    		jm	xra_a_stc_ret		
0046+  C7A0             
0047+  C7A0             		; Если это цифра
0048+  C7A0 FE 0A       		cpi	10
0049+  C7A2 FA B1 C7    		jm	strToHex2_0
0050+  C7A5             
0051+  C7A5             		; Если некорректный символ, выходим с флагами С,Z
0052+  C7A5 FE 11       		cpi	11h
0053+  C7A7 FA AA C8    		jm	xra_a_stc_ret
0054+  C7AA FE 17       		cpi	17h
0055+  C7AC F2 AA C8    		jp	xra_a_stc_ret
0056+  C7AF             
0057+  C7AF             		; Это буквы A..F
0058+  C7AF D6 07       		sui	'A'-'0'-10
0059+  C7B1             
0060+  C7B1 4F          strToHex2_0:	mov	c, a
0061+  C7B2             
0062+  C7B2             		; hl *=	16
0063+  C7B2 29          		dad	h
0064+  C7B3 29          		dad	h
0065+  C7B4 29          		dad	h
0066+  C7B5 29          		dad	h
0067+  C7B6             
0068+  C7B6             		; Если переполнение, то	выйти c флагами С,Z
0069+  C7B6 DA AA C8    		jc	xra_a_stc_ret
0070+  C7B9             		
0071+  C7B9             		; hl += bc
0072+  C7B9 09          		dad	b
0073+  C7BA             
0074+  C7BA C3 8A C7    		jmp	strToHex2_loop0170   C7BD             .include "calcCrc.inc"
0001+  C7BD             ;+---------------------------------------------------------------------------
0002+  C7BD             ; RAMFOS
0003+  C7BD             ; Стандартная точка входа C82A
0004+  C7BD             ; Расчет контрольной суммы
0005+  C7BD             ;
0006+  C7BD             ; На входе
0007+  C7BD             ;  hl - начальный адрес
0008+  C7BD             ;  de - конечный адрес
0009+  C7BD             ;
0010+  C7BD             ; На выходе
0011+  C7BD             ;  bc - сумма
0012+  C7BD             ;
0013+  C7BD             ; 2013-11-01 Дизассемблировано vinxru
0014+  C7BD             ;----------------------------------------------------------------------------
0015+  C7BD             
0016+  C7BD 01 00 00    calcCrc:	lxi	b, 0
0017+  C7C0 7E          calcCrc_0:	 mov	a, m
0018+  C7C1 81          		 add	c
0019+  C7C2 4F          		 mov	c, a
0020+  C7C3 F5          		 push	psw
0021+  C7C4 CD 5D C8    		  call	cmp_hl_de
0022+  C7C7 CA 98 CB    		  jz	pop_psw_ret
0023+  C7CA F1          		 pop	psw
0024+  C7CB 78          		 mov	a, b
0025+  C7CC 8E          		 adc	m
0026+  C7CD 47          		 mov	b, a
0027+  C7CE CD 5D C8    		 call	cmp_hl_de
0028+  C7D1 C8          		 rz
0029+  C7D2 23          		 inx	h
0030+  C7D3 C3 C0 C7    		jmp	calcCrc_0
0171   C7D6             .include "pushPopCursor.inc"
0001+  C7D6             ;+---------------------------------------------------------------------------
0002+  C7D6             ; RAMFOS
0003+  C7D6             ; Запоминание курсора строки
0004+  C7D6             ; Вызывается при выводе кода 8Dh 
0005+  C7D6             ;
0006+  C7D6             ; 2013-11-01 Дизассемблировано vinxru
0007+  C7D6             ;----------------------------------------------------------------------------
0008+  C7D6             
0009+  C7D6 2A 3E C6    pushCursorLine:	lhld	v_cursorPos
0010+  C7D9 22 20 D2    		shld	v_pushCursorLn
0011+  C7DC C9          		ret
0012+  C7DD              
0013+  C7DD             ;----------------------------------------------------------------------------
0014+  C7DD             ; RAMFOS
0015+  C7DD             ; Восстановние кода цвета из стека
0016+  C7DD             ; Вызывается при выводе кода 87h
0017+  C7DD             ;
0018+  C7DD             ; 2013-11-01 Дизассемблировано vinxru
0019+  C7DD             ;----------------------------------------------------------------------------
0020+  C7DD             
0021+  C7DD 2A 20 D2    popCursorLine:	lhld	v_pushCursorLn
0022+  C7E0 C3 ED C7    		jmp	setCursorPosPx
0023+  C7E3             		
0024+  C7E3             ;----------------------------------------------------------------------------
0025+  C7E3             ; RAMFOS
0026+  C7E3             ; Запоминание курсора экрана
0027+  C7E3             ; Вызывается при выводе кода 93h
0028+  C7E3             ;
0029+  C7E3             ; 2013-11-01 Дизассемблировано vinxru
0030+  C7E3             ;----------------------------------------------------------------------------
0031+  C7E3             
0032+  C7E3 2A 3E C6    pushCursor:	lhld	v_cursorPos
0033+  C7E6 22 22 D2    		shld	v_pushCursor
0034+  C7E9 C9          		ret
0035+  C7EA             
0036+  C7EA             ;----------------------------------------------------------------------------
0037+  C7EA             ; RAMFOS
0038+  C7EA             ; Восстановление курсора экрана
0039+  C7EA             ; Вызывается при выводе кода 94h 
0040+  C7EA             ;
0041+  C7EA             ; 2013-11-01 Дизассемблировано vinxru
0042+  C7EA             ;----------------------------------------------------------------------------
0043+  C7EA             
0044+  C7EA 2A 22 D2    popCursor:	lhld	v_pushCursor
0045+  C7ED 22 3E C6    setCursorPosPx:	shld	v_cursorPos
0046+  C7F0 C9          		ret
0047+  C7F1             
0172   C7F1             .include "setGetMemTop.inc"
0001+  C7F1             ;+---------------------------------------------------------------------------
0002+  C7F1             ; RAMFOS
0003+  C7F1             ; Стандартная точка входа C830
0004+  C7F1             ; Получение верхней границы ОЗУ
0005+  C7F1             ;
0006+  C7F1             ; 2013-11-01 Дизассемблировано vinxru
0007+  C7F1             ;----------------------------------------------------------------------------
0008+  C7F1             
0009+  C7F1 2A 27 D2    getMemTop:	lhld	v_memTop
0010+  C7F4 C9          		ret
0011+  C7F5             
0012+  C7F5             ;----------------------------------------------------------------------------
0013+  C7F5             ; RAMFOS
0014+  C7F5             ; Стандартная точка входа C833
0015+  C7F5             ; Устанока верхней границы ОЗУ
0016+  C7F5             ;
0017+  C7F5             ; 2013-11-01 Дизассемблировано vinxru
0018+  C7F5             ;----------------------------------------------------------------------------
0019+  C7F5             
0020+  C7F5             
0021+  C7F5 22 27 D2    setMemTop:	shld	v_memTop
0022+  C7F8 C9          		ret
0023+  C7F9             
0173   C7F9             .include "pushColor.inc"
0001+  C7F9             ;+---------------------------------------------------------------------------
0002+  C7F9             ; RAMFOS
0003+  C7F9             ; Запоминание кода цвета по принципу стека (глубина 2 цвета)
0004+  C7F9             ; Вызывается при выводе кода 88h
0005+  C7F9             ;
0006+  C7F9             ; 2013-11-01 Дизассемблировано vinxru
0007+  C7F9             ;----------------------------------------------------------------------------
0008+  C7F9             
0009+  C7F9 2A 35 D2    pushColor:	lhld	v_color
0010+  C7FC 22 36 D2    		shld	v_pushColor
0011+  C7FF C9          		ret0174   C800             
0175   C800~            #if $ > 0C800h
0176   C800~            ЋиЁЎЄ _з бвм_C000_­Ґ_ў«Ґ§« 
0177   C800             #endif
0178   C800             .org 0C800h
0179   C800             
0180   C800             .include "c800.inc"
0001+  C800             ;+---------------------------------------------------------------------------
0002+  C800             ; RAMFOS
0003+  C800             ; Точки входа
0004+  C800             ;
0005+  C800             ; 2013-11-01 Дизассемблировано vinxru
0006+  C800             ;----------------------------------------------------------------------------
0007+  C800             
0008+  C800 C3 E6 C8    j_biosInit:		jmp	biosInit
0009+  C803 C3 FA CE    j_keyWait:		jmp	keyWait
0010+  C806 C3 BE C6    j_tapeRead:		jmp	tapeRead
0011+  C809 C3 9A CB    j_printChar:		jmp     printChar
0012+  C80C C3 28 C7    j_tapeWrite:		jmp	tapeWrite
0013+  C80F C3 DF C8    j_printCharA:		jmp	printCharA
0014+  C812 C3 47 CF    j_keyCheck:		jmp	keyCheck
0015+  C815 C3 80 CB    j_printHex:		jmp	printHex
0016+  C818 C3 4B C9    j_printString:		jmp	printString
0017+  C81B C3 8B CF    j_keyScan:		jmp	keyScan
0018+  C81E C3 AF CD    j_getCursorPos:		jmp	getCursorPos
0019+  C821 C3 FD CA    j_getCharFromScr:	jmp	getCharFromScreen
0020+  C824 C3 6C C6    j_tapeReadPilot:	jmp	tapeReadPilot
0021+  C827 C3 0F C7    j_tapeWritePilot:	jmp     tapeWritePilot
0022+  C82A C3 BD C7    j_calcCrc:		jmp     calcCrc
0023+  C82D C3 60 CA    j_setBottomLine:	jmp     setBottomLine
0024+  C830 C3 F1 C7    j_getMemTop:		jmp	getMemTop
0025+  C833 C3 F5 C7    j_setMemTop:		jmp     setMemTop
0026+  C836 C3 97 CA    j_input:		jmp     input
0027+  C839 C3 7F C7    j_strToHex:		jmp	strToHex
0028+  C83C C3 92 CD    j_setCursorPos:		jmp	setCursorPos
0029+  C83F C3 F0 D0    			jmp	printer
0030+  C842 C3 F0 D0    			jmp	printerHex
0031+  C845 C3 63 C8    j_inputFileName:	jmp     inputFileName
0032+  C848 C3 99 D0    			jmp	beep
0033+  C84B C3 15 D1    			jmp	setColor
0034+  C84E C3 77 CB    			jmp	fullClearScreen
0035+  C851 C3 75 D0    			jmp	oldBeep
0036+  C854 C3 5D C8    j_cmp_hl_de:		jmp     cmp_hl_de
0037+  C857 C3 F0 D0    j_printerEchoMode:	jmp	printerEchoMode
0038+  C85A C3 C8 D0    j_tapeMode:		jmp	tapeMode
0181   C85D             .include "cmp_hl_de.inc"
0001+  C85D             ;+---------------------------------------------------------------------------
0002+  C85D             ; RAMFOS
0003+  C85D             ; Сравнить регистры HL и DE
0004+  C85D             ;
0005+  C85D             ; 2013-11-01 Дизассемблировано vinxru
0006+  C85D             ;----------------------------------------------------------------------------
0007+  C85D             
0008+  C85D 7C          cmp_hl_de:	mov	a, h
0009+  C85E BA          		cmp	d
0010+  C85F C0          		rnz
0011+  C860 7D          		mov	a, l
0012+  C861 BB          		cmp	e
0013+  C862 C9          		ret0182   C863             .include "inputFileName.inc"
0001+  C863             ;----------------------------------------------------------------------------
0002+  C863             ; RAMFOS
0003+  C863             ; Ввевод имени файла с клавиатуры в v_header2_name
0004+  C863             ;
0005+  C863             ; 2013-11-01 vinxru
0006+  C863             ;----------------------------------------------------------------------------
0007+  C863             
0008+  C863 E5          inputFileName:	push	h
0009+  C864 D5          		push	d
0010+  C865 C5          		push	b
0011+  C866             
0012+  C866             		; Промежуточный адрес возврата
0013+  C866 21 A2 CB    		lxi	h, popa_ret
0014+  C869 E5          		push	h
0015+  C86A             
0016+  C86A              		; Выводим сообщение на экран и сохраним курсор строки
0017+  C86A 21 97 D1    		lxi	h, a_inputFileName
0018+  C86D CD 4B C9    		call	printString
0019+  C870             
0020+  C870             		; Удалим из имени файла все левые символы
0021+  C870 CD B8 C8    		call	printFileName2
0022+  C873             
0023+  C873             loc_C873:	; Восстановить курсор строки
0024+  C873 CD DD C7    		call	popCursorLine
0025+  C876             
0026+  C876             		; Ввод имени файла
0027+  C876 21 F5 D1    		lxi	h, v_header2_name
0028+  C879 11 FF 0C    		lxi	d, 0CFFh
0029+  C87C CD 97 CA    		call	input
0030+  C87F             
0031+  C87F             		; Нажат ESC
0032+  C87F C8          		rz
0033+  C880             
0034+  C880             		; Нажата левая клавиша, вывести знак вопроса и вернуться к вводу
0035+  C880 21 73 C8    		lxi	h, loc_C873
0036+  C883 E5          		push	h
0037+  C884 D2 AA C8    		jnc	xra_a_stc_ret
0038+  C887             
0039+  C887             		; Сдвинуть курсор
0040+  C887 2A 20 D2    		lhld	v_pushCursorLn
0041+  C88A 7C          		mov	a, h
0042+  C88B C6 18       		adi	3*8
0043+  C88D 67          		mov	h, a
0044+  C88E 22 3E C6    		shld	v_cursorPos
0045+  C891             
0046+  C891             		; Разделитель между именем и расширением должен быть пробелом
0047+  C891 21 FD D1    		lxi	h, v_header2_ext-1
0048+  C894 06 04       		mvi	b, 4
0049+  C896 7E          		mov	a, m
0050+  C897 FE 20       		cpi	20h
0051+  C899 C2 AA C8    		jnz	xra_a_stc_ret		
0052+  C89C             
0053+  C89C             		; Расширение
0054+  C89C 05          loc_C89C:	 dcr	b
0055+  C89D CD DF C8    		 call	printCharA
0056+  C8A0 CA 0C CF    		 jz	loc_CE8A	; Переход на pop h, ora a, ret
0057+  C8A3 23          		 inx	h
0058+  C8A4 7E          		 mov	a, m
0059+  C8A5 FE 20       		 cpi	20h
0060+  C8A7 C2 9C C8    		jnz	loc_C89C
0061+  C8AA             		
0062+  C8AA             xra_a_stc_ret:	; Вывод знака вопроса
0063+  C8AA 3E 3F       		mvi	a, '?'
0064+  C8AC CD DF C8    		call	printCharA
0065+  C8AF AF          		xra	a
0066+  C8B0             
0067+  C8B0 B7          ora_a_stc_ret:	ora	a
0068+  C8B1 37          		stc
0069+  C8B2 C9          		ret
0183   C8B3             .include "printFileName.inc"
0001+  C8B3             ;----------------------------------------------------------------------------
0002+  C8B3             ; RAMFOS
0003+  C8B3             ; Вывести имя файла на экран и удалить из него все недопустимые символы
0004+  C8B3             ;
0005+  C8B3             ; 2013-11-01 Дизассемблировано vinxru
0006+  C8B3             ;----------------------------------------------------------------------------
0007+  C8B3             
0008+  C8B3             printFileName:	
0009+  C8B3             		; Разделитель
0010+  C8B3             #if NICE
0011+  C8B3 0E 20       		mvi	c, ' '
0012+  C8B5~            #else
0013+  C8B5~            		; Разделитель
0014+  C8B5~            		mvi	c, 11h
0015+  C8B5             #endif
0016+  C8B5 CD 9A CB    		call	printChar
0017+  C8B8             
0018+  C8B8 21 F5 D1    printFileName2:lxi	h, v_header2_name	; Имя
0019+  C8BB 06 0C       		mvi	b, 12			; Длина имени
0020+  C8BD 7E          printFileNam_1:	 mov	a, m
0021+  C8BE             		 ; Символы меньше 0x20 заменяем на пробел
0022+  C8BE FE 20       		 cpi	20h
0023+  C8C0 DA CD C8    		 jc	printFileNam_2
0024+  C8C3             		 ; Символы от 0x20 до 0x7E допускаются
0025+  C8C3 FE 7F       		 cpi	7Fh
0026+  C8C5 DA D0 C8    		 jc	printFileNam_3
0027+  C8C8             		 ; Символы от 0xC0 до 0xFF допускаются
0028+  C8C8 FE C0       		 cpi	0C0h
0029+  C8CA D2 D0 C8    		 jnc	printFileNam_3		 
0030+  C8CD             printFileNam_2:	 ; Заменяем недопустимый символ на пробел
0031+  C8CD 36 20       		 mvi	m, 20h
0032+  C8CF 7E          		 mov	a, m
0033+  C8D0             printFileNam_3:	 ; Выводим символ на экран
0034+  C8D0 CD DF C8    		 call	printCharA
0035+  C8D3             		 ; Следующий символ
0036+  C8D3 23          		 inx	h
0037+  C8D4 05          		 dcr	b
0038+  C8D5 C2 BD C8    		jnz	printFileNam_1		
0039+  C8D8             
0040+  C8D8             		; Разделитель
0041+  C8D8             #if NICE
0042+  C8D8 0E 20       		mvi	c, ' '
0043+  C8DA C3 9A CB    		jmp	printChar
0044+  C8DD             #endif
0045+  C8DD             		; Переход на printChar60184   C8DD             .include "printCharA.inc"
0001+  C8DD             ;----------------------------------------------------------------------------
0002+  C8DD             ; RAMFOS
0003+  C8DD             ; Вывод символа с кодом 6 на экран
0004+  C8DD             ;
0005+  C8DD             ; 2013-11-01 Дизассемблировано vinxru
0006+  C8DD             ;----------------------------------------------------------------------------
0007+  C8DD             
0008+  C8DD 3E 06       printChar6:	mvi	a, 6
0009+  C8DF             
0010+  C8DF             ;----------------------------------------------------------------------------
0011+  C8DF             ; RAMFOS
0012+  C8DF             ; Стандартная точка входа C80F
0013+  C8DF             ; Вывод символа на экран
0014+  C8DF             ;
0015+  C8DF             ; На входе
0016+  C8DF             ;  A - число
0017+  C8DF             ;
0018+  C8DF             ; 2013-11-01 Дизассемблировано vinxru
0019+  C8DF             ;----------------------------------------------------------------------------
0020+  C8DF             
0021+  C8DF C5          printCharA:	push	b
0022+  C8E0 4F          		 mov	c, a
0023+  C8E1 CD 9A CB    		 call	printChar
0024+  C8E4 C1          		pop	b
0025+  C8E5 C9          		ret0185   C8E6             .include "biosInit.inc"
0001+  C8E6             ;+---------------------------------------------------------------------------
0002+  C8E6             ; RAMFOS
0003+  C8E6             ; Инициализация BIOS
0004+  C8E6             ; Вызывается только функцией init
0005+  C8E6             ;
0006+  C8E6             ; 2013-11-01 Дизассемблировано и доработано vinxru
0007+  C8E6             ;----------------------------------------------------------------------------
0008+  C8E6             
0009+  C8E6             biosInit:	; Очистка переменных начиная с v_dblClear
0010+  C8E6 21 10 D2    		lxi	h, v_dblClear
0011+  C8E9 06 2F       		mvi	b, 47
0012+  C8EB AF          		xra	a
0013+  C8EC 32 5C C6    		sta	v_clearScreenByte
0014+  C8EF 77          loc_C8EA:	 mov	m, a
0015+  C8F0 23          		 inx	h
0016+  C8F1 05          		 dcr	b
0017+  C8F2 C2 EF C8    		jnz	loc_C8EA
0018+  C8F5             
0019+  C8F5             		; Инициализация	контроллера цвета черным цветом для очистки экрана
0020+  C8F5~            #if INIT_SCREEN_COLOR==100h
0021+  C8F5~            		lda	v_selColor
0022+  C8F5             #else
0023+  C8F5 3E F1       		mvi	a, INIT_SCREEN_COLOR
0024+  C8F7             #endif
0025+  C8F7 CD 15 D1    		call	setColor
0026+  C8FA             
0027+  C8FA             		; Инициализация	клавиатуры
0028+  C8FA CD 95 CF    		call	keyMode82	
0029+  C8FD             
0030+  C8FD             		; Скрываем нижнюю строку
0031+  C8FD CD 8B CA    		call	bottomLineHide
0032+  C900             
0033+  C900             		; Очищаем экран
0034+  C900 CD 87 CE    		call	clearScreen
0035+  C903             		
0036+  C903             		; Настройка таймера
0037+  C903 21 EF FF    		lxi	h, IO_TIMER+3
0038+  C906 36 36       		mvi	m, 36h
0039+  C908 36 76       		mvi	m, 76h
0040+  C90A 36 90       		mvi	m, 90h
0041+  C90C 2B          		dcx	h
0042+  C90D 36 10       		mvi	m, 10h
0043+  C90F 2B          		dcx	h
0044+  C910 36 20       		mvi	m, 20h
0045+  C912 36 4E       		mvi	m, 4Eh
0046+  C914 2B          		dcx	h
0047+  C915 36 10       		mvi	m, 10h
0048+  C917 36 15       		mvi	m, 15h
0049+  C919             		
0050+  C919             		; *** Определение размера ДОЗУ ***
0051+  C919             
0052+  C919             #if WORK_WITHOUT_ARAM
0053+  C919             		; Надо вернуть доступ к ДОЗУ, иначе проверка не работает
0054+  C919 3E FD       		mvi	a, 0FDh		; Порт выбора ДОЗУ		
0055+  C91B 32 CA FF    		sta	disableARAM1+1
0056+  C91E 32 D9 FF    		sta	disableARAM2+1
0057+  C921             #endif
0058+  C921             
0059+  C921             #if TRUE_CHECK_ARAM
0060+  C921 21 BB FF    		lxi	h, ARAM_PAGE_END
0061+  C924~            #else
0062+  C924~            		lhld	v_aramPageEnd	; Это не совсем правильно, так как при программном сбросе проверка будет работать не так, как при аппаратном
0063+  C924             #endif
0064+  C924 3A 5E C6    		lda	v_aramMaxPageI
0065+  C927 CD 70 C9    		call	checkARAM
0066+  C92A             		
0067+  C92A             #if WORK_WITHOUT_ARAM
0068+  C92A 11 00 00    		lxi	d, 0		; Начало ДОЗУ
0069+  C92D             #endif
0070+  C92D             		; Если ДОЗУ найдено
0071+  C92D             #if TRUE_CHECK_ARAM
0072+  C92D C2 3E C9    		jnz	aramFounded	; Так короче код испрваленной функции
0073+  C930~            #else
0074+  C930~            		jz	aramFounded		
0075+  C930             #endif
0076+  C930             
0077+  C930             		; ДОЗУ не найдено
0078+  C930             #if WORK_WITHOUT_ARAM
0079+  C930             		 ; Настраиваем небольшой диск в основном ОЗУ
0080+  C930 11 6D D1    		 lxi	d, miniPage
0081+  C933 21 8E D1    		 lxi	h, miniPageEnd
0082+  C936 3E FC       		 mvi	a, 0FCh		; Порт выбора ОЗУ
0083+  C938 32 CA FF    		 sta	disableARAM1+1
0084+  C93B 32 D9 FF    		 sta	disableARAM2+1
0085+  C93E~            #else
0086+  C93E~            		 ; Пытаемся работать с 48 Кб ДОЗУ
0087+  C93E~            		 lxi	h, 0BFFBh
0088+  C93E             #endif
0089+  C93E             aramFounded:	
0090+  C93E 22 1C C6    		shld	v_aramPageEnd
0091+  C941 22 3C D2    		shld	v_aramPageEnd2
0092+  C944             #if WORK_WITHOUT_ARAM
0093+  C944 EB          		xchg
0094+  C945 22 1E C6    		shld	v_aramPageStart
0095+  C948             #endif
0096+  C948             		; *** Инициализация экрана ***
0097+  C948 21 A7 D1    		lxi	h, a_initScreen
0098+  C94B             		; Далее printString
0099+  C94B             
0100+  C94B             
0101+  C94B             		; Этот текст будет встроен в конец кода
0102+  C94B             #if NICE
0103+  C94B             #define A_INITSCREEN a_initScreen: .db C_INVERSE, C_TOPLINE, ' ', 0F3h, 0D0h, 0C5h, 0C3h, 0C9h, 0C1h, 0CCh, 0C9h, 0D3h, 0D4h, ' ','M','X','2',' ','R','A','M','F','O','S',C_NORMAL,0
0104+  C94B~            #else                                                                                                                                                                  
0105+  C94B~            #define A_INITSCREEN a_initScreen: .db C_INVERSE, C_TOPLINE, ' ', 0F3h, 0D0h, 0C5h, 0C3h, 0C9h, 0C1h, 0CCh, 0C9h, 0D3h, 0D4h, '_','M','X',92,'R','A','M','F','O','S',92,C_NORMAL,0
0106+  C94B             #endif
0186   C94B             .include "printString.inc"
0001+  C94B             ;+---------------------------------------------------------------------------
0002+  C94B             ; RAMFOS
0003+  C94B             ; Стандартная точка входа C818
0004+  C94B             ; Вывод строки на экран
0005+  C94B             ;
0006+  C94B             ; На входе
0007+  C94B             ;  hl - Строка
0008+  C94B             ;
0009+  C94B             ; 2013-11-01 Дизассемблировано vinxru
0010+  C94B             ;----------------------------------------------------------------------------
0011+  C94B             
0012+  C94B 7E          printString:	mov	a, m
0013+  C94C A7          		ana	a
0014+  C94D C8          		rz
0015+  C94E CD DF C8    		call	printCharA
0016+  C951 23          		inx	h
0017+  C952 C3 4B C9    		jmp	printString
0187   C955             .include "parseDate.inc"
0001+  C955             ;+---------------------------------------------------------------------------
0002+  C955             ; RAMFOS
0003+  C955             ; Преобразовать введенную строку с датой в числа
0004+  C955             ;
0005+  C955             ; На входе:
0006+  C955             ;  de - строка
0007+  C955             ;
0008+  C955             ; 2013-11-01 Дизассемблировано vinxru
0009+  C955             ;----------------------------------------------------------------------------
0010+  C955             
0011+  C955             parseDate:	; День
0012+  C955 CD 7F C7    		call	strToHex
0013+  C958 7D          		mov	a, l
0014+  C959             #if DATE_IN_RAM
0015+  C959 32 02 D2    		sta	v_header2_date+0
0016+  C95C~            #else
0017+  C95C~            		sta	parseDate_r1+1
0018+  C95C             #endif
0019+  C95C D8          		rc
0020+  C95D             		; Месяц
0021+  C95D CD 7F C7    		call	strToHex
0022+  C960 7D          		mov	a, l
0023+  C961             #if DATE_IN_RAM
0024+  C961 32 03 D2    		sta	v_header2_date+1
0025+  C964~            #else
0026+  C964~            		sta	parseDate_r2+1
0027+  C964             #endif
0028+  C964 D8          		rc
0029+  C965             		; Год
0030+  C965 CD 7F C7    		call	strToHex
0031+  C968 7D          		mov	a, l
0032+  C969             #if DATE_IN_RAM
0033+  C969 32 04 D2    		sta	v_header2_date+2
0034+  C96C~            #else
0035+  C96C~            		sta	parseDate_r3+1
0036+  C96C             #endif
0037+  C96C D8          		rc
0038+  C96D             		; Слишком много параметров
0039+  C96D C3 AA C8    		jmp	xra_a_stc_ret
0188   C970             #if TRUE_CHECK_ARAM
0189   C970             .include "checkARAM_v2.inc"
0001+  C970             ;+---------------------------------------------------------------------------
0002+  C970             ; RAMFOS
0003+  C970             ; Исправленная функция определения размера ДОЗУ
0004+  C970             ;
0005+  C970             ; На входе
0006+  C970             ;  а - максимальный номер страницы, константа MAX_ARAM_PAGE
0007+  C970             ;
0008+  C970             ; На выходе
0009+  C970             ;  NZ - ДОЗУ найдено (наоборот отновительно стандратной функции)
0010+  C970             ;   Z - ДОЗУ не найдено
0011+  C970             ;
0012+  C970             ; 2013-11-01 Разработано vinxru
0013+  C970             ;----------------------------------------------------------------------------
0014+  C970             
0015+  C970             checkARAM:	 ; Записываем во все страницы порядковые номера от большей к меньшей
0016+  C970 4F          		 mov	c, a		
0017+  C971 0C          		 inr	c
0018+  C972 CD 39 F8    		 call	j_pageWriteAny
0019+  C975 3D          		 dcr	a
0020+  C976 F2 70 C9    		jp	checkARAM
0021+  C979             
0022+  C979             		; Читаем номера. Если номер прочитан корректно, значит есть такая страница
0023+  C979             		; a = -1
0024+  C979             
0025+  C979             checkARAM_1:	 ; Читаем следующую страницу
0026+  C979 3C          		 inr	a
0027+  C97A CD 36 F8    		 call	j_pageReadAny		
0028+  C97D             		 ; Должен быть записан номер страницы+1, если нет, то выходим
0029+  C97D 0D          		 dcr	c
0030+  C97E B9          		 cmp	c		 
0031+  C97F C2 8A C9    		 jnz	checkARAM_2
0032+  C982                              ; Сохраняем номер последней страницы RAM-диска
0033+  C982 32 3D C6    		 sta	v_aramMaxPage
0034+  C985             		 ; Это максимум, выходим
0035+  C985 FE 0F       		 cpi	ARAM_MAX_PAGE		; ARAM_MAX_PAGE не может быть нулем!
0036+  C987 C2 79 C9    		jnz	checkARAM_1
0037+  C98A             		 
0038+  C98A             checkARAM_2:	; Если ДОЗУ найдено, выходим в флагом NZ
0039+  C98A B7          		ora	a
0040+  C98B C0          		rnz		
0041+  C98C             
0042+  C98C             		; В случае ошибки заносим в v_aramPages=0 и выходим с флагом Z
0043+  C98C 32 3D C6    		sta	v_aramMaxPage
0044+  C98F C9          		ret		0190   C990~            #else
0191   C990~            .include "checkARAM.inc"
0192   C990             #endif
0193   C990             .include "inputDate.inc"
0001+  C990             ;+---------------------------------------------------------------------------
0002+  C990             ; RAMFOS
0003+  C990             ; Ввод текущей даты
0004+  C990             ;
0005+  C990             ; 2013-11-01 Дизассемблировано vinxru
0006+  C990             ;----------------------------------------------------------------------------
0007+  C990             
0008+  C990             inputDate:	; Вывод приглашения "V3.1/дата:" или "дата:"
0009+  C990 21 A0 D1    		lxi	h, a_inputDate
0010+  C993 CD 4B C9    		call	printString
0011+  C996             	
0012+  C996             		; Ввод даты
0013+  C996 21 95 D2    		lxi	h, buffer
0014+  C999 11 FF 09    		lxi	d, 9FFh ; Максимум 9 символов
0015+  C99C CD 97 CA    		call	input
0016+  C99F             
0017+  C99F             		; Если была ошибка
0018+  C99F D2 90 C9    		jnc	inputDate
0019+  C9A2 77          		mov	m, a
0020+  C9A3             
0021+  C9A3             		; Преобразование введенной строки и числа
0022+  C9A3 FC 55 C9    		cm	parseDate
0023+  C9A6             
0024+  C9A6             		; Если преобразование не удалось вводим повторно
0025+  C9A6 CA 90 C9    		jz	inputDate
0026+  C9A9             
0027+  C9A9             #if DATE_IN_RAM
0028+  C9A9             		; Сохраняем признак того, что дата введена
0029+  C9A9 3E 8B       		mvi	a, 8Bh 
0030+  C9AB 32 01 D2    		sta	v_header2_saved
0031+  C9AE             
0032+  C9AE C9          		ret
0033+  C9AF~            #else
0034+  C9AF~            		; Извлекаем из стека адрес на диске
0035+  C9AF~            		pop	h
0036+  C9AF~            
0037+  C9AF~            		; Сохраняем 08Bh
0038+  C9AF~            		mvi	c, 8Bh 
0039+  C9AF~            		call	inputDate_1
0040+  C9AF~            		
0041+  C9AF~            		; Сохраняем день на диск
0042+  C9AF~            parseDate_r1:	mvi	c, 22h
0043+  C9AF~            		call	inputDate_1
0044+  C9AF~            
0045+  C9AF~            		; Сохраняем месяц на диск
0046+  C9AF~            parseDate_r2:	mvi	c, 09h
0047+  C9AF~            		call	inputDate_1
0048+  C9AF~            
0049+  C9AF~            		; Сохраняем год на диск
0050+  C9AF~            parseDate_r3:	mvi	c, 92h
0051+  C9AF~            inputDate_1:	xra	a
0052+  C9AF~            		call	j_pageWriteAny
0053+  C9AF~            		inx	h
0054+  C9AF~            		inr	a
0055+  C9AF~            		ret
0056+  C9AF             #endif
0057+  C9AF             
0058+  C9AF             #if NICE
0059+  C9AF             #define A_INPUTDATE a_inputDate: .db 0Dh, 0C4h, 0C1h, 0D4h, 0C1h, ':', 0 ; "дата:"
0060+  C9AF~            #else
0061+  C9AF~            #define A_INPUTDATE a_inputDate: .db 0Dh, 'V', '3', '.', '1', '/', 0C4h, 0C1h, 0D4h, 0C1h, ':', 0 ; "V3.1/дата:"
0062+  C9AF             #endif0194   C9AF             .include "topLine.inc"		; Їа®¤®«¦ Ґвбп ў inverse
0001+  C9AF             ;+---------------------------------------------------------------------------
0002+  C9AF             ; RAMFOS
0003+  C9AF             ; Вывод идникаторов в верхнюю строку
0004+  C9AF             ; Эта функция вызывается только из printIndicators и clearTopLine
0005+  C9AF             ;
0006+  C9AF             ; 2013-11-01 Дизассемблировано и доработано vinxru
0007+  C9AF             ;----------------------------------------------------------------------------
0008+  C9AF             
0009+  C9AF             #if FAST_PRINT
0010+  C9AF             INDCATORS_SEP = ' '
0011+  C9AF~            #else
0012+  C9AF~            INDCATORS_SEP = 11h
0013+  C9AF             #endif
0014+  C9AF             
0015+  C9AF             printIndicatorsInt:	
0016+  C9AF             		; Если дата хранится в ОЗУ, проверяется, введена ли дата
0017+  C9AF             #if DATE_IN_RAM
0018+  C9AF 3A 01 D2    		lda	v_header2_saved
0019+  C9B2 FE 8B       		cpi	8Bh
0020+  C9B4 C4 90 C9    		cnz	inputDate
0021+  C9B7             #endif
0022+  C9B7             		; Установка положения курсора (0 стока 45 столбец)
0023+  C9B7 21 08 87    		lxi	h, 8708h	
0024+  C9BA 22 3E C6    		shld	v_cursorPos
0025+  C9BD             
0026+  C9BD             		; Если дата хранится в ДОЗУ, проверяется, введена ли дата
0027+  C9BD~            #if DATE_IN_RAM==0
0028+  C9BD~            		; Читаем из нулевой страницы байт по адресу v_aramPageEnd+1
0029+  C9BD~            		lhld	v_aramPageEnd
0030+  C9BD~            		inx	h
0031+  C9BD~            		xra	a
0032+  C9BD~            		call	j_pageReadAny
0033+  C9BD~            		
0034+  C9BD~            		; Если там записан не 8B, то переходим к вводу даты
0035+  C9BD~            		mov	a, c
0036+  C9BD~            		cpi	8Bh
0037+  C9BD~            		push	h		
0038+  C9BD~            		jnz	inputDate
0039+  C9BD             #endif
0040+  C9BD             
0041+  C9BD             		; Разделитель
0042+  C9BD 3E 20       		mvi	a, INDCATORS_SEP
0043+  C9BF CD DF C8    		call	printCharA
0044+  C9C2             
0045+  C9C2             		; Выводим скорость записи на ленту
0046+  C9C2 3A 5F C6    		lda	v_tapeMode
0047+  C9C5 CD DF C8    		call	printCharA
0048+  C9C8             
0049+  C9C8             		; Выводим режим эхопечати
0050+  C9C8 3A 2F C6    		lda	v_printerEcho
0051+  C9CB CD DF C8    		call	printCharA
0052+  C9CE             
0053+  C9CE             		; Выводим CAPS LOCK
0054+  C9CE 2A 2D C6    		lhld	v_rusLat
0055+  C9D1 25          		dcr	h
0056+  C9D2 3E 0B       		mvi	a, 0Bh
0057+  C9D4 FA D9 C9    		jm	loc_C9D5
0058+  C9D7 3E 0F       		 mvi	a, 0Fh		 
0059+  C9D9 CD DF C8    loc_C9D5:	call	printCharA
0060+  C9DC             
0061+  C9DC             		; Выводим РУС/LAT
0062+  C9DC 2C          		inr	l
0063+  C9DD 21 8F D1    		lxi	h, a_lat
0064+  C9E0 C2 E6 C9    		jnz	loc_C9E2
0065+  C9E3 21 93 D1    		  lxi	h, a_rus
0066+  C9E6 CD 4B C9    loc_C9E2:	call	printString
0067+  C9E9             
0068+  C9E9             		; Выводим KOI8/7
0069+  C9E9 3A 2C C6    		lda	v_koi8
0070+  C9EC B7          		ora	a
0071+  C9ED 3E 38       		mvi	a, '8'
0072+  C9EF CA F3 C9    		jz	loc_C9EF
0073+  C9F2 3D          		  dcr	a		  
0074+  C9F3 CD DF C8    loc_C9EF:	call	printCharA
0075+  C9F6             
0076+  C9F6             #if FAST_PRINT
0077+  C9F6 3E 20       		mvi	a, ' '
0078+  C9F8 CD DF C8    		call	printCharA
0079+  C9FB~            #else
0080+  C9FB~            		call	printChar6
0081+  C9FB             #endif
0082+  C9FB             
0083+  C9FB             #if DATE_IN_RAM
0084+  C9FB             		; Разделитель
0085+  C9FB 3E 20       		mvi	a, INDCATORS_SEP
0086+  C9FD CD DF C8    		call	printCharA
0087+  CA00             
0088+  CA00             		; Вывод на экран даты
0089+  CA00 3A 02 D2    		lda v_header2_date
0090+  CA03 CD 80 CB    		call	printHex
0091+  CA06             
0092+  CA06             #if NICE
0093+  CA06 3E 2D       		mvi	a, '-'
0094+  CA08 CD DF C8    		call	printCharA
0095+  CA0B             #endif
0096+  CA0B             		; Вывод на экран даты
0097+  CA0B 3A 03 D2    		lda	v_header2_date+1
0098+  CA0E CD 80 CB    		call	printHex
0099+  CA11             #if NICE
0100+  CA11 3E 2D       		mvi	a, '-'
0101+  CA13 CD DF C8    		call	printCharA
0102+  CA16             #endif
0103+  CA16             		; Вывод на экран даты
0104+  CA16 3A 04 D2    		lda v_header2_date+2
0105+  CA19 CD 80 CB    		call	printHex
0106+  CA1C~            #else
0107+  CA1C~            		pop	h
0108+  CA1C~            
0109+  CA1C~            		; Адрес для сохранения даты
0110+  CA1C~            		lxi	d, v_header2_saved
0111+  CA1C~            
0112+  CA1C~            		; Сохраняем C в v_header2_saved <--- ????
0113+  CA1C~            		mov	a, c
0114+  CA1C~            		stax	d
0115+  CA1C~            
0116+  CA1C~            		; Разделитель
0117+  CA1C~            		mvi	a, INDCATORS_SEP
0118+  CA1C~            		call	printCharA
0119+  CA1C~            
0120+  CA1C~            		; Вывод на экран даты
0121+  CA1C~            		mvi	b, 3		; 3 байта
0122+  CA1C~            loc_CA02:	 inx	h
0123+  CA1C~            		 inx	d
0124+  CA1C~            		 ; Читаем байт из нулевой страницы
0125+  CA1C~            		 xra	a
0126+  CA1C~            		 call	j_pageReadAny
0127+  CA1C~            		 ; Запись в памяти
0128+  CA1C~            		 mov	a, c
0129+  CA1C~            		 stax	d
0130+  CA1C~            		 ; Вывод на экран
0131+  CA1C~            		 call	printHex
0132+  CA1C~            		 ; Цикл 3-1
0133+  CA1C~            		 dcr	b
0134+  CA1C~            		jnz	loc_CA02
0135+  CA1C             #endif
0136+  CA1C             
0137+  CA1C             #if FAST_PRINT
0138+  CA1C C9          		ret
0139+  CA1D~            #else
0140+  CA1D~            		jmp	printChar6
0141+  CA1D             #endif
0142+  CA1D             
0143+  CA1D             ;----------------------------------------------------------------------------
0144+  CA1D             ; RAMFOS
0145+  CA1D             ; Лишний код
0146+  CA1D             ;
0147+  CA1D             ; 2013-11-01 Дизассемблировано vinxru
0148+  CA1D             ;----------------------------------------------------------------------------
0149+  CA1D             
0150+  CA1D~            #if NO_PRINT_STATUS_BUG==0
0151+  CA1D~            printIndicatorsEnd:
0152+  CA1D~            		pop	psw
0153+  CA1D~            		cnz	changeInverse
0154+  CA1D             #endif
0155+  CA1D             
0156+  CA1D             ;----------------------------------------------------------------------------
0157+  CA1D             ; RAMFOS
0158+  CA1D             ; Очистка верхней строки и перемещение туда курсора
0159+  CA1D             ; Вызывается при печати символа 08Fh
0160+  CA1D             ;
0161+  CA1D             ; 2013-11-01 Дизассемблировано и доработано vinxru
0162+  CA1D             ;----------------------------------------------------------------------------
0163+  CA1D             
0164+  CA1D             clearTopLine:	
0165+  CA1D             #if COLOR_SUPPORT
0166+  CA1D             		; Цвет по умолчанию
0167+  CA1D 3E F1       		mvi	a, INIT_SCREEN_COLOR
0168+  CA1F CD 15 D1    		call	setColor
0169+  CA22             #endif
0170+  CA22             
0171+  CA22             		; Реальная очистка верхней строки
0172+  CA22 CD DF CE    		call	clearTopLine2
0173+  CA25             
0174+  CA25             		; Устанавливаем курсор в верхнюю строку
0175+  CA25 21 08 00    		lxi	h, 8
0176+  CA28 22 3E C6    		shld	v_cursorPos
0177+  CA2B             
0178+  CA2B             		; ?
0179+  CA2B 21 0A 14    		lxi	h, 140Ah
0180+  CA2E 22 30 D2    		shld	v_topLineHeight
0181+  CA31             
0182+  CA31             ;----------------------------------------------------------------------------
0183+  CA31             ; RAMFOS
0184+  CA31             ; Вывод идникаторов в верхнюю строку с сохранением курсора, цвета и инверсии
0185+  CA31             ; Эта функция вызывается только из keyScan
0186+  CA31             ;
0187+  CA31             ; 2013-11-01 Дизассемблировано и доработано vinxru
0188+  CA31             ;----------------------------------------------------------------------------
0189+  CA31             
0190+  CA31             printIndicators:
0191+  CA31             		; Не рисовать индикаторы
0192+  CA31 3A 30 D2    		lda	v_topLineHeight
0193+  CA34 B7          		ora	a
0194+  CA35 C8          		rz
0195+  CA36             
0196+  CA36             		; Запоминаем положение курсора
0197+  CA36 2A 3E C6    		lhld	v_cursorPos
0198+  CA39             
0199+  CA39             		; Запоминаем инверсию в стеке
0200+  CA39 3A 5C C6    		lda	v_clearScreenByte
0201+  CA3C B7          		ora	a
0202+  CA3D F5          		push	psw
0203+  CA3E             #if FAST_PRINT
0204+  CA3E             		; Если инверсия не была включена, включаем её.
0205+  CA3E CC 58 CA    		cz	changeInverse
0206+  CA41~            #else
0207+  CA41~            		; Если инверсия была включена, выключаем её.
0208+  CA41~            		cnz	changeInverse
0209+  CA41             #endif	
0210+  CA41             
0211+  CA41             		; Сохранение цвета и установка стандартного цвета
0212+  CA41             #if COLOR_SUPPORT
0213+  CA41 3A 35 D2    		lda	v_color
0214+  CA44 F5          		push	psw
0215+  CA45 3E F0       		mvi	a, 0F0h
0216+  CA47 CD 15 D1    		call	setColor
0217+  CA4A             #endif
0218+  CA4A             
0219+  CA4A             		; Вывод статусной строки
0220+  CA4A E5          		push	h
0221+  CA4B CD AF C9    		 call	printIndicatorsInt
0222+  CA4E E1          		pop	h
0223+  CA4F             
0224+  CA4F             		; Восстановление цвета
0225+  CA4F             #if COLOR_SUPPORT
0226+  CA4F F1          		pop	psw
0227+  CA50 CD 15 D1    		call	setColor
0228+  CA53             #endif
0229+  CA53             	
0230+  CA53             		;  Восстановление положения курсора
0231+  CA53 22 3E C6    		shld	v_cursorPos
0232+  CA56             		 
0233+  CA56~            #if NO_PRINT_STATUS_BUG==0
0234+  CA56~            		jnz	printIndicatorsEnd
0235+  CA56             #endif
0236+  CA56             
0237+  CA56             		;  Восстановление инверсии
0238+  CA56 F1          		pop	psw
0239+  CA57             #if FAST_PRINT
0240+  CA57 C0          		rnz
0241+  CA58~            #else
0242+  CA58~            		rz
0243+  CA58             #endif	
0244+  CA58             		; продолжается в changeInverse0195   CA58             .include "inverse.inc"
0001+  CA58             ;+---------------------------------------------------------------------------
0002+  CA58             ; RAMFOS
0003+  CA58             ; Инверсия инверсии (Инверсия фона чернобелого экрана)
0004+  CA58             ; Вызывается при выводе кода 8Ah и просто так
0005+  CA58             ;
0006+  CA58             ; 2013-11-01 Дизассемблировано vinxru
0007+  CA58             ;----------------------------------------------------------------------------
0008+  CA58             
0009+  CA58 3A 5C C6    changeInverse:	lda	v_clearScreenByte
0010+  CA5B             
0011+  CA5B             ;----------------------------------------------------------------------------
0012+  CA5B             ; RAMFOS
0013+  CA5B             ; Включение/выключение инверсии
0014+  CA5B             ;
0015+  CA5B             ; На входе
0016+  CA5B             ;  A=0    - Включить. (Вызывается при выводе кода 8Bh)
0017+  CA5B             ;  A=0FFh - Выключить.
0018+  CA5B             ;
0019+  CA5B             ; 2013-11-01 Дизассемблировано vinxru
0020+  CA5B             ;----------------------------------------------------------------------------
0021+  CA5B             
0022+  CA5B 2F          setInverseNeg:	cma
0023+  CA5C             
0024+  CA5C             ;----------------------------------------------------------------------------
0025+  CA5C             ; RAMFOS
0026+  CA5C             ; Включение/выключение инверсии
0027+  CA5C             ;
0028+  CA5C             ; На входе
0029+  CA5C             ;  A=0FFh - Включить. (Вызывается при выводе кода 8Ch)
0030+  CA5C             ;  A=0    - Выключить.
0031+  CA5C             ;
0032+  CA5C             ; 2013-11-01 Дизассемблировано vinxru
0033+  CA5C             ;----------------------------------------------------------------------------
0034+  CA5C             
0035+  CA5C 32 5C C6    setInverse:	sta	v_clearScreenByte
0036+  CA5F C9          		ret		
0196   CA60             .include "bottomLine.inc"
0001+  CA60             ;+---------------------------------------------------------------------------
0002+  CA60             ; RAMFOS
0003+  CA60             ; Стандартная точка входа C82D
0004+  CA60             ; Установка текста в нижнюю строку. 
0005+  CA60             ; Необходимо предварительно включить строку с помощью clearBottomLine
0006+  CA60             ;
0007+  CA60             ; На входе
0008+  CA60             ;  hl - текстовая строка. Первый байт строки - индертификатор. Если строка
0009+  CA60             ;  с таким ид выводилась прошлый раз, то в этот раз она выводится не будет
0010+  CA60             ;
0011+  CA60             ; 2013-11-01 Дизассемблировано vinxru
0012+  CA60             ;----------------------------------------------------------------------------
0013+  CA60             
0014+  CA60             setBottomLine:	; Первым байтом строки идет идентификатор. 
0015+  CA60             		; Если эта строка уже устаналивалась, то выходим
0016+  CA60 3A 34 D2    		lda	v_bottomLineId
0017+  CA63 BE          		cmp	m
0018+  CA64 C8          		rz
0019+  CA65 7E          		mov	a, m
0020+  CA66 23          		inx	h
0021+  CA67             
0022+  CA67             		; Далее идет текст, выводим его
0023+  CA67 F5          		push	psw
0024+  CA68 CD 4B C9    		 call	printString
0025+  CA6B F1          		pop	psw
0026+  CA6C             
0027+  CA6C             		; bottomLineId = a
0028+  CA6C C3 87 CA    		jmp	setBottomLineId
0029+  CA6F             
0030+  CA6F             ;----------------------------------------------------------------------------
0031+  CA6F             ; RAMFOS
0032+  CA6F             ; Включение и очистка нижней строки и перемещение туда курсора
0033+  CA6F             ; Вызывается при печати символа 090h
0034+  CA6F             ;
0035+  CA6F             ; 2013-11-01 Дизассемблировано и доработано vinxru
0036+  CA6F             ;----------------------------------------------------------------------------
0037+  CA6F             
0038+  CA6F             clearBottomLine:
0039+  CA6F             #if COLOR_SUPPORT
0040+  CA6F             		; Цвет по умолчанию
0041+  CA6F 3E F1       		mvi	a, INIT_SCREEN_COLOR
0042+  CA71 CD 15 D1    		call	setColor
0043+  CA74             #endif	
0044+  CA74             		; Очистить нижнюю строку (строка d=250, высота e=10)
0045+  CA74 11 0A FA    		lxi	d, 0FA0Ah
0046+  CA77 CD E2 CE    		call	clearLine
0047+  CA7A             
0048+  CA7A             		; Положение курсора
0049+  CA7A 21 F8 00    		lxi	h, 248
0050+  CA7D 22 3E C6    		shld	v_cursorPos
0051+  CA80             
0052+  CA80             		; Размер экрана (230-240)
0053+  CA80 21 F0 E6    		lxi	h, 0E6F0h
0054+  CA83             
0055+  CA83 22 32 D2    setScreenHeight:shld	v_screenHeight
0056+  CA86             
0057+  CA86 AF          		xra	a		
0058+  CA87 32 34 D2    setBottomLineId:sta	v_bottomLineId
0059+  CA8A C9          		ret
0060+  CA8B             
0061+  CA8B             ;----------------------------------------------------------------------------
0062+  CA8B             ; RAMFOS
0063+  CA8B             ; Отключение нижней строки, строка при этом не стирается сама
0064+  CA8B             ; Вызывается при выводе 1Fh, 1Fh (функцией clearScreen)
0065+  CA8B             ;
0066+  CA8B             ; 2013-11-01 Дизассемблировано vinxru
0067+  CA8B             ;----------------------------------------------------------------------------
0068+  CA8B             
0069+  CA8B 21 00 0A    bottomLineHide:	lxi	h, 0A00h
0070+  CA8E 22 30 D2    		shld	v_topLineHeight
0071+  CA91             		
0072+  CA91             		; Размер экрана (240-250)
0073+  CA91 21 FA F0    		lxi	h, 0F0FAh
0074+  CA94 C3 83 CA    		jmp	setScreenHeight
0197   CA97             .include "input.inc"
0001+  CA97             ;----------------------------------------------------------------------------
0002+  CA97             ; RAMFOS
0003+  CA97             ; Стандартная точка входа C836
0004+  CA97             ; Ввод командной строки
0005+  CA97             ;
0006+  CA97             ; На входе
0007+  CA97             ;  HL   - адрес буфера
0008+  CA97             ;  D    - длина буфера
0009+  CA97             ;  E=XX - режим без очистки знакоместа, можно двигаться вправо
0010+  CA97             ;  E=00 - с очисткой знакоместа, вправо двигаться нельзя
0011+  CA97             ;
0012+  CA97             ; 2013-11-01 Дизассемблировано vinxru
0013+  CA97             ;----------------------------------------------------------------------------
0014+  CA97             
0015+  CA97             
0016+  CA97             input:		; Сохраняем BC, HL
0017+  CA97 C5          		push	b
0018+  CA98 E5          		push	h
0019+  CA99             
0020+  CA99             		; Зачем, не понял
0021+  CA99 01 00 80    		lxi	b, 8000h
0022+  CA9C             
0023+  CA9C 0C          input_inrc:	inr	c		; Ниже мы уменьшим C
0024+  CA9D 14          input_inrd:	inr	d		; Ниже мы уменьшим D
0025+  CA9E CD FA CE    input_ignore:	call	keyWait
0026+  CAA1 FE 7F       		cpi	7Fh
0027+  CAA3 CA 9E CA    		jz	input_ignore
0028+  CAA6 FE 08       		cpi	8
0029+  CAA8 CA E4 CA    		jz	input_del	; При переходе на удаление C и D больше на единицу
0030+  CAAB FE 0D       		cpi	0Dh
0031+  CAAD CA CF CA    		jz	input_enter	; Выход с флагами nz, c
0032+  CAB0 FE 1F       		cpi	1Fh
0033+  CAB2 CA D2 CA    		jz	input_esc	; Выход с флагами z, nc
0034+  CAB5             		; Если не места для новых символов
0035+  CAB5 15          		dcr	d
0036+  CAB6 CA 9D CA    		jz	input_inrd
0037+  CAB9             		; Вправо
0038+  CAB9 FE 18       		cpi	18h
0039+  CABB CA D5 CA    		jz	input_right	; На входе С больше на единицу
0040+  CABE             		; Остальные служебные клавиши - выход
0041+  CABE FE 20       		cpi	20h
0042+  CAC0 14          		inr	d		; Устанавливаем флаги nz
0043+  CAC1 DA D1 CA    		jc	input_cmc	; Выход с флагами nz, nc
0044+  CAC4 15          		dcr	d
0045+  CAC5             		; Увеличиваем B
0046+  CAC5 04          		inr	b
0047+  CAC6             input_chr:	; Вывод символа на экран
0048+  CAC6 CD DF C8    		call	printCharA
0049+  CAC9             		; Сохранение символа в памяти
0050+  CAC9 77          		mov	m, a
0051+  CACA 23          		inx	h
0052+  CACB             		; Уменьшаем счетчик свободных байт
0053+  CACB 15          		dcr	d
0054+  CACC             		; Следующий символ
0055+  CACC C3 9C CA    		jmp	input_inrc
0056+  CACF             
0057+  CACF             ; ---------------------------------------------------------------------------
0058+  CACF             
0059+  CACF B7          input_enter:	ora	a	; Устанавливаем флаг - не нуль
0060+  CAD0 05          		dcr	b       ; Если были введены символы, то флаг минус
0061+  CAD1 3F          input_cmc:	cmc		; Инвертируем CF
0062+  CAD2             input_esc:	; Восстанавливаем DE, BC
0063+  CAD2 D1          		pop	d
0064+  CAD3 C1          		pop	b
0065+  CAD4 C9          		ret
0066+  CAD5             
0067+  CAD5             ; ---------------------------------------------------------------------------
0068+  CAD5             
0069+  CAD5             input_right:	; Если режим 0, то вправо двигаться нельзя
0070+  CAD5 1C          		inr	e
0071+  CAD6 1D          		dcr	e
0072+  CAD7 CA 9D CA    		jz	input_inrd
0073+  CADA             
0074+  CADA             		; Если в буфере служебные символы, зменяем их на пробел и выводим
0075+  CADA 3E 20       		mvi	a, ' ' 
0076+  CADC BE          		cmp	m
0077+  CADD D2 C6 CA    		jnc	input_chr
0078+  CAE0             
0079+  CAE0             		; Если обычные символы, выводм
0080+  CAE0 7E          		mov	a, m
0081+  CAE1 C3 C6 CA    		jmp	input_chr
0082+  CAE4             
0083+  CAE4             ; ---------------------------------------------------------------------------
0084+  CAE4             
0085+  CAE4             input_del:	; Перед вызовом D была увеличена на единицу, надо уменьшить
0086+  CAE4 15          		dcr	d
0087+  CAE5             
0088+  CAE5             		; Если ни одного байта не введено, выходим и увеличиваем С обратно
0089+  CAE5 0D          		dcr	c
0090+  CAE6 CA 9C CA    		jz	input_inrc
0091+  CAE9             
0092+  CAE9                             ; Если режим 0, то вместо удаленного символа ставим пробел
0093+  CAE9 1D          		dcr	e
0094+  CAEA 1C          		inr	e
0095+  CAEB CC DF C8    		cz	printCharA	; На входе A=8
0096+  CAEE 3E 20       		mvi	a, ' '
0097+  CAF0 CC DF C8    		cz	printCharA
0098+  CAF3             
0099+  CAF3             		; Курсор влево
0100+  CAF3 3E 08       		mvi	a, 8
0101+  CAF5 CD DF C8    		call	printCharA
0102+  CAF8             
0103+  CAF8             		; Уменьшаем указатель
0104+  CAF8 2B          		dcx	h
0105+  CAF9             
0106+  CAF9             		; Увеличиваем длину
0107+  CAF9 14          		inr	d
0108+  CAFA C3 9D CA    		jmp	input_inrd
0109+  CAFD             
0110+  CAFD             ; ---------------------------------------------------------------------------
0198   CAFD             .include "getCharFromScreen.inc"
0001+  CAFD             ;----------------------------------------------------------------------------
0002+  CAFD             ; RAMFOS
0003+  CAFD             ; Получить код символа на экране
0004+  CAFD             ;
0005+  CAFD             ; 2013-11-01 vinxru
0006+  CAFD             ;----------------------------------------------------------------------------                   
0007+  CAFD             
0008+  CAFD             getCharFromScreen:
0009+  CAFD E5          		push	h
0010+  CAFE D5          		push	d
0011+  CAFF C5          		push	b
0012+  CB00             
0013+  CB00             		; Адрес возврата
0014+  CB00 21 A2 CB    		lxi	h, popa_ret
0015+  CB03 E5          		push	h
0016+  CB04             
0017+  CB04             		; Положение курсора в пикселях
0018+  CB04 2A 3E C6    		lhld	v_cursorPos	
0019+  CB07             
0020+  CB07             		; Расчет адреса
0021+  CB07 EB          		xchg
0022+  CB08 CD 81 CD    		call	calcCharAddr
0023+  CB0B EB          		xchg
0024+  CB0C             		
0025+  CB0C             		; с - смещение в битах
0026+  CB0C             		; hl - адрес с видеопамяти
0027+  CB0C             
0028+  CB0C 06 08       		mvi	b, 8 ; Высота символа
0029+  CB0E 11 1A D2    		lxi	d, unk_D21A ; Сюда будет скопирован символ с экрана
0030+  CB11 D5          		push	d		
0031+  CB12 E5          loc_CAF9:	 push	h
0032+  CB13             		  ; Загрузить в HL из памяти по адресу HL
0033+  CB13 7E          		  mov	a, m		
0034+  CB14 24          		  inr	h
0035+  CB15 6E          		  mov	l, m
0036+  CB16 67          		  mov	h, a
0037+  CB17             		  ; Сдвигаем HL на c*2 бит
0038+  CB17 79          		  mov	a, c
0039+  CB18 F5          loc_CAFF:	   push	psw
0040+  CB19 CD 6E CB    		    call	hl_div_2
0041+  CB1C CD 6E CB    		    call	hl_div_2
0042+  CB1F F1          		   pop 	psw
0043+  CB20 3D          		   dcr	a
0044+  CB21 C2 18 CB    		  jnz	loc_CAFF
0045+  CB24             		  ; Сохраняем только нижние 6 бит по адресу de
0046+  CB24 7D          		  mov	a, l
0047+  CB25 E6 3F       		  ani	3Fh
0048+  CB27 12          		  stax	d
0049+  CB28 1B          		  dcx	d
0050+  CB29 E1          		 pop	h
0051+  CB2A 2D          		 dcr	l
0052+  CB2B 05          		 dcr	b
0053+  CB2C C2 12 CB    		jnz	loc_CAF9
0054+  CB2F             
0055+  CB2F             		; Если v_clearScreenByte не ноль
0056+  CB2F 3A 5C C6    		lda	v_clearScreenByte
0057+  CB32 B7          		ora	a
0058+  CB33 CA 42 CB    		jz	loc_CB29
0059+  CB36             		 ; Инвертируем байт по адресу de
0060+  CB36 06 08       		 mvi	b, 8
0061+  CB38             loc_CB1F:	  ; de++
0062+  CB38 13          		  inx	d
0063+  CB39             		  ; *de = (*de ^ 0xFF) & 0x3F;
0064+  CB39 1A          		  ldax	d
0065+  CB3A 2F          		  cma
0066+  CB3B E6 3F       		  ani	3Fh
0067+  CB3D 12          		  stax	d
0068+  CB3E             		  ; Цикл
0069+  CB3E 05          		  dcr	b
0070+  CB3F C2 38 CB    		 jnz	loc_CB1F
0071+  CB42 D1          loc_CB29:	pop	d
0072+  CB43             
0073+  CB43             		; de - адрес на экране
0074+  CB43             
0075+  CB43             		; Сравниваем каждый символ из знакогенератора с экраном
0076+  CB43             
0077+  CB43 3E FF       		mvi	a, -1
0078+  CB45 2A 0C C6    		lhld	v_charGenPtr	; Знакогенератор
0079+  CB48 01 08 00    		lxi	b, 8		; высота символа
0080+  CB4B             loc_CB32:	 ; Следующий символ
0081+  CB4B 09          		 dad	b		
0082+  CB4C C5          		 push	b
0083+  CB4D D5          		 push	d
0084+  CB4E E5          		 push	h
0085+  CB4F 47          		  mov	b, a
0086+  CB50 CD 60 CB    		  call	compareChar
0087+  CB53 78          		  mov	a, b
0088+  CB54 E1          		 pop	h
0089+  CB55 D1          		 pop	d
0090+  CB56 C1          		 pop	b
0091+  CB57 C2 4B CB    		jnz	loc_CB32
0092+  CB5A             
0093+  CB5A             		; Знакогенератор не содержит символов 80-BF
0094+  CB5A FE 80       		cpi	80h
0095+  CB5C D8          		rc
0096+  CB5D C6 40       		adi	40h		
0097+  CB5F C9          		ret
0098+  CB60             
0099+  CB60             ; ---------------------------------------------------------------------------
0100+  CB60             
0101+  CB60             compareChar:	; if(a == 0xBF) return true;
0102+  CB60 FE BF       		cpi	0BFh
0103+  CB62 C8          		rz
0104+  CB63             		; Увеличивае номер символа
0105+  CB63 04          		inr	b
0106+  CB64             		; Далее memcmp_hl1_de_c
0199   CB64             .include "memcmp_hl1_de_c.inc"
0001+  CB64             memcmp_hl1_de_c: ; if(*de-- != *--hl) return;
0002+  CB64 1A          		 ldax	d
0003+  CB65 1B          		 dcx	d
0004+  CB66 2B          		 dcx	h
0005+  CB67 BE          		 cmp	m
0006+  CB68 C0          		 rnz
0007+  CB69             		 ; c--
0008+  CB69 0D          		 dcr	c
0009+  CB6A C8          		 rz
0010+  CB6B C3 64 CB    		jmp	memcmp_hl1_de_c
0200   CB6E             .include "hl_div_2.inc"
0001+  CB6E             ;+---------------------------------------------------------------------------
0002+  CB6E             ; RAMFOS
0003+  CB6E             ; Деление HL на два
0004+  CB6E             ;
0005+  CB6E             ; 2013-11-01 vinxru
0006+  CB6E             ;----------------------------------------------------------------------------                   
0007+  CB6E             
0008+  CB6E             hl_div_2:	; Обнуляем флаг C
0009+  CB6E AF          		xra	a
0010+  CB6F 0F          		rrc
0011+  CB70                             ; Сдвигаем H		
0012+  CB70 7C          		mov	a, h
0013+  CB71 1F          		rar
0014+  CB72 67          		mov	h, a
0015+  CB73                             ; Сдвигаем L
0016+  CB73 7D          		mov	a, l
0017+  CB74 1F          		rar
0018+  CB75 6F          		mov	l, a
0019+  CB76 C9          		ret0201   CB77             .include "fullClearScreen.inc"
0001+  CB77             ;+---------------------------------------------------------------------------
0002+  CB77             ; RAMFOS
0003+  CB77             ; Стандартная точка входа C84E
0004+  CB77             ; Очистка всего экрана с отключением служебных строк
0005+  CB77             ;
0006+  CB77             ; Сохраняет все регистры
0007+  CB77             ;
0008+  CB77             ; 2013-11-01 Дизассемблировано vinxru
0009+  CB77             ;----------------------------------------------------------------------------                   
0010+  CB77             
0011+  CB77             fullClearScreen:
0012+  CB77 F5          		push	psw
0013+  CB78             
0014+  CB78             		; Эта переменная включает очистку всего экрана
0015+  CB78 3E 1F       		mvi	a, 1Fh
0016+  CB7A 32 10 D2    		sta	v_dblClear
0017+  CB7D             
0018+  CB7D             		; Печать символа 1Fh и освобождение стека
0019+  CB7D             		; call	printCharA
0020+  CB7D             		; pop	psw
0021+  CB7D             		; ret		
0022+  CB7D C3 95 CB    		jmp	printCharA_popret0202   CB80             .include "printHex.inc"
0001+  CB80             ;----------------------------------------------------------------------------
0002+  CB80             ; RAMFOS
0003+  CB80             ; Стандартная точка входа C815
0004+  CB80             ; Вывод 16-ричного числа на экране
0005+  CB80             ;
0006+  CB80             ; На входе
0007+  CB80             ;  A - число
0008+  CB80             ;
0009+  CB80             ; 2013-11-01 Дизассемблировано vinxru
0010+  CB80             ;----------------------------------------------------------------------------
0011+  CB80             
0012+  CB80 F5          printHex:	push	psw
0013+  CB81 0F          		rrc
0014+  CB82 0F          		rrc
0015+  CB83 0F          		rrc
0016+  CB84 0F          		rrc
0017+  CB85 CD 89 CB    		call	printHex_1
0018+  CB88 F1          		pop	psw
0019+  CB89 F5          printHex_1:	push	psw
0020+  CB8A E6 0F       		ani	0Fh
0021+  CB8C FE 0A       		cpi	0Ah
0022+  CB8E FA 93 CB    		jm	printHex_2
0023+  CB91 C6 07       		adi	7
0024+  CB93 C6 30       printHex_2:	adi	30h ; '0'
0025+  CB95             printCharA_popret:
0026+  CB95 CD DF C8    		call	printCharA
0027+  CB98 F1          pop_psw_ret:	pop	psw
0028+  CB99 C9          		ret
0203   CB9A             #if FAST_PRINT
0204   CB9A             .include "printChar_fast.inc"
0001+  CB9A             ;----------------------------------------------------------------------------
0002+  CB9A             ; RAMFOS
0003+  CB9A             ; Ускоренная функция выводе символа на экран.
0004+  CB9A             ;
0005+  CB9A             ; На входе:
0006+  CB9A             ;  с - символ
0007+  CB9A             ;
0008+  CB9A             ; 2013-11-01 Разработано vinxru
0009+  CB9A             ;----------------------------------------------------------------------------
0010+  CB9A             
0011+  CB9A E5          printChar:	push	h
0012+  CB9B D5          		push	d
0013+  CB9C C5          		push	b
0014+  CB9D F5          		push	psw
0015+  CB9E CD AC CB    printChar_pol:	 call	printChar_int
0016+  CBA1 F1          		pop	psw
0017+  CBA2 C1          popa_ret:	pop	b
0018+  CBA3 D1          		pop	d
0019+  CBA4 E1          		pop	h
0020+  CBA5 C9          		ret
0021+  CBA6             
0022+  CBA6             ; ---------------------------------------------------------------------------
0023+  CBA6             
0024+  CBA6 2A 3E C6    printCharAll:	lhld	v_cursorPos		
0025+  CBA9 C3 0C CC    		jmp	printChar_0
0026+  CBAC             
0027+  CBAC             ; ---------------------------------------------------------------------------
0028+  CBAC             
0029+  CBAC             printChar_int:	
0030+  CBAC~            #if NO_PRINTER==0
0031+  CBAC~            		; Если включен эхо режим на принтер
0032+  CBAC~            		lda	v_printerEcho
0033+  CBAC~            		cpi	0D2h
0034+  CBAC~            		cz	doPrinterEcho
0035+  CBAC             #endif
0036+  CBAC             		; hl - положение курсора в пикселях		
0037+  CBAC 2A 3E C6    		lhld	v_cursorPos		
0038+  CBAF             
0039+  CBAF             		; Служебные символы
0040+  CBAF 79          		mov	a, c		; Символ		
0041+  CBB0 FE 1F       		cpi	1Fh
0042+  CBB2 CA 87 CE    		jz	clearScreen
0043+  CBB5             
0044+  CBB5             		; Если символ >0x1F, пропускаем проверки ниже
0045+  CBB5 D2 E5 CB    		jnc	fast		
0046+  CBB8             
0047+  CBB8 FE 18       		cpi	18h
0048+  CBBA CA 06 CE    		jz	cursorRight
0049+  CBBD FE 08       		cpi	8
0050+  CBBF CA 22 CE    		jz	cursorLeft
0051+  CBC2 FE 19       		cpi	19h
0052+  CBC4 CA 2E CE    		jz	cursorUp
0053+  CBC7 FE 1A       		cpi	1Ah
0054+  CBC9 CA 14 CE    		jz	cursorDown
0055+  CBCC FE 0C       		cpi	0Ch
0056+  CBCE CA CD CE    		jz	loc_CE4B
0057+  CBD1 FE 0A       		cpi	0Ah
0058+  CBD3 CA 12 CE    		jz	cursorCrLf
0059+  CBD6 FE 1B       		cpi	1Bh
0060+  CBD8 CA 39 CD    		jz	printChar_esc
0061+  CBDB FE 07       		cpi	7
0062+  CBDD CA 5A D0    		jz	keySound
0063+  CBE0 FE 0D       		cpi	0Dh
0064+  CBE2 CA F4 CD    		jz	saveCursorPosX0
0065+  CBE5             				
0066+  CBE5             fast:		; Если меньше 0x60, переходим к печати
0067+  CBE5 FE 60       		cpi	60h
0068+  CBE7 DA 0C CC    		jc	printChar_0
0069+  CBEA             
0070+  CBEA             		; Символы меньше 0x80 
0071+  CBEA FE 80       		cpi	80h
0072+  CBEC DA 01 CC    		jc	printChar_koi
0073+  CBEF             
0074+  CBEF             		; Промежуток C0-FF преобразовать в 80-BF
0075+  CBEF D6 40       		sui	40h
0076+  CBF1 FA 0B CC    		jm	loc_CBF1
0077+  CBF4             
0078+  CBF4             		; Промежуток 80-BF преобразовать в 1-40
0079+  CBF4 D6 3F       		sui	3Fh		
0080+  CBF6             
0081+  CBF6             		; Обрабатываем промежуток 87-BF
0082+  CBF6 FE 08       		cpi	8
0083+  CBF8 D2 D9 CC    		jnc	printChar2
0084+  CBFB 4F          		mov	c, a
0085+  CBFC             
0086+  CBFC             		; Промежуток 80-86 преобразовать в символы 1-7
0087+  CBFC             		
0088+  CBFC             loc_CBE2:	; Если меньше 0x60, переходим к печати
0089+  CBFC FE 60       		cpi	60h
0090+  CBFE DA 0C CC    		jc	printChar_0
0091+  CC01             
0092+  CC01             		; Трансляция из KOI-7 в KOI-8
0093+  CC01 3A 2C C6    printChar_koi:	lda	v_koi8
0094+  CC04 B7          		ora	a
0095+  CC05 CA 0C CC    		jz	printChar_0
0096+  CC08 79          		mov	a, c
0097+  CC09 C6 40       		adi	40h		
0098+  CC0B             
0099+  CC0B 4F          loc_CBF1:	mov	c, a
0100+  CC0C             
0101+  CC0C             printChar_0:	; Если cursorX >= 190, то перевод строки
0102+  CC0C 7C          		mov	a, h
0103+  CC0D FE BE       		cpi	190
0104+  CC0F D4 12 CE    		cnc	cursorCrLf
0105+  CC12             
0106+  CC12             		; Не позволяем снимать инверсию в служебных строках
0107+  CC12 3A 32 D2                    lda	v_screenHeight
0108+  CC15 BD          		cmp	l
0109+  CC16 DA 23 CC    		jc	printChar_u
0110+  CC19 3A 30 D2                    lda	v_topLineHeight
0111+  CC1C BD          		cmp	l
0112+  CC1D 3A 5C C6    		lda	v_clearScreenByte
0113+  CC20 DA 25 CC    		jc	printChar_i
0114+  CC23 3E FF       printChar_u:	 mvi	a, -1
0115+  CC25 32 6F CD    printChar_i:    sta	v_clearScreenByte2
0116+  CC28             
0117+  CC28             		; Увеличиваем положение курсора
0118+  CC28 7C          		mov	a, h
0119+  CC29 C6 03       		adi	3
0120+  CC2B 32 3F C6    		sta	v_cursorPos+1	; Положение курсора в пикселях
0121+  CC2E             
0122+  CC2E             		; Положение курсора в DE
0123+  CC2E EB          		xchg
0124+  CC2F             
0125+  CC2F             		; Расчет адреса символа и знакоместа
0126+  CC2F CD 71 CD    		call	calcCharAddr3
0127+  CC32             
0128+  CC32             		; Косяк в координатах
0129+  CC32 7B          		mov	a, e
0130+  CC33 DE 08       		sbi	8
0131+  CC35 5F          		mov	e, a
0132+  CC36             
0133+  CC36 06 09       		mvi	b, 9
0134+  CC38             
0135+  CC38             		; Дублировать строку?
0136+  CC38 AF          		XRA	A
0137+  CC39 B6          		ORA	M
0138+  CC3A 3A 6F CD    		LDA	v_clearScreenByte2
0139+  CC3D F2 41 CC    		JP	drawCharDbl		
0140+  CC40 AE          		 XRA	M
0141+  CC41             drawCharDbl:
0142+  CC41             		 		 
0143+  CC41 2B          		dcx	h
0144+  CC42 0D          		dcr c
0145+  CC43 0D          		dcr c
0146+  CC44 0D          		dcr c
0147+  CC45 CA A9 CC    		jz printCharS4
0148+  CC48 0D          		dcr c
0149+  CC49 CA 91 CC    		jz printCharS2
0150+  CC4C 0D          		dcr c
0151+  CC4D CA 79 CC    		jz printCharS0
0152+  CC50             
0153+  CC50             ;----------------------------------------------------------------------------
0154+  CC50             ; Сдвиг на 6
0155+  CC50             
0156+  CC50 CD 53 CC    printCharS6:	CALL	printCharS6_0
0157+  CC53 1F          printCharS6_0:	 RAR
0158+  CC54 1F          		 RAR
0159+  CC55 1F          		 RAR
0160+  CC56 1F          		 RAR
0161+  CC57 F5          		 PUSH	PSW
0162+  CC58 E6 03       		  ANI	00000011b
0163+  CC5A 4F          		  MOV	C, A
0164+  CC5B 1A          		  LDAX	D
0165+  CC5C E6 FC       		  ANI	11111100b
0166+  CC5E A9          		  XRA	C
0167+  CC5F 12          		  STAX	D
0168+  CC60 14          		  INR	D
0169+  CC61 F1          		 POP	PSW
0170+  CC62 1F          		 RAR
0171+  CC63 E6 F0       		 ANI	11110000b
0172+  CC65 4F          		 MOV	C, A
0173+  CC66 1A          		 LDAX	D
0174+  CC67 E6 0F       		 ANI	00001111b
0175+  CC69 A9          		 XRA	C
0176+  CC6A 12          		 STAX	D
0177+  CC6B 15          		 DCR	D
0178+  CC6C 13          		 INX	D
0179+  CC6D 23          		 INX	H
0180+  CC6E 3A 6F CD    		 LDA	v_clearScreenByte2
0181+  CC71 AE          		 XRA	M
0182+  CC72 05          		 DCR	B
0183+  CC73 C2 53 CC    		JNZ	printCharS6_0
0184+  CC76 C3 CD CC    		JMP	drawChar_ll
0185+  CC79             
0186+  CC79             ;----------------------------------------------------------------------------
0187+  CC79             ; Сдвиг на 0
0188+  CC79             
0189+  CC79 CD 7C CC    printCharS0:    CALL	printCharS0_0
0190+  CC7C             printCharS0_0:
0191+  CC7C 87          		 ADD	A
0192+  CC7D 87          		 ADD	A
0193+  CC7E 4F          		 MOV	C, A
0194+  CC7F 1A          		 LDAX	D
0195+  CC80 E6 03       		 ANI	00000011b
0196+  CC82 A9          		 XRA	C
0197+  CC83 12          		 STAX	D
0198+  CC84 13          		 INX	D
0199+  CC85 23          		 INX	H
0200+  CC86 3A 6F CD    		 LDA	v_clearScreenByte2
0201+  CC89 AE          		 XRA	M
0202+  CC8A 05          		 DCR	B
0203+  CC8B C2 7C CC    		JNZ	printCharS0_0
0204+  CC8E C3 CD CC    		JMP	drawChar_ll
0205+  CC91             	
0206+  CC91             ;----------------------------------------------------------------------------
0207+  CC91             ; Сдвиг на 2
0208+  CC91             
0209+  CC91 CD 94 CC    printCharS2:    CALL	printCharS2_0
0210+  CC94 E6 3F       printCharS2_0:	 ANI	03Fh
0211+  CC96 4F          		 MOV	C, A
0212+  CC97 1A          		 LDAX	D
0213+  CC98 E6 C0       		 ANI	11000000b
0214+  CC9A A9          		 XRA	C
0215+  CC9B 12          		 STAX	D
0216+  CC9C 13          		 INX	D
0217+  CC9D 23          		 INX	H
0218+  CC9E 3A 6F CD    		 LDA	v_clearScreenByte2
0219+  CCA1 AE          		 XRA	M
0220+  CCA2 05          		 DCR	B
0221+  CCA3 C2 94 CC    		JNZ	printCharS2_0
0222+  CCA6 C3 CD CC    		JMP	drawChar_ll
0223+  CCA9             
0224+  CCA9             ;----------------------------------------------------------------------------
0225+  CCA9             ; Сдвиг на 4
0226+  CCA9             
0227+  CCA9 CD AC CC    printCharS4:	CALL	printCharS4_0
0228+  CCAC 1F          printCharS4_0:	 RAR
0229+  CCAD 1F          		 RAR
0230+  CCAE F5          		 PUSH	PSW
0231+  CCAF E6 0F       		  ANI	00001111b
0232+  CCB1 4F          		  MOV	C, A
0233+  CCB2 1A          		  LDAX	D
0234+  CCB3 E6 F0       		  ANI	11110000b
0235+  CCB5 A9          		  XRA	C
0236+  CCB6 12          		  STAX	D
0237+  CCB7 14          		  INR	D
0238+  CCB8 F1          		 POP	PSW
0239+  CCB9 1F          		 RAR
0240+  CCBA E6 C0       		 ANI	011000000b
0241+  CCBC 4F          		 MOV	C, A
0242+  CCBD 1A          		 LDAX	D
0243+  CCBE E6 3F       		 ANI	000111111b
0244+  CCC0 A9          		 XRA	C
0245+  CCC1 12          		 STAX	D
0246+  CCC2 15          		 DCR	D
0247+  CCC3 13          		 INX	D
0248+  CCC4 23          		 INX	H
0249+  CCC5 3A 6F CD    		 LDA	v_clearScreenByte2
0250+  CCC8 AE          		 XRA	M
0251+  CCC9 05          		 DCR	B
0252+  CCCA C2 AC CC    		JNZ	printCharS4_0
0253+  CCCD             
0254+  CCCD             ;----------------------------------------------------------------------------
0255+  CCCD             
0256+  CCCD 2B          drawChar_ll:	DCX	H
0257+  CCCE AF          		XRA	A
0258+  CCCF B6          		ORA	M
0259+  CCD0 3A 6F CD    		LDA	v_clearScreenByte2
0260+  CCD3 F2 D7 CC    		JP	drawCharDbl2
0261+  CCD6 AE          		 XRA	M
0262+  CCD7 04          drawCharDbl2:	INR	B
0263+  CCD8 C9          		RET
0264+  CCD9             
0265+  CCD9             ;----------------------------------------------------------------------------
0266+  CCD9                 
0267+  CCD9 D6 21       printChar2:    sui	21h
0268+  CCDB D2 F1 D0    		jnc	setColorChar
0269+  CCDE C6 19       		adi	19h
0270+  CCE0 CA 1C D1    		jz	popColor	; 87h Восстановние кода цвета из стека
0271+  CCE3 3D          		dcr	a
0272+  CCE4 CA F9 C7    		jz	pushColor	; 88h Запоминание кода цвета по принципу стека (глубина 2 цвета)
0273+  CCE7 3D          		dcr	a
0274+  CCE8 CA 11 D1    		jz	inverseColor	; 89h Инверсия кода цвета
0275+  CCEB 3D          		dcr	a
0276+  CCEC CA 58 CA    		jz	changeInverse	; 8Ah Инверсия фона чернобелого экрана (инверсия инверсии)
0277+  CCEF 3D          		dcr	a
0278+  CCF0 CA 5B CA    		jz	setInverseNeg	; 8Bh Установка светлого фона черно-белого экрана (потому что A=0 будет инвертировано)
0279+  CCF3 3D          		dcr	a
0280+  CCF4 CA 5C CA    		jz	setInverse	; 8Сh Установка темного фона черно-белого экрана (потому что A=0)
0281+  CCF7 3D          		dcr	a
0282+  CCF8 CA D6 C7    		jz	pushCursorLine	; 8Dh Запоминание курсора строки
0283+  CCFB 3D          		dcr	a
0284+  CCFC CA DD C7    		jz	popCursorLine	; 8Eh Восстановление курсора строки
0285+  CCFF 3D          		dcr	a
0286+  CD00 CA 1D CA    		jz	clearTopLine	; 8Fh Очистка верхней служебной строки
0287+  CD03 3D          		dcr	a
0288+  CD04 CA 6F CA    		jz	clearBottomLine	; 90h Очистка нижней служебной строки
0289+  CD07 3D          		dcr	a
0290+  CD08 CA 3E CE    		jz	scrollDown	; 91h Сдвииг экрана вних от курсора
0291+  CD0B 3D          		dcr	a
0292+  CD0C CA C7 CD    		jz	scrollUp	; 92h Сдвин экрана вверх от курсора
0293+  CD0F 3D          		dcr	a
0294+  CD10 CA E3 C7    		jz	pushCursor	; 93h Запоминание курсора экрана
0295+  CD13 3D          loc_CCC1: 	dcr	a
0296+  CD14 CA EA C7    		jz	popCursor	; 94h Восстановление курсора экрана
0297+  CD17 3D          		dcr	a
0298+  CD18 CA B3 C8    		jz	printFileName	; 95h Вывод имени файла загруженного с диска
0299+  CD1B 3D          		dcr	a
0300+  CD1C EB          		xchg
0301+  CD1D 2A 2C C6    		lhld	v_koi8
0302+  CD20 3D          		dcr	a
0303+  CD21 CA 40 D0    		jz	c_koi7		; 97h Включение режиме KOI-7
0304+  CD24 3D          		dcr	a
0305+  CD25 CA 3B D0    		jz	c_koi8		; 98h Включение режиме KOI-8
0306+  CD28 3D          		dcr	a
0307+  CD29 3D          		dcr	a
0308+  CD2A C0          		rnz			; Выход, а дальше 9Ah Сдвиг экрана вверх от нижней служеюной строки до текущей строки курсора
0309+  CD2B EB          		xchg
0310+  CD2C E5          		push	h
0311+  CD2D 2C          		inr	l
0312+  CD2E 2C          		inr	l
0313+  CD2F 7D          		mov	a, l
0314+  CD30 C6 0A       		adi	0Ah
0315+  CD32 5F          		mov	e, a
0316+  CD33 3A 32 D2    		lda	v_screenHeight
0317+  CD36 C3 CF CD    		jmp	c_scrolUpEx
0318+  CD39             
0319+  CD39             ; ---------------------------------------------------------------------------
0320+  CD39             
0321+  CD39 21 3F CD    printChar_esc:	lxi	h, printChar_esc1		
0322+  CD3C C3 51 CD    		jmp	setEscMode
0323+  CD3F             		
0324+  CD3F             ; ---------------------------------------------------------------------------
0325+  CD3F             
0326+  CD3F             printChar_esc1:	; Обработка первого символа ESC-последовательности
0327+  CD3F             
0328+  CD3F             		; Если символ Y, перейти к обработке второго символа
0329+  CD3F 79          		mov	a, c
0330+  CD40 FE 59       		cpi	'Y'
0331+  CD42 21 55 CD    		lxi	h, printChar_esc2
0332+  CD45 CA 51 CD    		jz	setEscMode
0333+  CD48             
0334+  CD48 2A 3E C6    		lhld	v_cursorPos
0335+  CD4B CD 0C CC    		call	printChar_0
0336+  CD4E             
0337+  CD4E 21 AC CB    setEscMode0:	lxi	h, printChar_int
0338+  CD51 22 9F CB    setEscMode:	shld	printChar_pol+1
0339+  CD54 C9          		ret
0340+  CD55             
0341+  CD55             ; ---------------------------------------------------------------------------
0342+  CD55             
0343+  CD55             printChar_esc2:	; Вычесть из буквы 20h
0344+  CD55 79          		mov	a, c
0345+  CD56 D6 20       		sui	20h
0346+  CD58 32 3E D2    		sta	v_escRow
0347+  CD5B 21 61 CD    		lxi	h, printChar_esc3
0348+  CD5E C3 51 CD    		jmp	setEscMode		
0349+  CD61             
0350+  CD61             ; ---------------------------------------------------------------------------
0351+  CD61             
0352+  CD61             printChar_esc3:	; Вычесть из буквы 20h
0353+  CD61 79          		mov	a, c
0354+  CD62 D6 20       		sui	20h
0355+  CD64 6F          		mov	l, a
0356+  CD65 3A 3E D2    		lda	v_escRow
0357+  CD68 67          		mov	h, a
0358+  CD69 CD 92 CD    		call	setCursorPos
0359+  CD6C C3 4E CD    		jmp	setEscMode0
0360+  CD6F             		
0361+  CD6F 00          v_clearScreenByte2:	.db 00205   CD70~            #else
0206   CD70~            .include "printChar.inc"
0207   CD70             #endif
0208   CD70             .include "calcCharAddr.inc"
0001+  CD70             ;----------------------------------------------------------------------------
0002+  CD70             ; RAMFOS
0003+  CD70             ; Расчет ареса символа в видеопамяти памяти и знакогенераторе
0004+  CD70             ;
0005+  CD70             ; 2013-11-01 Дизассемблировано vinxru
0006+  CD70             ;----------------------------------------------------------------------------
0007+  CD70             
0008+  CD70             calcCharAddr2:	; Какая то хрень
0009+  CD70 41          		mov	b, c
0010+  CD71 32 10 D2    calcCharAddr3:	sta	v_dblClear
0011+  CD74             
0012+  CD74             		; hl = charGen + c * 8
0013+  CD74 D5          		push	d
0014+  CD75 2A 0C C6    		 lhld	v_charGenPtr
0015+  CD78 EB          		 xchg
0016+  CD79 69          		 mov	l, c
0017+  CD7A 26 00       		 mvi	h, 0
0018+  CD7C 29          		 dad	h
0019+  CD7D 29          		 dad	h
0020+  CD7E 29          		 dad	h
0021+  CD7F 19          		 dad	d
0022+  CD80 D1          		pop	d
0023+  CD81             
0024+  CD81             ; Получить адрес и смещение символа на экране по координатам
0025+  CD81             ; Вход: de - координаты
0026+  CD81             ; Выход: de - адрес, c - смещение
0027+  CD81             		
0028+  CD81             calcCharAddr:	; c = (d & 3)
0029+  CD81 7A          		mov	a, d		
0030+  CD82 E6 03       		ani	3
0031+  CD84 4F          		mov	c, a
0032+  CD85 3E 05       		mvi	a, 5
0033+  CD87 91          		sub	c
0034+  CD88 4F          		mov	c, a
0035+  CD89             	
0036+  CD89             		; d = d / 4 + 0x90		
0037+  CD89 7A          		mov	a, d		
0038+  CD8A E6 FC       		ani	0FCh
0039+  CD8C 0F          		rrc
0040+  CD8D 0F          		rrc
0041+  CD8E C6 90       		adi	90h
0042+  CD90 57          		mov	d, a
0043+  CD91 C9          		ret
0209   CD92~            #if FAST_PRINT!=1
0210   CD92~            .include "printChar2.inc"	; Їа®¤®«¦ Ґвбп ў setCursorPos
0211   CD92             #endif
0212   CD92             .include "setCursorPos.inc"
0001+  CD92             ;----------------------------------------------------------------------------
0002+  CD92             ; RAMFOS
0003+  CD92             ; Стандартная точка входа C83C
0004+  CD92             ; Устанвока/получения положения курсора. Координаты в символах.
0005+  CD92             ;
0006+  CD92             ; На входе
0007+  CD92             ;  H - номер строки
0008+  CD92             ;  L - номер колонки
0009+  CD92             ;
0010+  CD92             ; 2013-11-01 Дизассемблировано vinxru
0011+  CD92             ;----------------------------------------------------------------------------
0012+  CD92             
0013+  CD92 E5          setCursorPos:	push	h
0014+  CD93 F5          		push	psw
0015+  CD94             
0016+  CD94             		; Поменять H L местами
0017+  CD94 7D          		mov	a, l
0018+  CD95 6C          		mov	l, h
0019+  CD96 67          		mov	h, a
0020+  CD97             
0021+  CD97             		; l = l * 10 - 2
0022+  CD97 3E FE       		mvi	a, -2
0023+  CD99 C6 0A       loc_CD1C:	 adi	10
0024+  CD9B 2D          		 dcr	l
0025+  CD9C F2 99 CD    		jp	loc_CD1C
0026+  CD9F 6F          		mov	l, a
0027+  CDA0             
0028+  CDA0             		; h *= 3
0029+  CDA0 3E FD       		mvi	a, -3
0030+  CDA2 C6 03       loc_CD25:	 adi	3
0031+  CDA4 25          		 dcr	h
0032+  CDA5 F2 A2 CD    		jp	loc_CD25
0033+  CDA8 67          		mov	h, a
0034+  CDA9             
0035+  CDA9             		; Сохранить положение курсора
0036+  CDA9 22 3E C6    		shld	v_cursorPos
0037+  CDAC             
0038+  CDAC F1          		pop	psw
0039+  CDAD E1          		pop	h
0040+  CDAE C9          		ret0213   CDAF             .include "getCursorPos.inc"
0001+  CDAF             ;+---------------------------------------------------------------------------
0002+  CDAF             ; RAMFOS
0003+  CDAF             ; Стандартная точка входа F81E	
0004+  CDAF             ; Получить координаты курсора в символах
0005+  CDAF             ;
0006+  CDAF             ; На выходе
0007+  CDAF             ;  h - строка (Y)
0008+  CDAF             ;  l - столбец (X)
0009+  CDAF             ;  Сохраняет остальные регистры
0010+  CDAF             ;
0011+  CDAF             ; 2013-11-01 vinxru
0012+  CDAF             ;----------------------------------------------------------------------------                   
0013+  CDAF             
0014+  CDAF F5          getCursorPos:	push	psw
0015+  CDB0 21 FF FF    		lxi	h, -1
0016+  CDB3             
0017+  CDB3             		; h = v_cursorPosY / 10
0018+  CDB3 3A 3E C6    		lda	v_cursorPos	
0019+  CDB6 24          getCursorPos_0:	 inr	h
0020+  CDB7 D6 0A       		 sui	0Ah
0021+  CDB9 D2 B6 CD    		jnc	getCursorPos_0
0022+  CDBC             
0023+  CDBC             		; l = v_cursorPosX / 3
0024+  CDBC 3A 3F C6    		lda	v_cursorPos+1			
0025+  CDBF 2C          getCursorPos_1:  inr	l
0026+  CDC0 D6 03       		 sui	3
0027+  CDC2 D2 BF CD    		jnc	getCursorPos_1
0028+  CDC5             
0029+  CDC5 F1          		pop	psw
0030+  CDC6 C9          		ret0214   CDC7             .include "scrollUp.inc"
0001+  CDC7             ;----------------------------------------------------------------------------
0002+  CDC7             ; RAMFOS
0003+  CDC7             ; Сдвиг экрана вверх
0004+  CDC7             ;
0005+  CDC7             ; 2013-11-01 Дизассемблировано vinxru
0006+  CDC7             ;----------------------------------------------------------------------------
0007+  CDC7             
0008+  CDC7 E5          scrollUp:	push	h
0009+  CDC8 7D          		mov	a, l		; c =  (l + 2 -	word_D231)/2
0010+  CDC9             
0011+  CDC9 2A 30 D2    		lhld	v_topLineHeight
0012+  CDCC 5C          		mov	e, h		; e = word_D231
0013+  CDCD 3C          		inr	a
0014+  CDCE 3C          		inr	a
0015+  CDCF 93          c_scrolUpEx:	sub	e
0016+  CDD0 1F          		rar
0017+  CDD1 4F          		mov	c, a
0018+  CDD2             		; Адрес видео
0019+  CDD2 26 90       		mvi	h, 90h
0020+  CDD4 54          		mov	d, h
0021+  CDD5             		; Колонки		
0022+  CDD5 06 30       		mvi	b, 48
0023+  CDD7 E5          loc_CD5A:	 push	h
0024+  CDD8 D5          		 push	d
0025+  CDD9 C5          		 push	b
0026+  CDDA             		  ; Копируем C байт
0027+  CDDA 0C          		  inr	c
0028+  CDDB 0D          		  dcr	c
0029+  CDDC C4 F9 CD    		  cnz	memcpy_hl_de_c2
0030+  CDDF             		  ; Очищаем последние 10 байт
0031+  CDDF 3A 5C C6    		  lda	v_clearScreenByte
0032+  CDE2 0E 0A       		  mvi	c, 10
0033+  CDE4 77          loc_CD67:	   mov	m, a
0034+  CDE5 2C          		   inr	l
0035+  CDE6 0D          		   dcr	c
0036+  CDE7 C2 E4 CD    		  jnz	loc_CD67
0037+  CDEA C1          		 pop	b
0038+  CDEB D1          		 pop	d
0039+  CDEC E1          		 pop	h
0040+  CDED             		 ; Следующая колонка
0041+  CDED 24          		 inr	h
0042+  CDEE 14          		 inr	d
0043+  CDEF 05          		 dcr	b
0044+  CDF0 C2 D7 CD    		jnz	loc_CD5A
0045+  CDF3 E1          		pop	h
0046+  CDF4             		; Установка положения курсора	
0047+  CDF4 26 00       saveCursorPosX0:mvi	h, 0
0048+  CDF6 C3 D5 CE    		jmp	saveCursorPos
0215   CDF9             .include "memcpy_hl_de_c2.inc"
0001+  CDF9 1A          memcpy_hl_de_c2:ldax	d
0002+  CDFA 77          		mov	m, a
0003+  CDFB 2C          		inr	l
0004+  CDFC 1C          		inr	e
0005+  CDFD 1A          		ldax	d
0006+  CDFE 77          		mov	m, a
0007+  CDFF 2C          		inr	l
0008+  CE00 1C          		inr	e
0009+  CE01 0D          		dcr	c
0010+  CE02 C2 F9 CD    		jnz	memcpy_hl_de_c2
0011+  CE05 C9          		ret
0216   CE06             .include "cursor.inc"
0001+  CE06             ;+---------------------------------------------------------------------------
0002+  CE06             ; RAMFOS
0003+  CE06             ; Функции перемещения курсора
0004+  CE06             ;
0005+  CE06             ; На входе в каждую функцию HL должен содержать v_cursorPos
0006+  CE06             ;
0007+  CE06             ; 2013-11-01 Дизассемблировано vinxru
0008+  CE06             ;----------------------------------------------------------------------------
0009+  CE06             
0010+  CE06             cursorRight:	; Если v_cursorX >= 190, то перейти на новую строку
0011+  CE06 7C          		mov	a, h
0012+  CE07 FE BE       		cpi	190
0013+  CE09 D2 12 CE    		jnc	cursorCrLf
0014+  CE0C             
0015+  CE0C             		; v_cursorX += 3
0016+  CE0C C6 03       		adi	3
0017+  CE0E 67          		mov	h, a
0018+  CE0F             
0019+  CE0F             		; Сохранить новое положение курсора (shld v_cursorPos, ret)
0020+  CE0F C3 D5 CE    		jmp	saveCursorPos
0021+  CE12             
0022+  CE12             ; ---------------------------------------------------------------------------
0023+  CE12             
0024+  CE12             cursorCrLf:	; v_cursorX = 0
0025+  CE12 26 00       		mvi	h, 0
0026+  CE14             
0027+  CE14             cursorDown:	; Если v_cursorY > screenHeight+10, сдвинуть экран вверх
0028+  CE14 3A 33 D2    		lda	v_screenHeight+1
0029+  CE17 BD          		cmp	l
0030+  CE18 DA C7 CD    		jc	scrollUp
0031+  CE1B             
0032+  CE1B             		; cursorY += 10
0033+  CE1B 7D          		mov	a, l
0034+  CE1C C6 0A       		adi	10
0035+  CE1E 6F          		mov	l, a
0036+  CE1F             
0037+  CE1F             		; Сохранить новое положение курсора (shld v_cursorPos, ret)
0038+  CE1F C3 D5 CE    		jmp	saveCursorPos
0039+  CE22             
0040+  CE22             ; ---------------------------------------------------------------------------
0041+  CE22             
0042+  CE22             cursorLeft:	; Если курсор у левого края экрана, ничего не делать
0043+  CE22 7C          		mov	a, h
0044+  CE23 FE 02       		cpi	2
0045+  CE25 DA D5 CE    		jc	saveCursorPos
0046+  CE28             
0047+  CE28             		; v_cursorX -= 3
0048+  CE28 D6 03       		sui	3
0049+  CE2A 67          		mov	h, a
0050+  CE2B             
0051+  CE2B             		; Сохранить новое положение курсора (shld v_cursorPos, ret)
0052+  CE2B C3 D5 CE    		jmp	saveCursorPos
0053+  CE2E             
0054+  CE2E             ; ---------------------------------------------------------------------------
0055+  CE2E             
0056+  CE2E             cursorUp:	; Если курсор выше word_D231, то сдвинуть экран вверх
0057+  CE2E 3A 31 D2    		lda	v_topLineHeight+1
0058+  CE31 BD          		cmp	l
0059+  CE32 D2 3C CE    		jnc	scrollDownX0
0060+  CE35             
0061+  CE35             		; v_cursorY -= 10
0062+  CE35 7D          		mov	a, l
0063+  CE36 D6 0A       		sui	10
0064+  CE38 6F          		mov	l, a
0065+  CE39             
0066+  CE39             		; Сохранить новое положение курсора (shld v_cursorPos, ret)
0067+  CE39 C3 D5 CE    		jmp	saveCursorPos0217   CE3C             .include "scrollDown.inc"
0001+  CE3C             ;----------------------------------------------------------------------------
0002+  CE3C             ; RAMFOS
0003+  CE3C             ; Сдвиг экрана вниз
0004+  CE3C             ;
0005+  CE3C             ; 2013-11-01 Дизассемблировано vinxru
0006+  CE3C             ;----------------------------------------------------------------------------
0007+  CE3C             
0008+  CE3C             scrollDownX0:	; x = 0
0009+  CE3C 26 00       		mvi	h, 0	; Влияет на расчет C, смотри ниже
0010+  CE3E             
0011+  CE3E E5          scrollDown:	push	h
0012+  CE3F             		; c = cursorY - 8
0013+  CE3F 7D          		mov	a, l
0014+  CE40 D6 08       		sui	8
0015+  CE42             		; if(v_cursorX != 0) c += 10
0016+  CE42 25          		dcr	h
0017+  CE43 24          		inr	h
0018+  CE44 CA 49 CE    		jz	scrollDown_0
0019+  CE47 C6 0A       		  adi	10		  
0020+  CE49 4F          scrollDown_0:	mov	c, a
0021+  CE4A             
0022+  CE4A             		; l = v_screenHeight, e = h = v_screenHeight-10
0023+  CE4A 2A 32 D2    		lhld	v_screenHeight
0024+  CE4D 5C          		mov	e, h
0025+  CE4E             
0026+  CE4E             		; if(v_screenHeight < c) goto CDF9
0027+  CE4E 7B          		mov	a, e
0028+  CE4F 91          		sub	c
0029+  CE50 DA 76 CE    		jc	scrollDown_1
0030+  CE53             
0031+  CE53             		; с = (v_screenHeight - c) / 2
0032+  CE53 1F          		rar
0033+  CE54 4F          		mov	c, a
0034+  CE55             
0035+  CE55             		; Адрес на экране. Для DE, HL идентичный, поскольку будет отличаться E, L
0036+  CE55 26 90       		mvi	h, 90h
0037+  CE57 54          		mov	d, h
0038+  CE58             
0039+  CE58             		; 48 столбцов
0040+  CE58 06 30       		mvi	b, 48
0041+  CE5A E5          scrollDown_2:	 push	h
0042+  CE5B D5          		 push	d
0043+  CE5C C5          		 push	b
0044+  CE5D             		  ; Копируем C линий
0045+  CE5D 0C          		  inr	c
0046+  CE5E 0D          		  dcr	c
0047+  CE5F C4 7A CE    		  cnz	memcpyb_hl_de_c2
0048+  CE62             		  ; Верхние 10 линий очищаем
0049+  CE62 3A 5C C6    		  lda	v_clearScreenByte
0050+  CE65 0E 0A       		  mvi	c, 10		
0051+  CE67 2D          scrollDown_3:	   dcr	l
0052+  CE68 77          		   mov	m, a
0053+  CE69 0D          		   dcr	c
0054+  CE6A C2 67 CE    		  jnz	scrollDown_3
0055+  CE6D C1          		 pop	b
0056+  CE6E D1          		 pop	d
0057+  CE6F E1          		 pop	h
0058+  CE70             		 ; Следующий столбец
0059+  CE70 24          		 inr	h
0060+  CE71 14          		 inr	d
0061+  CE72 05          		 dcr	b
0062+  CE73 C2 5A CE    		jnz	scrollDown_2
0063+  CE76             
0064+  CE76             scrollDown_1:	; Восстанавливам L, он же cursorY
0065+  CE76             		; cursorX, он же H будет заменен 0 в функции saveCursorPosX0
0066+  CE76 E1          		pop	h
0067+  CE77 C3 F4 CD    		jmp	saveCursorPosX0
0218   CE7A             .include "memcpyb_hl_de_c2.inc"
0001+  CE7A             memcpyb_hl_de_c2:
0002+  CE7A 2D          		dcr	l
0003+  CE7B 1D          		dcr	e
0004+  CE7C 1A          		ldax	d
0005+  CE7D 77          		mov	m, a
0006+  CE7E             
0007+  CE7E 2D          		dcr	l
0008+  CE7F 1D          		dcr	e
0009+  CE80 1A          		ldax	d
0010+  CE81 77          		mov	m, a
0011+  CE82             
0012+  CE82 0D          		dcr	c
0013+  CE83 C2 7A CE    		jnz	memcpyb_hl_de_c2
0014+  CE86 C9          		ret
0219   CE87             .include "clearScreen.inc"
0001+  CE87             ;----------------------------------------------------------------------------
0002+  CE87             ; RAMFOS
0003+  CE87             ; Очистить экран
0004+  CE87             ;
0005+  CE87             ; 2013-11-01 Дизассемблировано vinxru
0006+  CE87             ;----------------------------------------------------------------------------
0007+  CE87             
0008+  CE87             clearScreen:	
0009+  CE87             #if COLOR_SUPPORT
0010+  CE87             		; Цвет по умолчанию
0011+  CE87 3E F1       		mvi	a, INIT_SCREEN_COLOR
0012+  CE89 CD 15 D1    		call	setColor
0013+  CE8C             #endif
0014+  CE8C             clearScreen2:
0015+  CE8C             		; Сохраняем SP
0016+  CE8C 21 00 00    		lxi	h, 0
0017+  CE8F 39          		dad	sp
0018+  CE90 22 2D D2    		shld	v_oldSP
0019+  CE93             
0020+  CE93             		; Колонки
0021+  CE93 06 30       		mvi	b, 48
0022+  CE95             
0023+  CE95             		; Байт для заливки экрана
0024+  CE95 3A 5C C6    		lda	v_clearScreenByte
0025+  CE98 57          		mov	d, a
0026+  CE99 5F          		mov	e, a
0027+  CE9A             
0028+  CE9A             		; Заливаем экран. Начинаем с 383,240.
0029+  CE9A 21 F0 BF    		lxi	h, 0BFF0h
0030+  CE9D F9          loc_CE1B:	 sphl
0031+  CE9E 0E 17       		 mvi	c, 17h		; 230 строк
0032+  CEA0 D5          loc_CE1E:	  push	d
0033+  CEA1 D5          		  push	d
0034+  CEA2 D5          		  push	d
0035+  CEA3 D5          		  push	d
0036+  CEA4 D5          		  push	d
0037+  CEA5 0D          		  dcr	c
0038+  CEA6 C2 A0 CE    		 jnz	loc_CE1E
0039+  CEA9 25          		dcr	h
0040+  CEAA 05          		dcr	b
0041+  CEAB C2 9D CE    		jnz	loc_CE1B
0042+  CEAE             
0043+  CEAE             		; Восстаналиваем SP
0044+  CEAE 2A 2D D2    		lhld	v_oldSP
0045+  CEB1 F9          		sphl
0046+  CEB2             
0047+  CEB2             		; Дальше магия с переменными и строками состояния
0048+  CEB2             
0049+  CEB2             		; При печати двойного символа 1F скрываем нижнюю строку
0050+  CEB2 21 10 D2    		lxi	h, v_dblClear
0051+  CEB5 3E 1F       		mvi	a, 1Fh
0052+  CEB7 BE          		cmp	m
0053+  CEB8 CC 8B CA    		cz	bottomLineHide	; Если вызвана, то на выходе A=0		
0054+  CEBB 32 10 D2    		sta	v_dblClear
0055+  CEBE             
0056+  CEBE 3A 30 D2    		lda	v_topLineHeight
0057+  CEC1 B7          		ora	a
0058+  CEC2 CC DF CE    		cz	clearTopLine2
0059+  CEC5             
0060+  CEC5 3A 32 D2    		lda	v_screenHeight
0061+  CEC8 FE FA       		cpi	250
0062+  CECA CC D9 CE    		cz	sub_CE57
0063+  CECD             
0064+  CECD             loc_CE4B:	; cursorX = 0
0065+  CECD 26 00       		mvi	h, 0
0066+  CECF             
0067+  CECF             		; cursorY = byte_D231 - 2
0068+  CECF 3A 31 D2    		lda	v_topLineHeight+1
0069+  CED2 3D          		dcr	a
0070+  CED3 3D          		dcr	a
0071+  CED4 6F          		mov	l, a
0072+  CED5             		
0073+  CED5             saveCursorPos:	; Сохранить положение курсора
0074+  CED5 22 3E C6    		shld	v_cursorPos
0075+  CED8 C9          		ret
0076+  CED9             
0077+  CED9             ; ---------------------------------------------------------------------------
0078+  CED9             
0079+  CED9 11 10 00    sub_CE57:	lxi	d, 10h
0080+  CEDC C3 E2 CE    		jmp	clearLine	; d - строка, e	- высота
0081+  CEDF             
0082+  CEDF             ; ---------------------------------------------------------------------------
0220   CEDF             .include "clearLine.inc"
0001+  CEDF             ;----------------------------------------------------------------------------
0002+  CEDF             ; RAMFOS
0003+  CEDF             ; Очистить верхнюю строку
0004+  CEDF             ;
0005+  CEDF             ; 2013-11-01 Дизассемблировано vinxru
0006+  CEDF             ;----------------------------------------------------------------------------
0007+  CEDF             
0008+  CEDF 11 0A 0A    clearTopLine2:	lxi	d, 0A0Ah	; строка 10, высота 10
0009+  CEE2             
0010+  CEE2             ;----------------------------------------------------------------------------
0011+  CEE2             ; RAMFOS
0012+  CEE2             ; Очистить произвольное кол-во строк
0013+  CEE2             ;
0014+  CEE2             ; На входе
0015+  CEE2             ;  d - номер строки, выше которой строки будут очищены. Сама строка не очищается
0016+  CEE2             ;  e - кол-во строк
0017+  CEE2             ;
0018+  CEE2             ; 2013-11-01 Дизассемблировано vinxru
0019+  CEE2             ;----------------------------------------------------------------------------
0020+  CEE2             
0021+  CEE2 3A 5C C6    clearLine:	lda	v_clearScreenByte
0022+  CEE5 26 90       		mvi	h, 90h			; Адрес
0023+  CEE7 06 30       		mvi	b, 48			; Кол-во столбцов
0024+  CEE9 6A          clearRect_0:	 mov	l, d
0025+  CEEA 4B          		 mov	c, e		
0026+  CEEB 2D          clearRect_1:	  dcr	l
0027+  CEEC 0D          		  dcr	c		
0028+  CEED 77          		  mov	m, a
0029+  CEEE 2D          		  dcr	l
0030+  CEEF 0D          		  dcr	c
0031+  CEF0 77          		  mov	m, a
0032+  CEF1 C2 EB CE    		 jnz	clearRect_1
0033+  CEF4 24          		 inr	h
0034+  CEF5 05          		 dcr	b
0035+  CEF6 C2 E9 CE    		jnz	clearRect_0
0036+  CEF9 C9          		ret		0221   CEFA             .include "keyWait.inc"
0001+  CEFA             ;----------------------------------------------------------------------------
0002+  CEFA             ; RAMFOS
0003+  CEFA             ; Ожидание нажатия клавиши с курсором
0004+  CEFA             ;
0005+  CEFA             ; 2013-11-01 Дизассемблировано vinxru
0006+  CEFA             ;----------------------------------------------------------------------------
0007+  CEFA             
0008+  CEFA E5          keyWait:	push	h
0009+  CEFB D5          		push	d
0010+  CEFC C5          		push	b
0011+  CEFD             		 ; Нажата ли клавиша
0012+  CEFD CD 47 CF    		 call	keyCheck
0013+  CF00             		 ; Если клавиша не нажата, мигаем курсором, пока не нажмут
0014+  CF00 CC 0F CF    		 cz	keyCursor
0015+  CF03             		 ; Сбрасыаем флаг v_key2
0016+  CF03 AF          		 xra	a
0017+  CF04 32 25 D2    		 sta	v_key2
0018+  CF07             		 ; Нажатая клавиша в v_key1
0019+  CF07 3A 2B D2    		 lda	v_key1
0020+  CF0A C1          		pop	b		
0021+  CF0B D1          popa_ora_a_ret:	pop	d
0022+  CF0C E1          loc_CE8A:	pop	h
0023+  CF0D B7          ora_a_ret:	ora	a
0024+  CF0E C9          		ret
0222   CF0F             .include "keyCursor.inc"		
0001+  CF0F             ;----------------------------------------------------------------------------
0002+  CF0F             ; RAMFOS
0003+  CF0F             ; Ожидание нажатия клавиши с курсором
0004+  CF0F             ;
0005+  CF0F             ; 2013-11-01 Дизассемблировано vinxru
0006+  CF0F             ;----------------------------------------------------------------------------
0007+  CF0F             
0008+  CF0F             keyCursor:	; Рисуем курсор XOR-ом
0009+  CF0F CD 19 CF    		call	keyCursor1
0010+  CF12             		; Стираем курсор XOR-ом
0011+  CF12 CD 19 CF    		call	keyCursor1
0012+  CF15             		; Если была нажата клавиаша, выходим
0013+  CF15 C0          		rnz
0014+  CF16             		; Бесконечное ожидание
0015+  CF16 C3 0F CF    		jmp	keyCursor
0016+  CF19             
0017+  CF19             ;----------------------------------------------------------------------------
0018+  CF19             
0019+  CF19             keyCursor1:	
0020+  CF19~            #if FAST_PRINT != 1
0021+  CF19~            		; Код символа курсора
0022+  CF19~            		mvi	c, 17h
0023+  CF19~            
0024+  CF19~            		; Положение курсора в пикселях 		
0025+  CF19~            		lhld	v_cursorPos
0026+  CF19~            		xchg
0027+  CF19~            
0028+  CF19~            		; Получение изображения символа hl и адреса в видеопамяти de
0029+  CF19~            		call	calcCharAddr2
0030+  CF19~            
0031+  CF19~            		; Корректировка адреса
0032+  CF19~            		mov	a, e
0033+  CF19~            		sui	7
0034+  CF19~            		mov	e, a
0035+  CF19~            
0036+  CF19~            		; Рисование курсора
0037+  CF19~            		call	drawChar
0038+  CF19             #else
0039+  CF19             		; Положение курсора в пикселях 		
0040+  CF19 2A 3E C6    		lhld	v_cursorPos
0041+  CF1C EB          		xchg
0042+  CF1D             
0043+  CF1D             		; Получение адреса в видеопамяти de
0044+  CF1D CD 81 CD    		call calcCharAddr
0045+  CF20             
0046+  CF20             		; Исходный символ
0047+  CF20 21 3F 00    		lxi	h, 3Fh		 
0048+  CF23             
0049+  CF23             		; Сдвигаем
0050+  CF23 79          		mov	a, c		
0051+  CF24 29          drawCursor_0:	 dad	h
0052+  CF25 29          		 dad	h
0053+  CF26 3D          		 dcr	a
0054+  CF27 C2 24 CF    		jnz	drawCursor_0
0055+  CF2A             
0056+  CF2A             		; Цикл b
0057+  CF2A 06 08       		mvi	b, 8
0058+  CF2C             drawCursor_1:	 ; *de++ ^= hl
0059+  CF2C 1A          		 ldax	d
0060+  CF2D AC          		 xra	h
0061+  CF2E 12          		 stax	d		 
0062+  CF2F 14          		 inr	d		 
0063+  CF30 1A          		 ldax	d
0064+  CF31 AD          		 xra	l
0065+  CF32 12          		 stax	d
0066+  CF33 15          		 dcr	d
0067+  CF34 1D          		 dcr	e		
0068+  CF35             		 ; Цикл
0069+  CF35 05          		 dcr	b
0070+  CF36 C2 2C CF    		jnz	drawCursor_1
0071+  CF39             #endif
0072+  CF39             		; Ждем нажатия клавиши
0073+  CF39 21 FF 02    		lxi	h, CURSOR_BLINK_SPEED
0074+  CF3C CD 47 CF    keyCursor1_0:	 call	keyCheck
0075+  CF3F C0          		 rnz
0076+  CF40 2B          		 dcx	h
0077+  CF41 7C          		 mov	a, h
0078+  CF42 B5          		 ora	l
0079+  CF43 C2 3C CF    		jnz	keyCursor1_0
0080+  CF46 C9          		ret0223   CF47             .include "keyCheck.inc"
0001+  CF47             ;----------------------------------------------------------------------------
0002+  CF47             ; RAMFOS
0003+  CF47             ; Автоповтор клавиатуры и эхопечать (обертка над сканирование клавиатуры)
0004+  CF47             ;
0005+  CF47             ; 2013-11-01 Дизассемблировано vinxru
0006+  CF47             ;----------------------------------------------------------------------------
0007+  CF47             
0008+  CF47~            #if FAST_PRINT==0
0009+  CF47~            keyScanWhilePrint:
0010+  CF47~            		; Обработка клавиш во время вывода и эхопечать
0011+  CF47~            
0012+  CF47~            		; Если v_cursorY=8 или 248, выходим 
0013+  CF47~            		mov	a, e
0014+  CF47~            		cpi	8
0015+  CF47~            		rz
0016+  CF47~            		cpi	248
0017+  CF47~            		rz
0018+  CF47~            
0019+  CF47~            		; Если включен эхо режим на принтер
0020+  CF47~            		lda	v_printerEcho
0021+  CF47~            		cpi	0D2h
0022+  CF47~            		jz	doPrinterEcho
0023+  CF47             #endif
0024+  CF47             		
0025+  CF47             keyCheck:
0026+  CF47             		; Какой то флаг
0027+  CF47 3A 25 D2    		lda	v_key2
0028+  CF4A B7          		ora	a
0029+  CF4B C0          		rnz
0030+  CF4C             
0031+  CF4C             		; Что то считаем
0032+  CF4C E5          		push	h
0033+  CF4D D5          		push	d
0034+  CF4E 2A 29 D2    		 lhld	v_key0
0035+  CF51 EB          		 xchg
0036+  CF52 2A 2B D2    		 lhld	v_key1
0037+  CF55 CD 65 CF    		 call	sub_CEE2
0038+  CF58 22 2B D2    		 shld	v_key1	; Нажатая клавиша в L
0039+  CF5B EB          		 xchg
0040+  CF5C 22 29 D2    		 shld	v_key0
0041+  CF5F 32 25 D2    		 sta	v_key2
0042+  CF62             
0043+  CF62             		; pop d
0044+  CF62             		; pop h
0045+  CF62             		; ora a
0046+  CF62             		; ret
0047+  CF62 C3 0B CF    		jmp	popa_ora_a_ret
0048+  CF65             
0049+  CF65             ; ---------------------------------------------------------------------------
0050+  CF65             
0051+  CF65             sub_CEE2:	; Получить код нажатой клавиши
0052+  CF65 CD 8B CF    		call	keyScan
0053+  CF68             
0054+  CF68             		; Если нажатая клавиша не L
0055+  CF68 BD          		cmp	l
0056+  CF69 6F          		mov	l, a
0057+  CF6A C2 84 CF    		jnz	loc_CF01
0058+  CF6D             
0059+  CF6D             		; Если клавиша не была нажата, выходим с кодом 0
0060+  CF6D 3C          		inr	a
0061+  CF6E C8          		rz
0062+  CF6F             
0063+  CF6F             		; Уменьшаем DE, и если он не нулевой, выходим с кодом 0
0064+  CF6F 1B          		dcx	d
0065+  CF70 7A          		mov	a, d
0066+  CF71 B3          		ora	e
0067+  CF72 3E 00       		mvi	a, 0
0068+  CF74 C0          		rnz
0069+  CF75             
0070+  CF75             		; Звуковой сигнал
0071+  CF75 CD 5A D0    		call	keySound
0072+  CF78             
0073+  CF78             		; Инициализируем счетчик
0074+  CF78 11 7C 01    		lxi	d, 17Ch
0075+  CF7B             
0076+  CF7B             		; Если H=0, выходим с кодом 0FFh
0077+  CF7B 25          		dcr	h
0078+  CF7C 3E FF       		mvi	a, 0FFh
0079+  CF7E C8          		rz
0080+  CF7F             
0081+  CF7F             		; Возвращаем H
0082+  CF7F 24          		inr	h
0083+  CF80             
0084+  CF80             		; Инициализируем счетчик
0085+  CF80 11 1C 00    		lxi	d, 1Ch
0086+  CF83 C9          		ret
0087+  CF84             ; ---------------------------------------------------------------------------
0088+  CF84             
0089+  CF84             loc_CF01:	; Записываем H=1
0090+  CF84 26 01       		mvi	h, 1
0091+  CF86             
0092+  CF86             		; Выходим с кодом 0
0093+  CF86 AF          		xra	a        	
0094+  CF87             
0095+  CF87             		; Инициализируем счетчик
0096+  CF87 11 30 00    		lxi	d, 30h
0097+  CF8A C9          		ret
0098+  CF8B             
0099+  CF8B             ; ---------------------------------------------------------------------------
0224   CF8B             .include "keyScan.inc"		; Їа®¤®«¦ Ґвбп ў keySound
0001+  CF8B             ;----------------------------------------------------------------------------
0002+  CF8B             ; RAMFOS
0003+  CF8B             ; Сканирование клавиатуры
0004+  CF8B             ;
0005+  CF8B             ; 2013-11-01 Дизассемблировано vinxru
0006+  CF8B             ;----------------------------------------------------------------------------
0007+  CF8B             
0008+  CF8B             keyScan:		; Сохраняем регистры BC, DE, HL
0009+  CF8B E5          		push	h
0010+  CF8C D5          		push	d
0011+  CF8D C5          		push	b
0012+  CF8E CD A7 CF    		 call	keyScan_0
0013+  CF91 C1          		pop	b
0014+  CF92 D1          		pop	d
0015+  CF93 E1          		pop	h
0016+  CF94             
0017+  CF94             		; Флаг Z
0018+  CF94 B7          		ora	a
0019+  CF95             		
0020+  CF95             keyMode82:	; Восстаналиваем индикатор РУС/LAT
0021+  CF95             		; Вызывается из biosinit.inc
0022+  CF95             
0023+  CF95             		; Сохраняем результат
0024+  CF95 F5          		push	psw
0025+  CF96             		 ; Далее устаналиваем режим клавиатуры 82h
0026+  CF96 3E 82       		 mvi	a, 82h
0027+  CF98 32 E3 FF    		 sta	IO_KEYB_MODE
0028+  CF9B             		 ; Устаналиваем светодиод РУС/ЛАТ
0029+  CF9B 3A 2D C6    		 lda	v_rusLat
0030+  CF9E E6 01       		 ani	1
0031+  CFA0 F6 0C       		 ori	0Ch
0032+  CFA2 32 E3 FF    		 sta	IO_KEYB_MODE
0033+  CFA5 F1          		pop	psw
0034+  CFA6             
0035+  CFA6 C9          		ret
0036+  CFA7             
0037+  CFA7             ; ---------------------------------------------------------------------------
0038+  CFA7             
0039+  CFA7             keyScan_0:	; Получаем номер ряда нажатой клавиши в B
0040+  CFA7 CD 95 CF    		call	keyMode82
0041+  CFAA 3A E1 FF    		lda	IO_KEYB_B
0042+  CFAD 47          		mov	b, a
0043+  CFAE             
0044+  CFAE             		; Если ни одна клавиша не нажата, выходим
0045+  CFAE F6 03       		ori	3
0046+  CFB0 FE FF       		cpi	0FFh
0047+  CFB2 C8          		rz
0048+  CFB3             
0049+  CFB3             		; Получаем номер колонки нажатой клавиши в HL
0050+  CFB3 3E 91       		mvi	a, 91h
0051+  CFB5 32 E3 FF    		sta	IO_KEYB_MODE
0052+  CFB8 3A E0 FF    		lda	IO_KEYB_A
0053+  CFBB 6F          		mov	l, a		
0054+  CFBC 3A E2 FF    		lda	IO_KEYB_C
0055+  CFBF F6 F0       		ori	0F0h
0056+  CFC1 67          		mov	h, a
0057+  CFC2             
0058+  CFC2             		; Если колонка не нажата или нажата особая комбинация, выходим.
0059+  CFC2             		; При этом может быть возвращена ерунда!
0060+  CFC2 BD          		cmp	l
0061+  CFC3 C8          		rz
0062+  CFC4             		
0063+  CFC4             		; Помещаем в L номер первого нулевого бита из HL
0064+  CFC4 3E FB       		mvi	a, 0FBh
0065+  CFC6 3C          keyScan_1:	 inr	a
0066+  CFC7 29          		 dad	h
0067+  CFC8 DA C6 CF    		 jc	keyScan_1
0068+  CFCB 6F          		mov	l, a
0069+  CFCC             
0070+  CFCC             		; Помещаем в С номер первого нулевого бита из B
0071+  CFCC 78          		mov	a, b
0072+  CFCD F6 03       		ori	3
0073+  CFCF 37          		stc
0074+  CFD0 0E FD       		mvi	c, 0FDh
0075+  CFD2 0C          keyScan_2:	 inr	c
0076+  CFD3 1F          		 rar
0077+  CFD4 DA D2 CF    		jc	keyScan_2
0078+  CFD7             
0079+  CFD7             		; Если нажато более одной кнопки
0080+  CFD7 3C          		inr	a
0081+  CFD8 C2 49 D0    		jnz	specialKeysRet
0082+  CFDB             
0083+  CFDB             		; b = !b & 2
0084+  CFDB 78          		mov	a, b
0085+  CFDC 2F          		cma
0086+  CFDD E6 02       		ani	2
0087+  CFDF 47          		mov	b, a
0088+  CFE0             
0089+  CFE0 79          		mov	a, c
0090+  CFE1 07          		rlc
0091+  CFE2 07          		rlc
0092+  CFE3 07          		rlc
0093+  CFE4 07          		rlc
0094+  CFE5 B5          		ora	l
0095+  CFE6             
0096+  CFE6             		; a = keybMap[a]
0097+  CFE6 5F          		mov	e, a		
0098+  CFE7 16 00       		mvi	d, 0
0099+  CFE9 2A 0E C6    		lhld	v_keybMap
0100+  CFEC 19          		dad	d
0101+  CFED 7E          		mov	a, m
0102+  CFEE             
0103+  CFEE             		; Сохраняем на будущее
0104+  CFEE 4F          		mov	c, a		; c = a
0105+  CFEF             
0106+  CFEF             		; if(a < 0x21) return;
0107+  CFEF FE 21       		cpi	21h
0108+  CFF1 D8          		rc
0109+  CFF2             
0110+  CFF2             		; Специальные клавиши
0111+  CFF2 FE 8B       		cpi	8Bh
0112+  CFF4 CA 5A C8    		jz	j_tapeMode
0113+  CFF7 FE 8C       		cpi	8Ch
0114+  CFF9 CA 57 C8    		jz	j_printerEchoMode
0115+  CFFC             
0116+  CFFC 2A 2C C6    		lhld	v_koi8
0117+  CFFF             
0118+  CFFF FE 81       		cpi	81h
0119+  D001 CA B3 D0    		jz	capsLock
0120+  D004 FE 8A       		cpi	8Ah
0121+  D006 CA 43 D0    		jz	inverseVideo
0122+  D009 FE 40       		cpi	40h
0123+  D00B DA 31 D0    		jc	pressed40
0124+  D00E             
0125+  D00E 3A 2E C6    		lda	v_capsLock
0126+  D011 A8          		xra	b
0127+  D012 47          		mov	b, a
0128+  D013 79          		mov	a, c
0129+  D014 24          		inr	h
0130+  D015 CA 26 D0    		jz	loc_CFA3
0131+  D018 05          		dcr	b
0132+  D019 F8          		rm
0133+  D01A C6 20       		adi	20h ; ' '
0134+  D01C 2C          		inr	l
0135+  D01D C0          		rnz
0136+  D01E C6 A0       		adi	0A0h ; 'а'
0137+  D020 FE 08       		cpi	8
0138+  D022 D0          		rnc
0139+  D023 C6 7F       		adi	7Fh ; ''
0140+  D025 C9          		ret
0141+  D026             
0142+  D026             ; ---------------------------------------------------------------------------
0143+  D026             
0144+  D026 C6 20       loc_CFA3:	adi	20h ; ' '
0145+  D028 2C          		inr	l
0146+  D029 C8          		rz
0147+  D02A C6 60       		adi	60h ; '`'
0148+  D02C 05          		dcr	b
0149+  D02D F0          		rp
0150+  D02E C6 20       		adi	20h ; ' '
0151+  D030 C9          		ret
0152+  D031             
0153+  D031             ; ---------------------------------------------------------------------------
0154+  D031             
0155+  D031 05          pressed40:	dcr	b
0156+  D032 F8          		rm
0157+  D033 D6 10       		sui	10h
0158+  D035 FE 20       		cpi	20h ; ' '
0159+  D037 D0          		rnc
0160+  D038 C6 20       		adi	20h ; ' '
0161+  D03A C9          		ret
0162+  D03B             
0163+  D03B             ; ---------------------------------------------------------------------------
0164+  D03B             
0165+  D03B             c_koi8:					; CODE XREF: ROM:CCD3j
0166+  D03B 7D          		mov	a, l
0167+  D03C 2F          		cma
0168+  D03D C3 41 D0    		jmp	loc_CFBE
0169+  D040             ; ---------------------------------------------------------------------------
0170+  D040             
0171+  D040             c_koi7:					; CODE XREF: ROM:CCCFj
0172+  D040 7D          		mov	a, l
0173+  D041             
0174+  D041 B7          loc_CFBE:	ora	a
0175+  D042 C0          		rnz
0176+  D043             
0177+  D043 7D          inverseVideo:	mov	a, l		; l = ~l;
0178+  D044 2F          		cma
0179+  D045 6F          		mov	l, a
0180+  D046             
0181+  D046 22 2C C6    capsLockRet:    shld	v_koi8
0182+  D049             
0183+  D049             specialKeysRet:	; Если не не выводим в стркоу статуса, обновить её
0184+  D049 3A 3E C6    		lda	v_cursorPos
0185+  D04C FE 08       		cpi	8
0186+  D04E C4 31 CA    		cnz	printIndicators
0187+  D051             
0188+  D051             		; Задежка
0189+  D051 21 00 40    		lxi	h, 4000h	
0190+  D054 2B          keyScan_delay:	 dcx	h
0191+  D055 7C          		 mov	a, h
0192+  D056 B5          		 ora	l
0193+  D057 C2 54 D0    		jnz	keyScan_delay
0194+  D05A             
0195+  D05A             		; Переход на keySound
0225   D05A             .include "keySound.inc"
0001+  D05A             ;----------------------------------------------------------------------------
0002+  D05A             ; RAMFOS
0003+  D05A             ; Звуковой сигнал при нажатии клавиши
0004+  D05A             ;
0005+  D05A             ; 2013-11-01 vinxru
0006+  D05A             ;----------------------------------------------------------------------------
0007+  D05A             
0008+  D05A C5          keySound:	push	b
0009+  D05B EB          		 xchg
0010+  D05C 2A 4C C6    		 lhld	v_beepConfig
0011+  D05F EB          		 xchg
0012+  D060             
0013+  D060 3A 2D C6    		 lda	v_rusLat
0014+  D063 E6 01       		 ani	1
0015+  D065 7A          		 mov	a, d
0016+  D066 C2 6A D0    		 jnz	keySound_0
0017+  D069 0F          		  rrc
0018+  D06A 57          keySound_0:	 mov	d, a
0019+  D06B             
0020+  D06B 43          		 mov	b, e
0021+  D06C 4B          		 mov	c, e
0022+  D06D B7          		 ora	a
0023+  D06E CD 9C D0    		 call	setTimer
0024+  D071 C1          		pop	b
0025+  D072             
0026+  D072 3E FF       		mvi	a, 0FFh
0027+  D074 C9          		ret
0226   D075             .include "oldbeep.inc"
0001+  D075             ;+---------------------------------------------------------------------------
0002+  D075             ; RAMFOS
0003+  D075             ; Стандартная точка входа C851
0004+  D075             ; Воспроизвести звуковой сигнал через ВВ55
0005+  D075             ;
0006+  D075             ; Частота задается в v_oldBeep
0007+  D075             ;
0008+  D075             ; 2013-11-01 Дизассемблировано vinxru
0009+  D075             ;----------------------------------------------------------------------------
0010+  D075             
0011+  D075 F5          oldBeep:	push	psw
0012+  D076 C5          		push	b
0013+  D077 E5          		push	h
0014+  D078 2A 4E C6    		 lhld	v_oldBeep
0015+  D07B 3E 0B       oldBeep_0:	 mvi	a, 0Bh
0016+  D07D 32 E3 FF    		  sta	IO_KEYB_MODE
0017+  D080 CD 93 D0    		  call	delay_l
0018+  D083 3E 0A       		  mvi	a, 0Ah
0019+  D085 32 E3 FF    		  sta	IO_KEYB_MODE
0020+  D088 CD 93 D0    		  call	delay_l
0021+  D08B 25          		  dcr	h
0022+  D08C C2 7B D0    		 jnz	oldBeep_0
0023+  D08F E1          		pop	h
0024+  D090 C1          		pop	b
0025+  D091 F1          		pop	psw
0026+  D092 C9          		ret
0227   D093             .include "delay_l.inc"
0001+  D093             ;+---------------------------------------------------------------------------
0002+  D093             ; RAMFOS
0003+  D093             ; Задержка
0004+  D093             ;
0005+  D093             ; На входе
0006+  D093             ;  L - длительность
0007+  D093             ;
0008+  D093             ; На выходе
0009+  D093             ;  B - 0
0010+  D093             ;
0011+  D093             ; 2013-11-01 Дизассемблировано vinxru
0012+  D093             ;----------------------------------------------------------------------------
0013+  D093             
0014+  D093 45          delay_l:	mov	b, l
0015+  D094 05          delay_l_0:	dcr	b
0016+  D095 C2 94 D0    		jnz	delay_l_0
0017+  D098 C9          		ret
0228   D099             .include "beep.inc"
0001+  D099             ;+---------------------------------------------------------------------------
0002+  D099             ; RAMFOS
0003+  D099             ; Стандартная точка входа C848
0004+  D099             ; Воспроизвести звуковой сигнал через ВИ53
0005+  D099             ;
0006+  D099             ; На входе:
0007+  D099             ;  de - частота
0008+  D099             ;  bс - длительность
0009+  D099             ;  с  - ждать завершения предыдущего звукового сигнала
0010+  D099             ;  z  - ждать завершения этого звукового сигнала
0011+  D099             ;
0012+  D099             ; 2013-11-01 Дизассемблировано vinxru
0013+  D099             ;----------------------------------------------------------------------------
0014+  D099             
0015+  D099             beep:		; Ожидание заверения прошлого звукового сигнала, если C
0016+  D099 DC A8 D0    		cc	waitBeep		
0017+  D09C             
0018+  D09C             		; de-частота, bс-длительность, z-ждать
0019+  D09C E5          setTimer:	push	h
0020+  D09D 21 EC FF    		 lxi	h, IO_TIMER
0021+  D0A0 73          		 mov	m, e
0022+  D0A1 72          		 mov	m, d
0023+  D0A2 23          		 inx	h
0024+  D0A3 23          		 inx	h
0025+  D0A4 71          		 mov	m, c
0026+  D0A5 70          		 mov	m, b
0027+  D0A6 E1          		pop	h
0028+  D0A7             
0029+  D0A7             		; Ожидание заверения этого звукового сигнала, если Z
0030+  D0A7 C0          		rnz
0031+  D0A8             
0032+  D0A8             waitBeep:	; Ожидание заверения звукового сигнала
0033+  D0A8 F5          		push	psw		
0034+  D0A9 3A E4 FF    waitBeep_0:	 lda	IO_EXT_A
0035+  D0AC E6 01       		 ani	1
0036+  D0AE CA A9 D0    		jz	waitBeep_0
0037+  D0B1 F1          		pop	psw
0038+  D0B2 C9          		ret0229   D0B3             .include "capsLock.inc"
0001+  D0B3             ;+---------------------------------------------------------------------------
0002+  D0B3             ; RAMFOS
0003+  D0B3             ; Нажатие на клавишу CAPS LOCK
0004+  D0B3             ;
0005+  D0B3             ; 2013-11-01 Дизассемблировано vinxru
0006+  D0B3             ;----------------------------------------------------------------------------
0007+  D0B3             
0008+  D0B3 05          capsLock:	dcr	b
0009+  D0B4 F2 BD D0    		jp	capsLock1
0010+  D0B7 7C          		 mov	a, h
0011+  D0B8 2F          		 cma
0012+  D0B9 67          		 mov	h, a
0013+  D0BA C3 46 D0    		jmp	capsLockRet
0014+  D0BD             
0015+  D0BD             ; ---------------------------------------------------------------------------
0016+  D0BD             
0017+  D0BD 3A 2E C6    capsLock1:	lda	v_capsLock
0018+  D0C0 EE 02       		xri	2
0019+  D0C2 32 2E C6    		sta	v_capsLock
0020+  D0C5 C3 49 D0    		jmp	specialKeysRet
0230   D0C8             .include "tapeMode.inc"
0001+  D0C8             ;+---------------------------------------------------------------------------
0002+  D0C8             ; RAMFOS
0003+  D0C8             ; Переключение скорости записи на магнитофон и режима принтера
0004+  D0C8             ; Вызывается при нажатии на соответствующую клавишу
0005+  D0C8             ;
0006+  D0C8             ; 2013-11-01 Дизассемблировано vinxru
0007+  D0C8             ;----------------------------------------------------------------------------
0008+  D0C8             
0009+  D0C8             tapeMode:	; Эта хитрая программа просто обменивает местами
0010+  D0C8             		; v_tapePulseB,A -> v_tapePulseB1,A1 -> v_tapePulseB2,A2
0011+  D0C8 16 04       		mvi	d, 4			; Надо сдвинуть 4 байта
0012+  D0CA 1E 0B       tapeMode_0:	 mvi	e, 11			; Длина всего массива 12 байт
0013+  D0CC 21 6B C6    		 lxi	h, v_tapePresets-1	; Конец массива
0014+  D0CF 3A 60 C6    		 lda	v_tapePulseB		; Загружаем первое значение, которое сразу же поместим в конец
0015+  D0D2 4F          tapeMode_1:	  mov	c, a			; Сдвигаем 11 байт
0016+  D0D3 7E          		  mov	a, m
0017+  D0D4 71          		  mov	m, c
0018+  D0D5 2B          		  dcx	h
0019+  D0D6 1D          		  dcr	e
0020+  D0D7 C2 D2 D0    		 jnz	tapeMode_1
0021+  D0DA 77          		 mov	m, a			; И сохраняем 12 байт. Прошлое значение мы уже поместили в начало массива
0022+  D0DB 15          		 dcr	d			; Повторяем это 4 раза
0023+  D0DC C2 CA D0    		jnz	tapeMode_0
0024+  D0DF             
0025+  D0DF             		; Меняем переменную v_tapeMode '0'->'1'->'2'->'0'
0026+  D0DF 3A 5F C6    		lda	v_tapeMode
0027+  D0E2 3C          		inr	a
0028+  D0E3 FE 33       		cpi	'3'
0029+  D0E5 C2 EA D0    		jnz	tapeMode_2
0030+  D0E8 3E 30       		 mvi	a, '0'
0031+  D0EA 32 5F C6    tapeMode_2:	sta	v_tapeMode
0032+  D0ED             
0033+  D0ED             		; Возвращаемся в функцию опроса клавиатуры
0034+  D0ED C3 49 D0    		jmp	specialKeysRet
0231   D0F0             .include "printerEchoMode.inc"
0001+  D0F0             ;----------------------------------------------------------------------------
0002+  D0F0             ; RAMFOS
0003+  D0F0             ; Включение/выключение эхопечати на принтер
0004+  D0F0             ; Вызывается при нажатии на соответствующую клавишу
0005+  D0F0             ;
0006+  D0F0             ; 2013-11-01 Дизассемблировано vinxru
0007+  D0F0             ;----------------------------------------------------------------------------
0008+  D0F0             
0009+  D0F0~            #if NO_PRINTER==0
0010+  D0F0~            
0011+  D0F0~            printerEchoMode:lxi	h, v_printerEcho
0012+  D0F0~            		mvi	a, 0D2h
0013+  D0F0~            		cmp	m
0014+  D0F0~            		jnz	printerEchoMode_0
0015+  D0F0~            		 xra	a
0016+  D0F0~            printerEchoMode_0:
0017+  D0F0~            		mov	m, a
0018+  D0F0~            		jmp	specialKeysRet
0019+  D0F0             #endif0232   D0F0             .include "printerHex.inc"
0001+  D0F0             ;+---------------------------------------------------------------------------
0002+  D0F0             ; RAMFOS
0003+  D0F0             ; Стандартная точка входа C842
0004+  D0F0             ; Печать 16-ричного числа на принтере
0005+  D0F0             ;
0006+  D0F0             ; На входе
0007+  D0F0             ;  A - число
0008+  D0F0             ;
0009+  D0F0             ; Все регистры сохраняются
0010+  D0F0             ;
0011+  D0F0             ; 2013-11-01 Дизассемблировано vinxru
0012+  D0F0             ;----------------------------------------------------------------------------
0013+  D0F0             
0014+  D0F0~            #if NO_PRINTER==0
0015+  D0F0~            
0016+  D0F0~            printerHex:	push	psw
0017+  D0F0~            		 rrc
0018+  D0F0~            		 rrc
0019+  D0F0~            		 rrc
0020+  D0F0~            		 rrc
0021+  D0F0~            		 call	printerHex_1
0022+  D0F0~            		pop	psw
0023+  D0F0~            printerHex_1:	push	psw
0024+  D0F0~            		 ani	0Fh
0025+  D0F0~            		 cpi	10
0026+  D0F0~            		 jm	printerHex_2
0027+  D0F0~            		  adi	'A'-'0'-10		  
0028+  D0F0~            printerHex_2:	 adi	'0'
0029+  D0F0~            		 push	b
0030+  D0F0~            		  mov	c, a
0031+  D0F0~            		  call	printer
0032+  D0F0~            		 pop	b
0033+  D0F0~            		pop	psw
0034+  D0F0~            		ret
0035+  D0F0~            
0036+  D0F0             #endif0233   D0F0             .include "printerEcho.inc"
0001+  D0F0             ;----------------------------------------------------------------------------
0002+  D0F0             ; RAMFOS
0003+  D0F0             ; Эхопечать на принтере
0004+  D0F0             ;
0005+  D0F0             ; 2013-11-01 Дизассемблировано vinxru
0006+  D0F0             ;----------------------------------------------------------------------------
0007+  D0F0             
0008+  D0F0~            #if NO_PRINTER==0
0009+  D0F0~            
0010+  D0F0~            printerEcho_crLf:
0011+  D0F0~            		; В сумме код ниже заменяет 0A или 0D на пару 0A, 0D. 
0012+  D0F0~            		; Но в случае "0A любые символы 0D", послений не дублируется
0013+  D0F0~            
0014+  D0F0~            		; Вместо 0A, то печатаем пару символов 0A, 0D.
0015+  D0F0~            		lxi	h, v_printerCrLf
0016+  D0F0~            		cpi	0Ah
0017+  D0F0~            		jz	printerEcho_0
0018+  D0F0~            
0019+  D0F0~            		; Вместо 0D, то печатаем пару символов 0A, 0D, только если прошлый перенос был 0D.
0020+  D0F0~            		; Иначе выводим 0D как есть, без второго сивола.
0021+  D0F0~            		cpi	0Dh
0022+  D0F0~            		jnz	printerEcho_spc
0023+  D0F0~            		cmp	m
0024+  D0F0~            
0025+  D0F0~            printerEcho_0:	mvi	c, 0Ah
0026+  D0F0~            		cz	printer
0027+  D0F0~            		mvi	c, 0Dh
0028+  D0F0~            		mov	m, a
0029+  D0F0~            		jmp	printer
0030+  D0F0~            
0031+  D0F0~            ; ---------------------------------------------------------------------------
0032+  D0F0~            
0033+  D0F0~            loc_D0B1:	; Если символ >= 0x87
0034+  D0F0~            		cpi	87h ; 'З'
0035+  D0F0~            		jnc	printerEcho_1
0036+  D0F0~            
0037+  D0F0~            printerEcho_spc:; Заменяем символ на пробел
0038+  D0F0~            		mvi	c, ' '
0039+  D0F0~            
0040+  D0F0~            doPrinterEcho:	; Если это удаление, выходим
0041+  D0F0~            		mov	a, c
0042+  D0F0~            		cpi	8
0043+  D0F0~            		rz
0044+  D0F0~            		; Перевод курсора в начало экрана - выходим
0045+  D0F0~            		cpi	0Ch
0046+  D0F0~            		rz
0047+  D0F0~            		; Если <= 0x18
0048+  D0F0~            		cpi	18h
0049+  D0F0~            		jc	printerEcho_crLf
0050+  D0F0~            		; Если <= 0x1C выходим
0051+  D0F0~            		cpi	1Ch
0052+  D0F0~            		rc
0053+  D0F0~            		; Если очистка экрана - выходим
0054+  D0F0~            		cpi	1Fh
0055+  D0F0~            		rz
0056+  D0F0~            		; Остальные служебные коды заменяем на пробел
0057+  D0F0~            		jc	printerEcho_spc
0058+  D0F0~            		; Если <= 0x60, печатаем
0059+  D0F0~            		cpi	60h
0060+  D0F0~            		jc	printer
0061+  D0F0~            		; ?
0062+  D0F0~            		lhld	v_koi8
0063+  D0F0~            		cpi	7Fh
0064+  D0F0~            		jnc	 loc_D0B1 ;+
0065+  D0F0~            		inr	l
0066+  D0F0~            		jnz	printer
0067+  D0F0~            		ori	80h
0068+  D0F0~            		mov	c, a
0069+  D0F0~            
0070+  D0F0~            printerEcho_1:  ; Если символ меньше 0xC0, выходим
0071+  D0F0~            		cpi	0C0h
0072+  D0F0~            		rc
0073+  D0F0~            
0074+  D0F0~            		; Если v_tapeMode = '0', выводим символ без изменений
0075+  D0F0~            		lda	v_tapeMode
0076+  D0F0~            		sui	'0'
0077+  D0F0~            		jz	printer
0078+  D0F0~            
0079+  D0F0~            		; Если v_tapeMode = '1', выводим с преобразованим
0080+  D0F0~            		dcr	a
0081+  D0F0~            		jnz	printerXlat
0082+  D0F0~            
0083+  D0F0~            		; Иначе перед выводом каждого симовола выводим 27, 82, 1
0084+  D0F0~            		; Из документациии к принтерам Epson
0085+  D0F0~            		; Select International character set France
0086+  D0F0~            		lxi	h, 1B52h
0087+  D0F0~            		mvi	a, 1
0088+  D0F0~            		call	printerEsc
0089+  D0F0~            
0090+  D0F0~            		; Вывод C на принтер
0091+  D0F0~            		call	printer		; Вывод	байта на принтер
0092+  D0F0~            
0093+  D0F0~            		; Выводим 27, 82, 0
0094+  D0F0~            		; Select International character set USA
0095+  D0F0~            		xra	a
0096+  D0F0~            
0097+  D0F0~            printerEsc:	push	b
0098+  D0F0~            		 mov	c, h
0099+  D0F0~            		 call	printer		; Вывод	байта на принтер
0100+  D0F0~            		 mov	c, l
0101+  D0F0~            		 call	printer		; Вывод	байта на принтер
0102+  D0F0~            		 mov	c, a
0103+  D0F0~            		 call	printer		; Вывод	байта на принтер
0104+  D0F0~            		pop	b
0105+  D0F0~            		ret
0106+  D0F0~            
0107+  D0F0             #endif0234   D0F0             .include "printer.inc"
0001+  D0F0             ;----------------------------------------------------------------------------
0002+  D0F0             ; RAMFOS
0003+  D0F0             ; Печать на принтере
0004+  D0F0             ;
0005+  D0F0             ; 2013-11-01 Дизассемблировано vinxru
0006+  D0F0             ;----------------------------------------------------------------------------
0007+  D0F0             
0008+  D0F0~            #if NO_PRINTER==0
0009+  D0F0~            
0010+  D0F0~            printerXlat:	; c = v_printerXlat[c % 64];
0011+  D0F0~            		mov	a, c		
0012+  D0F0~            		ani	63
0013+  D0F0~            		lxi	h, v_printerXlat
0014+  D0F0~            		mov	c, a
0015+  D0F0~            		mvi	b, 0
0016+  D0F0~            		dad	b
0017+  D0F0~            		mov	c, m
0018+  D0F0~            
0019+  D0F0~            printer:	push	psw
0020+  D0F0~            
0021+  D0F0~            		; Режим КР580ВВ55
0022+  D0F0~            		mvi	a, 90h
0023+  D0F0~            		sta	IO_EXT_MODE
0024+  D0F0~            
0025+  D0F0~            		; Инвертируем и записываем данные
0026+  D0F0~            		mov	a, c
0027+  D0F0~            		cma
0028+  D0F0~            		sta	IO_EXT_B
0029+  D0F0~            
0030+  D0F0~            printer_0:	 ; Пользователь может прервать ожидание
0031+  D0F0~            		 lda	IO_KEYB_B		
0032+  D0F0~            		 ani	2
0033+  D0F0~            		 jz	printer_break
0034+  D0F0~            
0035+  D0F0~            		 ; Ждем пока 6-ой бит не нулевой
0036+  D0F0~            		 lda	IO_EXT_A
0037+  D0F0~            		 ani	40h
0038+  D0F0~            		jnz	printer_0
0039+  D0F0~            
0040+  D0F0~            		; Строб
0041+  D0F0~            		mvi	a, 3
0042+  D0F0~            		sta	IO_EXT_C
0043+  D0F0~            
0044+  D0F0~            		; Пауза
0045+  D0F0~            		nop
0046+  D0F0~            		nop
0047+  D0F0~            		nop
0048+  D0F0~            		nop
0049+  D0F0~            		nop
0050+  D0F0~            		nop
0051+  D0F0~            		nop
0052+  D0F0~            
0053+  D0F0~            		; Строб
0054+  D0F0~            		xra	a
0055+  D0F0~            		sta	IO_EXT_C
0056+  D0F0~            
0057+  D0F0~            printer_break:	pop	psw
0058+  D0F0~            		ret
0059+  D0F0~            
0060+  D0F0~            		.db    0
0061+  D0F0             #else
0062+  D0F0             
0063+  D0F0             printer:
0064+  D0F0             printerHex:
0065+  D0F0             printerEchoMode: 
0066+  D0F0             doPrinterEcho:
0067+  D0F0 C9          		ret
0068+  D0F1             #endif0235   D0F1             .include "setColorChar.inc"
0001+  D0F1             ;+---------------------------------------------------------------------------
0002+  D0F1             ; RAMFOS
0003+  D0F1             ; Устанвока цвета фона или символов
0004+  D0F1             ; Вызывается при выводе кодов A0-BFh
0005+  D0F1             ;
0006+  D0F1             ; 2013-11-01 Дизассемблировано vinxru
0007+  D0F1             ;----------------------------------------------------------------------------
0008+  D0F1             
0009+  D0F1             setColorChar:   ; Переходим, если это символы B0-BFh
0010+  D0F1 FE 10       		cpi	10h
0011+  D0F3 D2 05 D1    		jnc	setColorChar_1
0012+  D0F6             
0013+  D0F6             		; Это символы А0-АFh
0014+  D0F6             
0015+  D0F6             		; Младшие 4 бита будут цветом символов (B = A << 4)
0016+  D0F6 E6 0F       		ani	0Fh
0017+  D0F8 07          		rlc
0018+  D0F9 07          		rlc
0019+  D0FA 07          		rlc
0020+  D0FB 07          		rlc
0021+  D0FC 47          		mov	b, a
0022+  D0FD             
0023+  D0FD             		; Оставляем цвет фона (A = v_color & 0xF)
0024+  D0FD 3A 35 D2    		lda	v_color
0025+  D100 E6 0F       		ani	0Fh
0026+  D102             
0027+  D102             		; Устаналвиаем цвет (A | B)
0028+  D102 C3 0D D1    		jmp	setColorChar_2
0029+  D105             
0030+  D105             ; ---------------------------------------------------------------------------
0031+  D105             
0032+  D105             setColorChar_1:	; Младшие 4 бита будут цветом фона (B = A & 0x0F)
0033+  D105 E6 0F       		ani	0Fh
0034+  D107 47          		mov	b, a
0035+  D108             
0036+  D108             		; Оставляем цвет символов (A = v_color & 0xF0)
0037+  D108 3A 35 D2    		lda	v_color
0038+  D10B E6 F0       		ani	0F0h
0039+  D10D             
0040+  D10D             setColorChar_2:	; Устаналвиаем цвет (A | B)
0041+  D10D B0          		ora	b
0042+  D10E C3 15 D1    		jmp	setColor		0236   D111             .include "setColor.inc"
0001+  D111             ;+---------------------------------------------------------------------------
0002+  D111             ; RAMFOS
0003+  D111             ; Инверсия кода цвета
0004+  D111             ; Вызывается при выводе кода 89
0005+  D111             ;
0006+  D111             ; 2013-11-01 Дизассемблировано vinxru
0007+  D111             ;----------------------------------------------------------------------------
0008+  D111             
0009+  D111 3A 35 D2    inverseColor:	lda	v_color
0010+  D114 2F          		cma
0011+  D115             
0012+  D115             ;+---------------------------------------------------------------------------
0013+  D115             ; RAMFOS
0014+  D115             ; Стандартная точка входа C84B
0015+  D115             ; Установка цвета фона и букв
0016+  D115             ;
0017+  D115             ; На входе
0018+  D115             ;  Младшие биты A - цвета фона
0019+  D115             ;  Старшие биты A - цвет букв
0020+  D115             ;
0021+  D115             ; 2013-11-01 Дизассемблировано vinxru
0022+  D115             ;----------------------------------------------------------------------------
0023+  D115             
0024+  D115 32 35 D2    setColor:	sta	v_color
0025+  D118 32 F8 FF    		sta	IO_COLOR
0026+  D11B C9          		ret0237   D11C             .include "popColor.inc"
0001+  D11C             ;----------------------------------------------------------------------------
0002+  D11C             ; RAMFOS
0003+  D11C             ; Восстановние цвета из стека
0004+  D11C             ; Вызывается при выводе кода 87h
0005+  D11C             ;
0006+  D11C             ; 2013-11-01 Дизассемблировано vinxru
0007+  D11C             ;----------------------------------------------------------------------------
0008+  D11C             
0009+  D11C 2A 36 D2    popColor:	lhld	v_pushColor
0010+  D11F 22 35 D2    		shld	v_color
0011+  D122 7D          		mov	a, l
0012+  D123 C3 15 D1    		jmp	setColor0238   D126             .include "bigRom.inc"
0001+  D126             ;----------------------------------------------------------------------------
0002+  D126             ; RAMFOS
0003+  D126             ; Чтение ПЗУ Специалиста MX
0004+  D126             ;
0005+  D126             ; 2013-11-01 Разработано vinxru
0006+  D126             ;----------------------------------------------------------------------------
0007+  D126             
0008+  D126             #if BIG_ROM
0009+  D126 F5          bigRom:		push	psw
0010+  D127             
0011+  D127             		; Если в HL было число < 8000h, то переходим к чтению ПЗУ MX
0012+  D127 7C          		mov	a, h
0013+  D128 EE 80       		xri	80h
0014+  D12A FA 46 D1    		jm	bigRom_0
0015+  D12D             
0016+  D12D             		; Сохраняем HL и вычитаем из него 8000h
0017+  D12D E5          		push	h
0018+  D12E 67          		 mov	h, a		 
0019+  D12F             		 ; Первые три байта с ПЗУ СТД это программа инициаизации
0020+  D12F 23          		 inx	h
0021+  D130 23          		 inx	h
0022+  D131 23          		 inx	h
0023+  D132             		 ; Включаем ПЗУ СТД
0024+  D132 32 FF FF    		 sta	IO_PAGE_STD
0025+  D135 AF          		 xra	a
0026+  D136 32 F8 F7    		 sta	IO_COLOR-800h
0027+  D139             		 ; Чтение байта
0028+  D139 4E          		 mov	c, m
0029+  D13A             		 ; Включение ОЗУ MX и восстановление цвета
0030+  D13A 32 FC F7    		 sta	IO_PAGE_RAM-800h
0031+  D13D 3A 35 D2    		 lda	v_color
0032+  D140 32 F8 FF    		 sta	IO_COLOR
0033+  D143 E1          		pop	h
0034+  D144             		; Восстанавливаем в A значение
0035+  D144 F1          		pop	psw
0036+  D145 C9          		ret
0037+  D146             		
0038+  D146             bigRom_0:	; Включение ПЗУ MX
0039+  D146 32 FE FF    		sta	IO_PAGE_ROM
0040+  D149             		; Чтение байта
0041+  D149 4E          		mov	c, m
0042+  D14A             		; Включение ОЗУ MX
0043+  D14A 32 FC FF    		sta	IO_PAGE_RAM
0044+  D14D             		; Восстанавливаем в A значение
0045+  D14D F1          		pop	psw
0046+  D14E C9          		ret      
0047+  D14F             #endif0239   D14F             #if RELOCATE_FILE_FUNCTIONS
0240   D14F             .include "fileSaveHeader.inc"	; Їа®¤®«¦Ґ­ЁҐ ў pageWriteBlock
0001+  D14F             ;+---------------------------------------------------------------------------
0002+  D14F             ; RAMFOS
0003+  D14F             ; Записать заговлок текущего файла на диск
0004+  D14F             ;
0005+  D14F             ; 2013-11-01 Дизассемблировано vinxru
0006+  D14F             ;----------------------------------------------------------------------------
0007+  D14F             
0008+  D14F             fileSaveHeader:
0009+  D14F             		; Устанавливаем флаг "файл не был сохранен"
0010+  D14F 3E 8B       		mvi	a, 8Bh
0011+  D151 32 61 D2    		sta	v_header_saved
0012+  D154             
0013+  D154             		; Сохранение заголовка на диск
0014+  D154 01 52 D2    		lxi	b, v_header
0015+  D157             		
0016+  D157             ;----------------------------------------------------------------------------
0017+  D157             ; RAMFOS
0018+  D157             ; Записать альтернативный заговлок файла на диск
0019+  D157             ; Используется для записи заговлока v_header2 при создании нового файла
0020+  D157             ;
0021+  D157             ; На входе
0022+  D157             ;  b - заголовок
0023+  D157             ;
0024+  D157             ; 2013-11-01 Дизассемблировано vinxru
0025+  D157             ;----------------------------------------------------------------------------
0026+  D157             
0027+  D157             fileSaveHeaderAny:
0028+  D157 11 1D 00    		lxi	d, FILE_HEADER_SIZE-1
0029+  D15A 2A 70 D2    		lhld	v_curFile
0030+  D15D             
0031+  D15D             		; Продолжение на pageWriteBlock
0032+  D15D             		0241   D15D             .include "pageWriteBlock.inc"
0001+  D15D             ;+---------------------------------------------------------------------------
0002+  D15D             ; RAMFOS
0003+  D15D             ; Запись блока данных в ДОЗУ/ПЗУ
0004+  D15D             ;
0005+  D15D             ; На входе:
0006+  D15D             ;  bc - откуда, адрес в памяти
0007+  D15D             ;  hl - куда, адрес в ДОЗУ/ПЗУ
0008+  D15D             ;  de - длина-1
0009+  D15D             ;
0010+  D15D             ; 2013-11-01 Дизассемблировано vinxru
0011+  D15D             ;----------------------------------------------------------------------------
0012+  D15D             
0013+  D15D             pageWriteBlock:	; Чтение байта
0014+  D15D 0A          		ldax	b
0015+  D15E             		; Запись байта
0016+  D15E C5          		push	b
0017+  D15F 4F          		 mov	c, a
0018+  D160 CD D1 FF    		 call	pageWrite
0019+  D163 C1          		pop	b
0020+  D164             		; Увеличение адресов
0021+  D164 23          		inx	h
0022+  D165 03          		inx	b
0023+  D166             		; if(de == 0) break;
0024+  D166 7B          		mov	a, e
0025+  D167 B2          		ora	d
0026+  D168             		; de--
0027+  D168 1B          		dcx	d
0028+  D169 C2 5D D1    		jnz	pageWriteBlock
0029+  D16C C9          		ret
0242   D16D             #endif
0243   D16D             
0244   D16D             .include "v_printerXlat.inc"
0001+  D16D             ;+---------------------------------------------------------------------------
0002+  D16D             ; RAMFOS
0003+  D16D             ; Таблица преобразования кодировки символов для принтера
0004+  D16D             ;
0005+  D16D             ; 2013-11-01 Дизассемблировано vinxru
0006+  D16D             ;----------------------------------------------------------------------------
0007+  D16D             
0008+  D16D~            #if NO_PRINTER==0
0009+  D16D~            
0010+  D16D~            v_printerXlat:	.db 0EEh, 0D0h, 0D1h, 0E6h, 0D4h, 0D5h, 0E4h, 0D3h 
0011+  D16D~            		.db 0E5h, 0D8h, 0D9h, 0DAh, 0DBh, 0DCh, 0DDh, 0DEh
0012+  D16D~            		.db 0DFh, 0EFh, 0E0h, 0E1h, 0E2h, 0E3h, 0D6h, 0D2h
0013+  D16D~            		.db 0ECh, 0EBh, 0D7h, 0E8h, 0EDh, 0E9h, 0E7h, 0EAh
0014+  D16D~            		.db 0CEh, 0B0h, 0B1h, 0C6h, 0B4h, 0B5h, 0C4h, 0B3h 
0015+  D16D~            		.db 0C5h, 0B8h, 0B9h, 0BAh, 0BBh, 0BCh, 0BDh, 0BEh
0016+  D16D~            		.db 0BFh, 0CFh, 0C0h, 0C1h, 0C2h, 0C3h, 0B6h, 0B2h
0017+  D16D~            		.db 0CCh, 0CBh, 0B7h, 0C8h, 0CDh, 0C9h, 0C7h, 0CAh
0018+  D16D~            
0019+  D16D             #endif0245   D16D             
0246   D16D             ; …б«Ё ­Ґв „Ћ‡“, в® ЁбЇ®«м§гҐвбп нв®в ­ҐЎ®«ми®© ЎгдҐа, зв® Ўл е®вм зв® в®
0247   D16D             ; а Ў®в «®.
0248   D16D             
0249   D16D             #if WORK_WITHOUT_ARAM != 0
0250   D16D             miniPage:
0251   D18E             .org $ + FILE_HEADER_SIZE + WORK_WITHOUT_ARAM + 2	; ‘®еа ­Ґ­ЁҐ д ©«  ў WORK_WITHOUT_ARAM Ў ©в
0252   D18E             miniPageEnd:
0253   D18E 08          .db 8							; ‘о¤  § ЇЁблў Ґвбп Ў ©в вҐа¬Ё­ в®а.
0254   D18F             #endif
0255   D18F             
0256   D18F 4C 41 54 00 a_lat:		.db 04Ch, 041h, 054h, 0 ; "LAT"
0257   D193 F2 F5 F3 00 a_rus:		.db 0F2h, 0F5h,	0F3h, 0	; "ђ“‘"
0258   D197             a_inputFileName:
0259   D197             #if NICE
0260   D197 20 C6 C1 CA 		.db ' ', 0C6h, 0C1h, 0CAh, 0CCh, 3Ah, ' ', C_PUSHCURSORL, 0 ; "д ©«" + § Ї®¬Ё­ ­ЁҐ Єгаб®а  бва®ЄЁ
0260   D19B CC 3A 20 8D 
0260   D19F 00 
0261   D1A0~            #else
0262   D1A0~            		.db 11h, 0C6h, 0C1h, 0CAh, 0CCh, 3Ah, C_PUSHCURSORL, C_BEEP, 0 ; "д ©«" + § Ї®¬Ё­ ­ЁҐ Єгаб®а  бва®ЄЁ
0263   D1A0             #endif
0264   D1A0             
0265   D1A0 0D C4 C1 D4 A_INPUTDATE
0265   D1A4 C1 3A 00 
0266   D1A7 8B 8F 20 F3 A_INITSCREEN
0266   D1AB D0 C5 C3 C9 
0266   D1AF C1 CC C9 D3 
0266   D1B3 D4 20 4D 58 
0266   D1B7 32 20 52 41 
0266   D1BB 4D 46 4F 53 
0266   D1BF 8C 00 
0267   D1C1             
0268   D1C1             ; ===========================================================================
0269   D1C1             ; Џ…ђ…Њ…ЌЌ›…
0270   D1C1             
0271   D1C1~            #if $ > 0D1F0h
0272   D1C1~            ЋиЁЎЄ _з бвм_C800_­Ґ_ў«Ґ§« 
0273   D1C1             #endif
0274   D1F0             .org 0D1F0h
0275   D1F0             
0276   D1F0 00 00       v_tape:		.dw 0
0277   D1F2             
0278   D1F2             ; ‡ Ј®«®ў®Є д ©«  2
0279   D1F2             
0280   D1F2 D3 D3 D3    v_header2:	.db 0D3h, 0D3h, 0D3h		; вгв ¤®«¦­® Ўлвм 0D3h, 0D3h, 0D3h, Ё­ зҐ дг­ЄжЁп § Јаг§ЄЁ д ©«  ­Ґ а Ў® вҐв. ЌЁЄв® ­Ґ Ё­ЁжЁ «Ё§йЁагҐв нвЁ ЇҐаҐ¬Ґ­­лҐ!
0281   D1F5 20 20 20 20 v_header2_name:	.db ' ',' ',' ',' ',' ',' ',' ',' ',' '
0281   D1F9 20 20 20 20 
0281   D1FD 20 
0282   D1FE 20 20 20    v_header2_ext:	.db ' ',' ',' '
0283   D201 8B          v_header2_saved:.db 8Bh			; ЏаЁ§­ Є ­Ґ б®еа ­Ґ­­®бвЁ 8B, 8C
0284   D202 01 11 13    v_header2_date:	.db 01h, 11h, 13h	; „ в 
0285   D205 00 00 00 00 		.db 0, 0, 0, 0, 0	; ђҐ§Ґаў MXDOS
0285   D209 00 
0286   D20A 00 00       v_header2_start:.dw 0
0287   D20C 00 00       v_header2_end:	.dw 0
0288   D20E 00 00       v_header2_crc:	.dw 0
0289   D210             
0290   D210             ; Љ®­Ґж § Ј®«®ўЄ  д ©« 
0291   D210             
0292   D210 00          v_dblClear:	.db 0
0293   D211 00 00 00 00 		.db 0,0,0,0,0,0,0,0,0
0293   D215 00 00 00 00 
0293   D219 00 
0294   D21A 00 00 00 00 unk_D21A:	.db 0,0,0,0,0,0
0294   D21E 00 00 
0295   D220 00 00       v_pushCursorLn:	.dw 0
0296   D222 00 00       v_pushCursor:	.dw 0
0297   D224 00          v_escMode:	.db 0
0298   D225 00          v_key2:		.db 0
0299   D226 00          v_printerCrLf:	.db 0		
0300   D227 00 00       v_memTop:	.dw 0
0301   D229 00 00       v_key0:		.dw 0
0302   D22B 00 00       v_key1:		.dw 0
0303   D22D 00 00       v_oldSP:	.dw 0
0304   D22F 00          		.db 0
0305   D230 00 00       v_topLineHeight:.dw 0
0306   D232 00          v_screenHeight:	.db 0		; ‚лб®в  нЄа ­ 
0307   D233 00          v_screenHeight1:.db 0		; ‚лб®в  нЄа ­  - 10
0308   D234 00          v_bottomLineId:	.db 0
0309   D235 00          v_color:	.db 0		; ’ҐЄгйЁ© жўҐв д®­  Ё ЎгЄў
0310   D236 00 00       v_pushColor:	.dw 0
0311   D238 00 00 00 00 		.db 0,0,0,0
0312   D23C 00 00       v_aramPageEnd2:	.dw 0
0313   D23E 00          v_escRow:	.db 0
0314   D23F 00          		.db 0
0315   D240 00          v_lastKey:	.db 0
0316   D241 00          		.db 0
0317   D242 00          		.db 0
0318   D243 00 00       v_pageStart:	.dw 0		; Ќ з «® вҐЄгйҐ© бва ­Ёжл
0319   D245 00          v_page:		.db 0		; ’ҐЄгй п бва ­Ёж 
0320   D246             
0321   D246 00 00 00 00 		.db 0,0,0,0, 0,0,0,0, 0,0,0,0
0321   D24A 00 00 00 00 
0321   D24E 00 00 00 00 
0322   D252             
0323   D252             ; ‡ Ј®«®ў®Є д ©« 
0324   D252             ; ЏҐаўлҐ 15 Ў ©в (v_header, v_header_name, v_header_ext) зЁв Ґвбп дг­ЄжЁҐ© tapeReadHeader
0325   D252             ; ЏҐаўлҐ 30 Ў ©в зЁв овбп дг­ЄжЁҐ© fileLoadHeader
0326   D252             
0327   D252             
0328   D252 D3 D3 D3    v_header:	.db 0D3h, 0D3h, 0D3h	; €¤Ґ­вЁдЁЄ в®а, ¤®«¦Ґ­ Ўлвм 0D3h, 0D3h, 0D3h
0329   D255 20 20 20 20 v_header_name:	.db ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
0329   D259 20 20 20 20 
0330   D25D 20          v_header_spc:	.db ' '
0331   D25E 20 20 20    v_header_ext:	.db ' ', ' ', ' '
0332   D261 00          v_header_saved:	.db 0
0333   D262 00 00 00    v_header_date:	.db 0, 0, 0
0334   D265 00 00 00 00 v_header_unused:.db 0, 0, 0, 0, 0
0334   D269 00 
0335   D26A 00 00       v_header_start:	.dw 0
0336   D26C 00 00       v_header_stop:	.dw 0
0337   D26E 00 00       v_header_crc:	.dw 0
0338   D270             
0339   D270             ; Љ®­Ґж § Ј®«®ўЄ  д ©« 
0340   D270             
0341   D270 00 00       v_curFile:	.dw 0
0342   D272 00 00       v_printedFile:	.dw 0
0343   D274 00 00       f_nextFile:	.dw 0
0344   D276 00 00       f_fileBodySize:	.dw 0
0345   D278 00 00       f_fileSize:	.dw 0
0346   D27A 00 00       v_pageFreeTotal:.dw 0
0347   D27C 00 00       v_pageFreePtr:	.dw 0
0348   D27E             
0349   D27E F0 77 23 1B 		.db 0F0h, 77h, 23h, 1Bh, 7Ah, 0B3h, 0CAh, 95h, 0D2h, 0Ch, 0C2h, 78h, 0D2h, 22h, 0, 8Fh, 0EBh, 22h, 2, 8Fh, 0C3h, 52h, 0D2h
0349   D282 7A B3 CA 95 
0349   D286 D2 0C C2 78 
0349   D28A D2 22 00 8F 
0349   D28E EB 22 02 8F 
0349   D292 C3 52 D2 
0350   D295             
0351   D295 00 00 00 00 buffer:		.db 0,0,0,0,0,0,0,0,0	; €бЇ®«м§гҐвбп ¬ ЄбЁ¬г¬ 9 бЁ¬ў®«®ў ¤«п ўў®¤  ¤ вл. Џ®б«Ґ¤­Ё© Ў ©в ¤«п Є®­ва®«п ЇҐаҐЇ®«­Ґ­Ёп
0351   D299 00 00 00 00 
0351   D29D 00 
0352   D29E             
0353   D29E             ; ===========================================================================
0354   D29E             ; ЉЋ„
0355   D29E             
0356   F800             .org 0F800h
0357   F800             
0358   F800             .include "f800.inc"
0001+  F800             ;+---------------------------------------------------------------------------
0002+  F800             ; RAMFOS
0003+  F800             ; Точки входа
0004+  F800             ;
0005+  F800             ; 2013-11-01 Дизассемблировано vinxru
0006+  F800             ;----------------------------------------------------------------------------
0007+  F800             
0008+  F800 C3 2A F9    			jmp	init
0009+  F803 C3 03 C8    			jmp	j_keyWait
0010+  F806 C3 06 C8    			jmp	j_tapeRead
0011+  F809 C3 09 C8    			jmp	j_printChar
0012+  F80C C3 0C C8    			jmp	j_tapeWrite
0013+  F80F C3 0F C8    			jmp	j_printCharA
0014+  F812 C3 12 C8    			jmp	j_keyCheck
0015+  F815 C3 15 C8    			jmp	j_printHex
0016+  F818 C3 18 C8    			jmp	j_printString
0017+  F81B C3 1B C8    			jmp	j_keyScan
0018+  F81E C3 1E C8    			jmp	j_getCursorPos
0019+  F821 C3 21 C8    			jmp	j_getCharFromScr
0020+  F824 C3 95 F8    			jmp	dlg_loadFile
0021+  F827 C3 B0 F8    			jmp	fileSaveDlg
0022+  F82A C3 2A C8    			jmp	j_calcCrc
0023+  F82D C3 64 FF    			jmp	fileSetType
0024+  F830 C3 30 C8    			jmp	j_getMemTop
0025+  F833 C3 33 C8    			jmp	j_setMemTop
0026+  F836 C3 C5 FF    j_pageReadAny:		jmp	pageReadAny
0027+  F839 C3 D4 FF    j_pageWriteAny:		jmp	pageWriteAny
0028+  F83C C3 3C C8    			jmp	j_setCursorPos
0029+  F83F C3 A9 F8    			jmp	fileSave
0030+  F842 C3 A0 F8    			jmp	fileSetAddr
0031+  F845 C3 4F FF    			jmp	fileGetName
0032+  F848 C3 59 FF    			jmp	fileSetName
0033+  F84B C3 5A F8    			jmp	fileFind
0034+  F84E C3 36 FB    			jmp	fileLoad
0035+  F851 C3 11 FE    			jmp	fileDelete
0036+  F854             #if NO_ROM_ENTRY
0037+  F854             #if NO_MXDOS
0038+  F854 C3 2A F9    			jmp	init
0039+  F857~            #else
0040+  F857~            			jmp	loadMxDos
0041+  F857             #endif
0042+  F857 C3 4B FA    			jmp	exec
0043+  F85A             #endif0359   F85A             .include "loadMXDOS.inc"
0001+  F85A             ;+---------------------------------------------------------------------------
0002+  F85A             ; RAMFOS
0003+  F85A             ; Загрузка и запуск MXDOS с дискеты
0004+  F85A             ; Вызывается при нажатии на F6 из файловой панели
0005+  F85A             ;
0006+  F85A             ; 2013-11-01 Дизассемблировано vinxru
0007+  F85A             ;----------------------------------------------------------------------------
0008+  F85A             
0009+  F85A~            #if NO_MXDOS==0
0010+  F85A~            
0011+  F85A~            MXDOS_ADDR = 0E400h
0012+  F85A~            
0013+  F85A~            loadMxDos:	mov	b, a
0014+  F85A~            
0015+  F85A~            		; Установка головки и сектора
0016+  F85A~            		mvi	a, 1
0017+  F85A~            		sta	IO_FLOPPY_HEAD
0018+  F85A~            		sta	IO_FLOPPY_SECTOR
0019+  F85A~            
0020+  F85A~            		; Пауза
0021+  F85A~            		mvi	h, 13h
0022+  F85A~            loadMxDos_0:	 dcx	h
0023+  F85A~            		 mov	a, l
0024+  F85A~            		 ora	h
0025+  F85A~            		jnz	loadMxDos_0
0026+  F85A~            
0027+  F85A~            		; Устанавливаем головку
0028+  F85A~            		sta	IO_FLOPPY_HEAD
0029+  F85A~            
0030+  F85A~            		; Адрес загрузки
0031+  F85A~            		lxi	h, MXDOS_ADDR
0032+  F85A~            
0033+  F85A~            		; Чтения сектора
0034+  F85A~            		mvi	a, 90h
0035+  F85A~            		sta	IO_FLOPPY_CMD
0036+  F85A~            
0037+  F85A~            		; Ожидание готовности
0038+  F85A~            loadMxDos_1:	 lda	IO_FLOPPY_CMD
0039+  F85A~            		 ral
0040+  F85A~            		 rc
0041+  F85A~            		 rar
0042+  F85A~            		 rar
0043+  F85A~            		jnc	loadMxDos_1
0044+  F85A~            
0045+  F85A~            		; Получение данных
0046+  F85A~            		mvi	c, 13h 
0047+  F85A~            loadMxDos_2:	  sta	IO_FLOPPY_TRIG
0048+  F85A~            		  lda	IO_FLOPPY_DATA
0049+  F85A~            		  mov	m, a
0050+  F85A~            		  inr	l
0051+  F85A~            		 jnz	loadMxDos_2
0052+  F85A~            		 inr	h
0053+  F85A~            		 dcr	c
0054+  F85A~            		jp	loadMxDos_2
0055+  F85A~            
0056+  F85A~            		; Проверка
0057+  F85A~            		lda	IO_FLOPPY_CMD
0058+  F85A~            		xri	1
0059+  F85A~            		ora	a
0060+  F85A~            		mvi	a, 0D0h
0061+  F85A~            		sta	IO_FLOPPY_CMD
0062+  F85A~            		jnz	dlg_error
0063+  F85A~            
0064+  F85A~            		; Проверка
0065+  F85A~            		dcx	h
0066+  F85A~            		mov	a, m
0067+  F85A~            		dcx	h
0068+  F85A~            		inr	m
0069+  F85A~            		cmp	m
0070+  F85A~            		jnz	dlg_error
0071+  F85A~            
0072+  F85A~            		; Запуск MXDOS
0073+  F85A~            		.db 078h
0074+  F85A~            		call	MXDOS_ADDR
0075+  F85A~            
0076+  F85A~            		; При выходе из MXDOS выбираем ROM-диск
0077+  F85A~            		mvi	b, 80h
0078+  F85A~            		ret
0079+  F85A             #endif0360   F85A             .include "fileFind.inc"
0001+  F85A             ;+---------------------------------------------------------------------------
0002+  F85A             ; RAMFOS
0003+  F85A             ; Стандартная точка входа F84B
0004+  F85A             ; Поиск файла имя которого задано функцией fileSetName (F848)
0005+  F85A             ;
0006+  F85A             ; На входе
0007+  F85A             ;   v_header2_name  - Имя файла для поиска
0008+  F85A             ;
0009+  F85A             ; На выходе
0010+  F85A             ;   v_curFile       - Адрес текущего файла в ДОЗУ
0011+  F85A             ;   v_header        - Заголовок файла
0012+  F85A             ;   f_fileBodySize  - Длина файла без заголовка -1
0013+  F85A             ;   f_fileSize      - Длина файла с заголовком
0014+  F85A             ;   f_nextFile      - Адрес следующего файла в ДОЗУ
0015+  F85A             ;   В ДОЗУ по адресу v_curFile + f_fileSize записывается v_curFile
0016+  F85A             ;
0017+  F85A             ; Изменяет переменные в случае ошибки в ДОЗУ. ДОЗУ не изменяется.
0018+  F85A             ;   v_pageFreePtr   - Указатель на первый свободный байт
0019+  F85A             ;   v_pageFreeTotal - Свободно байт
0020+  F85A             ;
0021+  F85A             ; 2013-11-01 Дизассемблировано vinxru
0022+  F85A             ;----------------------------------------------------------------------------
0023+  F85A             
0024+  F85A             fileFind:	; Начальная страница
0025+  F85A 06 00       		mvi	b, 0
0026+  F85C             fileFindEx:	 ; Ищем файл в странице из регистра B
0027+  F85C CD 78 F8    		 call	fileFind1
0028+  F85F             
0029+  F85F             		 ; ?
0030+  F85F CA CC FB    		 jz	fileLoadHeader2
0031+  F862             
0032+  F862             		 ; Следующая страница (регистр B), если есть
0033+  F862 CD 69 F8    		 call	pageNext
0034+  F865 D2 5C F8    		jnc	fileFindEx
0035+  F868 C9          		ret0361   F869             .include "pageNext.inc"
0001+  F869             ;+---------------------------------------------------------------------------
0002+  F869             ; RAMFOS
0003+  F869             ; Следующая страница
0004+  F869             ;
0005+  F869             ; На входе
0006+  F869             ;  b - страница
0007+  F869             ;
0008+  F869             ; На выходе
0009+  F869             ;  jc - ошибка
0010+  F869             ;  b  - страница
0011+  F869             ;
0012+  F869             ; 2013-11-01 Дизассемблировано vinxru
0013+  F869             ;----------------------------------------------------------------------------
0014+  F869             
0015+  F869             pageNext:	; У ROM-диска (код 0x80) может быть только одна страница
0016+  F869 78          		mov	a, b
0017+  F86A 17          		ral
0018+  F86B D8          		rc
0019+  F86C 1F          		rar
0020+  F86D             
0021+  F86D             		; Отфильтровываем флаги
0022+  F86D~            #if ARAM_MAX_PAGE <= 7
0023+  F86D~            		ani	7
0024+  F86D             #else
0025+  F86D E6 0F       		ani	0Fh
0026+  F86F             #endif
0027+  F86F             		; Максимум страниц
0028+  F86F 4F          		mov	c, a
0029+  F870 0C          		inr	c
0030+  F871 3A 3D C6    		lda	v_aramMaxPage
0031+  F874 B9          		cmp	c
0032+  F875 D8          		rc
0033+  F876             
0034+  F876             		; Увеличиваем страницу
0035+  F876 04          		inr	b
0036+  F877 C9          		ret0362   F878             .include "fileFind1.inc"
0001+  F878             ;----------------------------------------------------------------------------
0002+  F878             ; RAMFOS
0003+  F878             ; Поиск файла в странице имя которого задано функцией F848
0004+  F878             ;
0005+  F878             ; На входе
0006+  F878             ;   v_header2_name  - Имя файла для поиска
0007+  F878             ;   b, v_page       - Номер текущей страницы
0008+  F878             ;
0009+  F878             ; На выходе
0010+  F878             ;   v_curFile       - Адрес текущего файла в ДОЗУ
0011+  F878             ;   v_header        - Заголовок файла
0012+  F878             ;   f_fileBodySize  - Длина файла без заголовка - 1
0013+  F878             ;   f_fileSize      - Длина файла с заголовком
0014+  F878             ;   f_nextFile      - Адрес следующего файла в ДОЗУ
0015+  F878             ;   В ДОЗУ по адресу v_curFile + f_fileSize записывается v_curFile
0016+  F878             ;   v_pageFreePtr   - Указатель на первый свободный байт
0017+  F878             ;   v_pageFreeTotal - Свободно байт
0018+  F878             ;
0019+  F878             ; 2013-11-01 Дизассемблировано vinxru
0020+  F878             ;----------------------------------------------------------------------------
0021+  F878             
0022+  F878             fileFind1:      ; Поиск происходит в два этапа
0023+  F878             		; Сначала мы расчитываем v_pageFreePtr, v_pageFreeTotal
0024+  F878 C5          		push	b
0025+  F879 78          		 mov	a, b
0026+  F87A F6 10       		 ori	10h
0027+  F87C 47          		 mov	b, a
0028+  F87D CD 81 F8    		 call	fileFind1_0
0029+  F880 C1          		pop	b
0030+  F881             
0031+  F881             		; А при втором проходе сравниваем имя файла
0032+  F881             
0033+  F881             fileFind1_0:	; Получаем B - текущая страница, HL - начало страницы
0034+  F881 CD CA FC    		call	fileSetPage
0035+  F884             fileFind2_1:	 ; Загружаем следующий заголовок файла
0036+  F884 CD 7A FB    		 call	fileLoadHeader
0037+  F887             		 ; Нет файлов, выходим с флагом NZ
0038+  F887 C0          		 rnz
0039+  F888             		 ; Во втором проходе (b & 0x10 == 0) сравниваем имя файла
0040+  F888 78          		 mov	a, b
0041+  F889 E6 10       		 ani	10h
0042+  F88B CC 01 FE    		 cz	compareFileName
0043+  F88E             		 ; Если файл найден, выходим с флагом Z
0044+  F88E C8          		 rz
0045+  F88F             		 ; Продолжаем поиск со следующего файла
0046+  F88F 2A 74 D2    		 lhld	f_nextFile
0047+  F892 C3 84 F8    		jmp	fileFind2_1
0363   F895             .include "dialog.inc"		; Їа®¤®«¦Ґ­ЁҐ ў fileSaveHeader
0001+  F895             ;----------------------------------------------------------------------------
0002+  F895             ; RAMFOS
0003+  F895             ; Файловая панель
0004+  F895             ;
0005+  F895             ; 2013-11-01 Дизассемблировано vinxru
0006+  F895             ;----------------------------------------------------------------------------
0007+  F895             
0008+  F895             #if ALL_CHARS
0009+  F895             #define BORDER_BL  27,12
0010+  F895             #define BORDER_BL1 12
0011+  F895             #define BORDER_B   27,13
0012+  F895             #define BORDER_B1  13
0013+  F895             #define BORDER_BR  27,24
0014+  F895             #define BORDER_BR1 24
0015+  F895             #define BORDER_L   27, 8
0016+  F895             #define BORDER_L1  8
0017+  F895             #define BORDER_R   27, 10
0018+  F895             #define BORDER_R1  10
0019+  F895             #define BORDER_H   27, 25
0020+  F895             #define BORDER_H1  25
0021+  F895~            #else
0022+  F895~            BORDER_BL  = 15h
0023+  F895~            BORDER_BL1 = 15h
0024+  F895~            BORDER_B   = 14h
0025+  F895~            BORDER_B1  = 14h
0026+  F895~            BORDER_BR  = 16h
0027+  F895~            BORDER_BR1 = 16h
0028+  F895~            BORDER_L   = 11h
0029+  F895~            BORDER_L1  = 11h
0030+  F895~            BORDER_R   = 6
0031+  F895~            BORDER_R1  = 6
0032+  F895~            BORDER_H   = 6
0033+  F895~            BORDER_H1  = 6
0034+  F895             #endif
0035+  F895             
0036+  F895             dlg_loadFile:	; Активная страница
0037+  F895 3A 45 D2    		lda	v_page
0038+  F898 E6 0F       		ani	0Fh
0039+  F89A             		; Режим выбора файла (6 ой бит)
0040+  F89A F6 40       		ori	40h
0041+  F89C 47          		mov	b, a
0042+  F89D C3 41 F9    		jmp	dlg_main
0043+  F8A0             
0044+  F8A0             ; ---------------------------------------------------------------------------
0045+  F8A0             
0046+  F8A0             .include "fileSetAddr.inc"
0001++ F8A0             ;+---------------------------------------------------------------------------
0002++ F8A0             ; RAMFOS
0003++ F8A0             ; Стандартная точка входа F842
0004++ F8A0             ; Установка адреса загрузки в память текущего файла
0005++ F8A0             ;
0006++ F8A0             ; На входе
0007++ F8A0             ;   v_header2_name - имя файла
0008++ F8A0             ;   hl             - новый адрес
0009++ F8A0             ;
0010++ F8A0             ; 2013-11-01 Дизассемблировано vinxru
0011++ F8A0             ;----------------------------------------------------------------------------
0012++ F8A0             
0013++ F8A0             fileSetAddr:	; Ищем файл
0014++ F8A0 E5          		push	h
0015++ F8A1 CD 5A F8    		 call	fileFind
0016++ F8A4 E1          		pop	h
0017++ F8A5             
0018++ F8A5             		; Файл не найден
0019++ F8A5 C0          		rnz
0020++ F8A6             
0021++ F8A6             		; Устаналиваем адрес загрузки
0022++ F8A6 C3 0A FB    		jmp	fileLoadSetAddr
0047+  F8A9             .include "fileSave.inc"	; Продолжение
0001++ F8A9             ;----------------------------------------------------------------------------
0002++ F8A9             ; RAMFOS
0003++ F8A9             ; Сохранить файл
0004++ F8A9             ;
0005++ F8A9             ; 2013-11-01 Дизассемблировано vinxru
0006++ F8A9             ;----------------------------------------------------------------------------
0007++ F8A9             
0008++ F8A9             fileSave:	; Найти свободную страницу и рассчитать контрольную сумму
0009++ F8A9 CD EB F8    		call	fileFindFree
0010++ F8AC D8          		rc
0011++ F8AD             
0012++ F8AD             		; Общая функция
0013++ F8AD C3 CC F8    		jmp	fileSaveCom		
0014++ F8B0             
0015++ F8B0             ;----------------------------------------------------------------------------
0016++ F8B0             ; RAMFOS
0017++ F8B0             ; Сохранить файл с вводом имени с клавиатуры
0018++ F8B0             ;
0019++ F8B0             ; 2013-11-01 Дизассемблировано vinxru
0020++ F8B0             ; ---------------------------------------------------------------------------
0021++ F8B0             
0022++ F8B0             fileSaveDlg:	; Вывод текста "Сохранить?"
0023++ F8B0 CD D9 FE    		call	printStringEx
0024++ F8B3 8B 90 20 F3 		.db C_INVERSE, C_BOTTOMLINE, ' ', 0F3h, 0CFh, 0C8h, 0D2h, 0C1h, 0CEh, 0C9h, 0D4h, 0D8h, 3Fh, C_NORMAL, 0
0024++ F8B7 CF C8 D2 C1 
0024++ F8BB CE C9 D4 D8 
0024++ F8BF 3F 8C 00 
0025++ F8C2             
0026++ F8C2             		; Ввод имени файла
0027++ F8C2 CD 45 C8    		call	j_inputFileName
0028++ F8C5 C8          		rz
0029++ F8C6             
0030++ F8C6             		; Поиск подходящей страницы
0031++ F8C6 CD EB F8    		call	fileFindFree
0032++ F8C9             
0033++ F8C9             		; В случае ошибки вывести "мал диск" и ждать нажания ESC
0034++ F8C9 DA CA FE    		jc	outOfSpace
0035++ F8CC             
0036++ F8CC             fileSaveCom:	; Запись заголовка файла на диск по адресу v_curFile
0037++ F8CC 01 F2 D1    		lxi	b, v_header2
0038++ F8CF CD 57 D1    		call	fileSaveHeaderAny
0039++ F8D2             
0040++ F8D2             		; BC = начало файла, DE = длина файла - 1
0041++ F8D2 E5          		push	h
0042++ F8D3             		 ; DE = начало файла, HL = длина файла - 1
0043++ F8D3 CD E3 FD    		 call	fileGetStartAndSize
0044++ F8D6 EB          		 xchg
0045++ F8D7 4D          		 mov	c, l
0046++ F8D8 44          		 mov	b, h
0047++ F8D9 E1          		pop	h
0048++ F8DA             
0049++ F8DA             		; Запись тела файла (запись на диск по адресу HL из памяти BC длиной DE+1)
0050++ F8DA CD 5D D1    		call	pageWriteBlock 
0051++ F8DD             
0052++ F8DD             		; Продолжение в fileChanged		0048+  F8DD             .include "fileChanged.inc"
0001++ F8DD             ;+---------------------------------------------------------------------------
0002++ F8DD             ; RAMFOS
0003++ F8DD             ; Вызывается после создания/удаления файла
0004++ F8DD             ;
0005++ F8DD             ; Вход
0006++ F8DD             ;  hl - Первый байт после тела файла. У второй функции соответственно +2.
0007++ F8DD             ;
0008++ F8DD             ; 2013-11-01 Дизассемблировано vinxru
0009++ F8DD             ;----------------------------------------------------------------------------                   
0010++ F8DD             
0011++ F8DD             fileChanged2: 	; Пропускаем два байта, они будут заполнены при просмотре.
0012++ F8DD 23          		inx	h
0013++ F8DE 23          		inx	h
0014++ F8DF             
0015++ F8DF             fileChanged:    ; Обновляем указатель свободного места
0016++ F8DF 22 7C D2    		shld	v_pageFreePtr
0017++ F8E2             
0018++ F8E2             		; Записываем значение 8 по этому адресу, что бы там ни 
0019++ F8E2             		; в коем случае не было D3, D3, D3
0020++ F8E2 0E 08       		mvi	c, 8
0021++ F8E4 CD D1 FF    		call	pageWrite
0022++ F8E7             
0023++ F8E7             		; Звуковой сигнал
0024++ F8E7 0D          		dcr	c
0025++ F8E8 C3 09 C8    		jmp	j_printChar
0049+  F8EB             .include "fileFindFree.inc"
0001++ F8EB             ;+---------------------------------------------------------------------------
0002++ F8EB             ; RAMFOS
0003++ F8EB             ; Расчет контрольной суммы сохраняемого файла, поиск страницы
0004++ F8EB             ; с подходящим cвободным объемом, удаление файла с именем v_header2_name
0005++ F8EB             ;
0006++ F8EB             ; На входе
0007++ F8EB             ;  v_header2_name  - Имя файла для удаления
0008++ F8EB             ;  f_header2_start - Адрес начала файла
0009++ F8EB             ;  f_header2_stop  - Адрес конца файла
0010++ F8EB             ;
0011++ F8EB             ; На выходе
0012++ F8EB             ;  jnc             - Страница найдена
0013++ F8EB             ;  f_header2_crc   - Контрольная сумма
0014++ F8EB             ;  v_page, b       - Страница
0015++ F8EB             ;
0016++ F8EB             ; 2013-11-01 Дизассемблировано vinxru
0017++ F8EB             ;----------------------------------------------------------------------------
0018++ F8EB             
0019++ F8EB             fileFindFree:	; Расчитываем контрольную сумму в v_header2_crc
0020++ F8EB 22 0A D2    		shld	v_header2_start	
0021++ F8EE EB          		xchg
0022++ F8EF 22 0C D2    		shld	v_header2_end		
0023++ F8F2 EB          		xchg
0024++ F8F3 CD 2A C8    		call	j_calcCrc
0025++ F8F6 60          		mov	h, b
0026++ F8F7 69          		mov	l, c
0027++ F8F8 22 0E D2    		shld	v_header2_crc
0028++ F8FB             
0029++ F8FB             		; Поиск по всем страницам и удаление файла
0030++ F8FB 06 20       		mvi	b, 20h
0031++ F8FD CD 5C F8    		call	fileFindEx
0032++ F900             
0033++ F900             		; Поиск файла начиная с нулевой страницы
0034++ F900 06 20       		mvi	b, 20h
0035++ F902             fileFindFree_0:	 ; Определяем свободное место на странице
0036++ F902 CD 78 F8    		 call	fileFind1
0037++ F905             		 
0038++ F905             		 ; de = расчитываем требуемый размер файла, почему то в цикле.
0039++ F905 CD E3 FD    		 call	fileGetStartAndSize
0040++ F908 11 21 00    		 lxi	d, FILE_HEADER_SIZE + 3
0041++ F90B 19          		 dad	d
0042++ F90C EB          		 xchg		
0043++ F90D             
0044++ F90D             		 ; Выходим с флагом NC, если места достаточно
0045++ F90D 2A 7A D2    		 lhld	v_pageFreeTotal
0046++ F910 D4 54 C8    		 cnc	j_cmp_hl_de
0047++ F913 D0          		 rnc		
0048++ F914             
0049++ F914             		 ; Следующая страница
0050++ F914 CD 69 F8    		 call	pageNext
0051++ F917 D2 02 F9    		jnc	fileFindFree_0
0052++ F91A C9          		ret0050+  F91B             
0051+  F91B             ; ---------------------------------------------------------------------------
0052+  F91B             ; УДАЛЕНИЕ ДАТЫ
0053+  F91B             
0054+  F91B             dlg_f2_alt:	; Если режим выбора файла, то выходим
0055+  F91B 78          		mov	a, b
0056+  F91C 17          		ral
0057+  F91D 17          		ral
0058+  F91E D8          		rc
0059+  F91F             
0060+  F91F             		; Вывод сообщения "дату удалить"
0061+  F91F 11 95 FF    		lxi	d, a_deleteDate
0062+  F922 CD 7D F9    		call	dlg_msgYesNo
0063+  F925             
0064+  F925             .include "deleteDate.inc"
0001++ F925             ;+---------------------------------------------------------------------------
0002++ F925             ; RAMFOS
0003++ F925             ; Удаление текущей даты
0004++ F925             ; Последующая перерисовка верхней строки в init приведет в вызову функции 
0005++ F925             ; ввода даты
0006++ F925             ;
0007++ F925             ; 2013-11-01 Дизассемблировано vinxru
0008++ F925             ;----------------------------------------------------------------------------
0009++ F925             
0010++ F925             #if DATE_IN_RAM
0011++ F925             		; Сохраняем признак того, что дата не введена
0012++ F925 3E 8C       		mvi	a, 8Ch 
0013++ F927 32 01 D2    		sta	v_header2_saved
0014++ F92A~            #else
0015++ F92A~            		; Сохраняем признак того, что дата не введена в ДОЗУ
0016++ F92A~            		; На входе A != 8Bh
0017++ F92A~            		lhld	v_aramPageEnd
0018++ F92A~            		inx	h
0019++ F92A~            		call	pageWrite
0020++ F92A             #endif
0021++ F92A             		; Функция продолжается в init0065+  F92A             
0066+  F92A             		; Далее init
0067+  F92A             
0068+  F92A             ; ---------------------------------------------------------------------------
0069+  F92A             
0070+  F92A             .include "init.inc"	; Продолжение в dlg_main
0001++ F92A             ;+---------------------------------------------------------------------------
0002++ F92A             ; RAMFOS
0003++ F92A             ; Стандартная точка входа F800
0004++ F92A             ; Инициализация
0005++ F92A             ;
0006++ F92A             ; 2013-11-01 vinxru
0007++ F92A             ;----------------------------------------------------------------------------
0008++ F92A             
0009++ F92A             init:		; Включение ОЗУ
0010++ F92A 32 FC FF    		sta	IO_PAGE_RAM
0011++ F92D             	
0012++ F92D             		; Инициализация	стека
0013++ F92D 31 FF D2    		lxi	sp, STACK_TOP
0014++ F930             
0015++ F930             		; Инициализация BIOS
0016++ F930 CD 00 C8    		call	j_biosInit
0017++ F933             
0018++ F933             		; Верхушка памяти
0019++ F933 21 FF 8F    		lxi	h, RAM_TOP
0020++ F936 CD 33 C8    		call	j_setMemTop
0021++ F939             
0022++ F939             		; Фильтр
0023++ F939 21 81 FF    		lxi	h, a_12spaces + 9
0024++ F93C CD 64 FF    		call	fileSetType
0025++ F93F             
0026++ F93F             		; Диск
0027++ F93F 06 80       		mvi	b, DLG_START_PAGE
0028++ F941             
0029++ F941             		; Продолжается в dlg_main0071+  F941             
0072+  F941             ; ---------------------------------------------------------------------------
0073+  F941             
0074+  F941             dlg_main:	
0075+  F941             		; Очищаем экран, перерисовываем заголовок и нижнюю строку
0076+  F941 CD EF FC    		call	dlg_pageChanged
0077+  F944             	
0078+  F944             dlg_main_0:
0079+  F944             		; Сохраняем текущий файл и положение курсора
0080+  F944~            #if DLG_CURSOR_AT_TOP
0081+  F944~            		xchg
0082+  F944~            		lhld	v_curFile
0083+  F944~            		push	h
0084+  F944~            		lhld	v_cursorPos
0085+  F944~            		push	h
0086+  F944~            		xchg
0087+  F944             #endif	
0088+  F944             		; Выводим все файлы на экран
0089+  F944 CD 7A FB    dlg_main_1:	 call	fileLoadHeader
0090+  F947 F5          		 push	psw
0091+  F948 CD 19 FC    		  call	dlg_printFile
0092+  F94B F1          		 pop	psw
0093+  F94C 2A 74 D2    		 lhld	f_nextFile
0094+  F94F CA 44 F9    		jz	dlg_main_1
0095+  F952             
0096+  F952             #if NICE
0097+  F952             dlg_z1:
0098+  F952 CD AF CD    		call	getCursorPos
0099+  F955 7C          		mov	a, h
0100+  F956 D6 16       		sui	16h
0101+  F958 D2 67 F9    		jnc	dlg_z0
0102+  F95B             		; 46 пробелов
0103+  F95B 01 20 2E    		lxi	b, (46 << 8) + ' '
0104+  F95E CD B3 FC    		call	printChars	
0105+  F961             		; Правая граница
0106+  F961 CD 76 FC    		call	dlg_rightEdge
0107+  F964 C3 52 F9    		jmp	dlg_z1
0108+  F967             dlg_z0:		
0109+  F967             #endif		
0110+  F967             
0111+  F967             		; Рисуем нижнюю границу
0112+  F967 CD 9C F9    		call	dlg_bottomEdge
0113+  F96A             		; Восстанавливаем положение курсора
0114+  F96A~            #if DLG_CURSOR_AT_TOP
0115+  F96A~            		pop	h
0116+  F96A~            		shld	v_cursorPos
0117+  F96A~            		pop	h
0118+  F96A~            		shld	v_curFile
0119+  F96A             #else
0120+  F96A 2A 72 D2    		lhld    v_printedFile
0121+  F96D             #endif	
0122+  F96D CD FF F9    		call    dlg_reloadItem
0123+  F970             
0124+  F970 CD D9 FE    		call    printStringEx
0125+  F973~            #if NICE==0
0126+  F973~            		.db C_BEEP
0127+  F973             #endif
0128+  F973 8E 93 8C 00 		.db C_POPCURSORL, C_PUSHCURSORS, C_NORMAL, 0
0129+  F977             
0130+  F977 2A 70 D2    		lhld	v_curFile
0131+  F97A C3 44 F9    		jmp	dlg_main_0
0132+  F97D             
0133+  F97D             ; ---------------------------------------------------------------------------
0134+  F97D             
0135+  F97D             dlg_msgYesNo:	; Вывод сообщения
0136+  F97D CD B4 FD    		call	dlg_msg
0137+  F980             
0138+  F980             dlg_yesNo:	; Ввод строки из 4-х сиволов
0139+  F980 21 95 D2    		lxi	h, buffer
0140+  F983 11 FF 04    		lxi	d, 4FFh
0141+  F986 CD 36 C8    		call	j_input
0142+  F989 77          		mov	m, a
0143+  F98A             
0144+  F98A             		; Если нажат ENTER, печатаем символ 0E и выходим
0145+  F98A 3E 0E       		mvi	a, 0Eh
0146+  F98C DA 0F C8    		jc	j_printCharA	; Выход
0147+  F98F             
0148+  F98F             		; Если нажат не ESC, повторяем
0149+  F98F C2 80 F9    		jnz	dlg_yesNo
0150+  F992             
0151+  F992             		; Выкидываем адрес возрата
0152+  F992 E1          		pop	h
0153+  F993             		
0154+  F993             loc_F9D0:	; Стираем то, что нарисовали
0155+  F993 CD 9C F9    		call	dlg_bottomEdge
0156+  F996             
0157+  F996             		; Перезагрузить и перерисовать выбранный файл
0158+  F996 2A 70 D2    		lhld    v_curFile
0159+  F999 C3 FF F9    		jmp     dlg_reloadItem
0160+  F99C             
0161+  F99C             ; ---------------------------------------------------------------------------
0162+  F99C             ; Рисование нижней границы
0163+  F99C             
0164+  F99C             dlg_bottomEdge:
0165+  F99C             		; Темный фон, восстановление курсора экрана, удаление, какой то символ
0166+  F99C CD D9 FE    		call	printStringEx
0167+  F99F 8C 94 08 1B 		.db 8Ch, 94h, 8, BORDER_BL, 0
0167+  F9A3 0C 00 
0168+  F9A5             	
0169+  F9A5             		; 46 символов 0x14
0170+  F9A5 01 0D 2E    		lxi	b, 2E00h | BORDER_B1
0171+  F9A8             
0172+  F9A8 CD B3 FC    		call	printChars
0173+  F9AB             
0174+  F9AB             		; Символ 16, восстановление курсора строки
0175+  F9AB CD D9 FE    		call	printStringEx
0176+  F9AE 1B 18 8E 00 		.db BORDER_BR, 8Eh, 0
0177+  F9B2             
0178+  F9B2 C9          		ret
0179+  F9B3             
0180+  F9B3             ; ---------------------------------------------------------------------------
0181+  F9B3             ; Клавиша вниз.
0182+  F9B3             
0183+  F9B3             dlg_down:	; Если это последний файл, переходим на следующую страницу
0184+  F9B3 CD D9 FD    		call	dlg_isLastLine
0185+  F9B6 D2 CB F9    		jnc	dlg_nextPage
0186+  F9B9             
0187+  F9B9             		; Если это последняя строка на экране, перерисовываем экран
0188+  F9B9             		; так что наша строка оказывается сверху.
0189+  F9B9 3A 1F FC    		lda	v_dlgOffset+1
0190+  F9BC 3D          		dcr	a
0191+  F9BD B9          		cmp	c
0192+  F9BE CA F2 FC    		jz	dlg_drawItems
0193+  F9C1             
0194+  F9C1             		; Помещаем в стек адрес следующего файла
0195+  F9C1 2A 74 D2    		lhld	f_nextFile
0196+  F9C4 E5          		push	h
0197+  F9C5             
0198+  F9C5             		; Стираем курсор
0199+  F9C5 CD F7 FB    		call	printFileHeaderDark
0200+  F9C8             		
0201+  F9C8 C3 F5 F9    		jmp	dlg_upDownInt
0202+  F9CB             		
0203+  F9CB             ; ---------------------------------------------------------------------------
0204+  F9CB             
0205+  F9CB             dlg_nextPage:	; Следующая страница (в регистре b)
0206+  F9CB CD 69 F8    		call	pageNext
0207+  F9CE             
0208+  F9CE             		; Это была последняя страница
0209+  F9CE D8          		rc
0210+  F9CF             
0211+  F9CF             		; Страница была изменена
0212+  F9CF C3 EF FC    		jmp	dlg_pageChanged
0213+  F9D2             
0214+  F9D2             ; ---------------------------------------------------------------------------
0215+  F9D2             
0216+  F9D2             dlg_prevPage:	; Если это нулевая страница, выходим
0217+  F9D2 78          		mov	a, b
0218+  F9D3~            #if ARAM_MAX_PAGE <= 7
0219+  F9D3~            		ani	7
0220+  F9D3             #else
0221+  F9D3 E6 0F       		ani	0Fh	; Старшие биты выполняют спец функции
0222+  F9D5             #endif
0223+  F9D5 CA 02 FA    		jz	dlg_drawItem
0224+  F9D8             
0225+  F9D8             		; Уменьшаем страницу
0226+  F9D8 05          		dcr	b
0227+  F9D9 C3 EF FC    		jmp	dlg_pageChanged
0228+  F9DC             
0229+  F9DC             ; ---------------------------------------------------------------------------
0230+  F9DC             
0231+  F9DC             dlg_up:		; Если это первая строка, то перейти на предыдущую страницу
0232+  F9DC 2A 70 D2    		lhld	v_curFile
0233+  F9DF CD 54 C8    		call	j_cmp_hl_de
0234+  F9E2 CA D2 F9    		jz	dlg_prevPage
0235+  F9E5             
0236+  F9E5             		; Непонятно что в с
0237+  F9E5 79          		mov	a, c
0238+  F9E6 FE 03       		cpi	3
0239+  F9E8 CA EF FC    		jz	dlg_pageChanged
0240+  F9EB             
0241+  F9EB~            #if NO_BACK_LINKS
0242+  F9EB~            		; filePrev2 ожидает значение в стеке
0243+  F9EB~            		push	h
0244+  F9EB~            		; Стираем курсор, так как filePrev2 перезагрузит заголовок
0245+  F9EB~            		call	printFileHeaderDark
0246+  F9EB~            .include	"filePrev2.inc"
0247+  F9EB~            		; Уничтожаем значение в стеке
0248+  F9EB~            		pop	d
0249+  F9EB~            		; Сохраняем адрес файла
0250+  F9EB~            		push	h
0251+  F9EB~            		; Пропускаем стирание курсора
0252+  F9EB~            		jmp	dlg_upDownInt2
0253+  F9EB             #else	
0254+  F9EB             .include	"filePrev.inc"
0001++ F9EB             ;+---------------------------------------------------------------------------
0002++ F9EB             ; RAMFOS
0003++ F9EB             ; Получить адрес предыдущего файла
0004++ F9EB             ;
0005++ F9EB             ; На входе
0006++ F9EB             ;  hl - адрес файла
0007++ F9EB             ;
0008++ F9EB             ; На выходе
0009++ F9EB             ;  bc - адрес предыдущего файла
0010++ F9EB             ;
0011++ F9EB             ; 2013-11-01 Дизассемблировано vinxru
0012++ F9EB             ;----------------------------------------------------------------------------
0013++ F9EB             
0014++ F9EB             		; Последние два байта файла это указатель на начало.
0015++ F9EB 2B          		dcx	h
0016++ F9EC CD C2 FF    		call	pageRead
0017++ F9EF 41          		mov	b, c
0018++ F9F0 2B          		dcx	h
0019++ F9F1 CD C2 FF    		call	pageRead
0255+  F9F4             		; Сохраняем адрес файла
0256+  F9F4 C5          		push	b
0257+  F9F5             #endif
0258+  F9F5             
0259+  F9F5             dlg_upDownInt:	; Стираем курсор
0260+  F9F5 CD F7 FB    		call	printFileHeaderDark
0261+  F9F8             
0262+  F9F8             dlg_upDownInt2:
0263+  F9F8             		; Перемещаем курсор вверх или вниз
0264+  F9F8 3A 40 D2    		lda	v_lastKey
0265+  F9FB CD 0F C8    		call	j_printCharA
0266+  F9FE             
0267+  F9FE             		; Восстаналваем HL
0268+  F9FE E1          		pop	h
0269+  F9FF             
0270+  F9FF             dlg_reloadItem:	; Загрузить заголовок файла
0271+  F9FF CD 7A FB    		call	fileLoadHeader
0272+  FA02             
0273+  FA02             dlg_drawItem:	; Вывести название файла
0274+  FA02 CD F2 FB    		call	printFileHeaderLight
0275+  FA05 4A          		mov	c, d
0276+  FA06             
0277+  FA06             		; Ждем символ с кодом <0x20
0278+  FA06 CD 72 FA    dlg_0:		call	keyWaitNoCursor
0279+  FA09 FE 20       		cpi	20h
0280+  FA0B D2 06 FA    		jnc	dlg_0
0281+  FA0E             
0282+  FA0E 32 40 D2    		sta	v_lastKey
0283+  FA11             
0284+  FA11             		; de - начало диска
0285+  FA11 2A 43 D2    		lhld	v_pageStart
0286+  FA14 EB          		xchg
0287+  FA15             
0288+  FA15 FE 19       		cpi	19h
0289+  FA17 CA DC F9    		jz	dlg_up
0290+  FA1A FE 1A       		cpi	1Ah
0291+  FA1C CA B3 F9    		jz	dlg_down
0292+  FA1F FE 0D       		cpi	0Dh
0293+  FA21 CA 8A FA    		jz	dlg_enter
0294+  FA24 FE 1B       		cpi	1Bh
0295+  FA26 CA 73 FB    		jz	dlg_esc		; ESC
0296+  FA29 B7          		ora	a
0297+  FA2A CA F7 FA    		jz	dlg_f1		; F1
0298+  FA2D 3D          		dcr	a
0299+  FA2E CA F1 FD    		jz	dlg_f2		; F2
0300+  FA31 3D          		dcr	a
0301+  FA32 CA 5C FE    		jz	dlg_f3		; F3
0302+  FA35 3D          		dcr	a
0303+  FA36 CA DF FE    		jz	dlg_f4		; F4
0304+  FA39 3D          		dcr	a
0305+  FA3A CA 30 FF    		jz	dlg_f5		; F5
0306+  FA3D 3D          		dcr	a
0307+  FA3E CA E9 FC    		jz	dlg_f6		; F6
0308+  FA41 3D          		dcr	a
0309+  FA42 C2 02 FA    		jnz	dlg_drawItem
0310+  FA45             		; Продолжение в startDebuger
0311+  FA45             
0312+  FA45             ; ---------------------------------------------------------------------------
0313+  FA45             
0314+  FA45             .include "startEditorDebuger.inc"
0001++ FA45             ;----------------------------------------------------------------------------
0002++ FA45             ; RAMFOS
0003++ FA45             ; Запуск редатора и отладчика
0004++ FA45             ;
0005++ FA45             ; 2013-11-01 Дизассемблировано vinxru
0006++ FA45             ;----------------------------------------------------------------------------
0007++ FA45             
0008++ FA45             #if NO_ROM_ENTRY
0009++ FA45             		; Адрес подпрограммы в ПЗУ
0010++ FA45 21 60 FA    		lxi	h, a_debuger
0011++ FA48             
0012++ FA48             editorDebuger:	; В режиме выбора файла запускать нельзя
0013++ FA48 78          		mov	a, b
0014++ FA49 87          		add	a
0015++ FA4A F8          		rm
0016++ FA4B             
0017++ FA4B             		; Запуск		
0018++ FA4B CD CB FA    exec:		call	exec1
0019++ FA4E C2 E6 C8    		jnz	biosInit
0020++ FA51 C3 B4 FA    		jmp	exec2
0021++ FA54             		
0022++ FA54 45 64 69 74 a_editor:	.db "Editor   EXE"
0022++ FA58 6F 72 20 20 
0022++ FA5C 20 45 58 45 
0023++ FA60 44 65 62 75 a_debuger:	.db "Debuger  EXE"
0023++ FA64 67 65 72 20 
0023++ FA68 20 45 58 45 
0024++ FA6C             
0025++ FA6C             ; ---------------------------------------------------------------------------
0026++ FA6C             
0027++ FA6C             startEditor:	; Адрес подпрограммы в ПЗУ
0028++ FA6C 21 54 FA    		lxi	h, a_editor
0029++ FA6F C3 48 FA    		jmp	editorDebuger
0030++ FA72             
0031++ FA72~            #else ; ---------------------------------------------------------------------
0032++ FA72~            
0033++ FA72~            		; Адрес подпрограммы в ПЗУ
0034++ FA72~            		lxi	h, 3
0035++ FA72~            
0036++ FA72~            editorDebuger:	; if(b & 0x40) return;
0037++ FA72~            		mov	a, b
0038++ FA72~            		ral
0039++ FA72~            		ral
0040++ FA72~            		rc
0041++ FA72~            
0042++ FA72~            		; Помещаем в стек адрес возврата
0043++ FA72~            		xthl
0044++ FA72~            
0045++ FA72~            		; Сохраняем выбранный файл
0046++ FA72~            		call	memcpy_fd_fd2
0047++ FA72~            
0048++ FA72~            		; Адрес загрузки
0049++ FA72~            		lxi	h, 0E800h
0050++ FA72~            
0051++ FA72~            		; Включаем ПЗУ
0052++ FA72~            		sta	IO_PAGE_ROM
0053++ FA72~            		ret
0054++ FA72~            
0055++ FA72~            ; ---------------------------------------------------------------------------
0056++ FA72~            
0057++ FA72~            startEditor:	; Адрес подпрограммы в ПЗУ
0058++ FA72~            		lxi	h, 6
0059++ FA72~            		jmp	editorDebuger
0060++ FA72~            
0061++ FA72             #endif0315+  FA72             .include "keyWaitNoCursor.inc"
0001++ FA72             ;----------------------------------------------------------------------------
0002++ FA72             ; RAMFOS
0003++ FA72             ; Ожидание нажатия клавиши без курсора
0004++ FA72             ;
0005++ FA72             ; 2013-11-01 Дизассемблировано vinxru
0006++ FA72             ;----------------------------------------------------------------------------
0007++ FA72             
0008++ FA72             ; Тут ошибка, курсор всётаки может промелькнуть
0009++ FA72             
0010++ FA72 CD 12 C8    keyWaitNoCursor:call	j_keyCheck
0011++ FA75 C2 03 C8    		jnz	j_keyWait
0012++ FA78 C3 72 FA    		jmp	keyWaitNoCursor0316+  FA7B             .include "memcmp_hl_de_c.inc"
0001++ FA7B 11 5E D2    memcmp_ext:	lxi	d, v_header_ext
0002++ FA7E             
0003++ FA7E 0E 03       memcmp_hl_de_3:	mvi	c, 3
0004++ FA80             
0005++ FA80             memcmp_hl_de_c:	 ; if(*de-- != *hl--) return;
0006++ FA80 1A          		 ldax	d
0007++ FA81 BE          		 cmp	m
0008++ FA82 23          		 inx	h
0009++ FA83 C0          		 rnz
0010++ FA84 13          		 inx	d
0011++ FA85 0D          		 dcr	c
0012++ FA86 C2 80 FA    		jnz	memcmp_hl_de_c
0013++ FA89 C9          		ret
0317+  FA8A             
0318+  FA8A             ; ---------------------------------------------------------------------------
0319+  FA8A             
0320+  FA8A CD D9 FD    dlg_enter:	call	dlg_isLastLine
0321+  FA8D CA 02 FA    		jz	dlg_drawItem
0322+  FA90             
0323+  FA90~            #if OPEN_ANY_FILE==0
0324+  FA90~            		; Сравнить расширение выбранного файла с установленным расширением
0325+  FA90~            		lxi	h, v_header2_ext
0326+  FA90~            		call	memcmp_ext
0327+  FA90             #endif
0328+  FA90             		; Если это режим выбора файла
0329+  FA90 78          		mov	a, b
0330+  FA91 17          		ral
0331+  FA92 17          		ral
0332+  FA93             #if OPEN_ANY_FILE
0333+  FA93 DA E6 FA    		jc	dlg_enter_1
0334+  FA96~            #else
0335+  FA96~            		jc	dlg_enter_0
0336+  FA96             #endif	
0337+  FA96             
0338+  FA96             .include "exec.inc"
0001++ FA96             ;----------------------------------------------------------------------------
0002++ FA96             ; RAMFOS
0003++ FA96             ; Запуск RKS файла
0004++ FA96             ;
0005++ FA96             ; 2013-11-01 Разработано vinxru
0006++ FA96             ;----------------------------------------------------------------------------
0007++ FA96             
0008++ FA96             #if RKS_LOADER
0009++ FA96             		; Это RKS файл
0010++ FA96 21 BC FA    		lxi	h, a_rks
0011++ FA99 CD 7B FA    		call	memcmp_ext
0012++ FA9C C2 D7 FA    		jnz	defExec2
0013++ FA9F             		
0014++ FA9F             		; Загрузить его в память
0015++ FA9F CD 4B FB    		call	fileLoad2
0016++ FAA2 C2 B5 FE    		jnz	dlg_error
0017++ FAA5             
0018++ FAA5             		; Найти файл Monitor2.sys в ПЗУ
0019++ FAA5 E5          		push	h
0020++ FAA6 21 BF FA    		 lxi	h, a_monitor2_sys
0021++ FAA9 CD CB FA    		 call	exec1
0022++ FAAC E1          		pop	h
0023++ FAAD             
0024++ FAAD C2 B5 FE    		jnz	dlg_error
0025++ FAB0             		
0026++ FAB0             		; Что бы не испортить стек
0027++ FAB0 31 FF 8F    		lxi	sp, 8FFFh
0028++ FAB3             
0029++ FAB3             		; Адрес программы
0030++ FAB3 E5          		push	h
0031++ FAB4             
0032++ FAB4             exec2:		; Адрес запуска монитора
0033++ FAB4 2A 6A D2    		lhld	v_header_start
0034++ FAB7 E5          		push	h
0035++ FAB8 EB          		xchg
0036++ FAB9 C3 3C FB                    jmp	fileLoadNoCheck
0037++ FABC             
0038++ FABC 52 4B 53    a_rks:		.db "RKS"
0039++ FABF 4D 6F 6E 69 a_monitor2_sys:	.db "Monitor2 SYS"
0039++ FAC3 74 6F 72 32 
0039++ FAC7 20 53 59 53 
0040++ FACB             		
0041++ FACB CD 59 FF    exec1:		call	fileSetName		
0042++ FACE CD 5A F8    		call	fileFind
0043++ FAD1 06 80       		mvi	b, 80h
0044++ FAD3 C4 5C F8    		cnz	fileFindEx
0045++ FAD6 C9          		ret
0046++ FAD7             
0047++ FAD7             defExec2:
0048++ FAD7             #endif0339+  FAD7             
0340+  FAD7             		; Допускаются только расширения EXE и COM
0341+  FAD7 21 84 FF    		lxi	h, a_exe		; "EXE"
0342+  FADA CD 7B FA    		call	memcmp_ext
0343+  FADD 21 87 FF    		lxi	h, a_com		; "COM"
0344+  FAE0 C4 7B FA    		cnz	memcmp_ext
0345+  FAE3             
0346+  FAE3             		; Недопустимое расширение, переходим в основной цикл
0347+  FAE3 C2 02 FA    dlg_enter_0:	jnz	dlg_drawItem
0348+  FAE6             
0349+  FAE6 2A 6A D2    dlg_enter_1:	lhld	v_header_start
0350+  FAE9 EB          		xchg
0351+  FAEA             
0352+  FAEA             		; Режим выбора
0353+  FAEA DA 13 FB    		jc	dlg_select
0354+  FAED             
0355+  FAED CD 4F FB    		call	fileLoadComEx
0356+  FAF0 C2 B5 FE    		jnz	dlg_error
0357+  FAF3             
0358+  FAF3             		;
0359+  FAF3 E3          		xthl
0360+  FAF4 C3 1A FB    		jmp	loc_FB05
0361+  FAF7             
0362+  FAF7             ; ---------------------------------------------------------------------------
0363+  FAF7             
0364+  FAF7             dlg_f1:		; Выводим сообщение
0365+  FAF7 11 8A FF    		lxi	d, a_copy
0366+  FAFA CD AE FD    		call	dlg_checkMsg
0367+  FAFD C8          		rz
0368+  FAFE             
0369+  FAFE             		; Ввод числа в v_header_start
0370+  FAFE CD 80 F9    		call	dlg_yesNo
0371+  FB01 2A 6A D2    		lhld	v_header_start	; Зачем?
0372+  FB04 FC 39 C8    		cm	j_strToHex	; Преобразовать строку DE в число HL
0373+  FB07 CA B5 FE    		jz	dlg_error
0374+  FB0A             
0375+  FB0A             fileLoadSetAddr:; Установить новый адрес загрузки
0376+  FB0A             		; de = v_header_start = hl; 
0377+  FB0A             		; hl = v_header_stop  = f_fileBodySize + hl;
0378+  FB0A CD 2A FB    		call	fileChangeAddr
0379+  FB0D             
0380+  FB0D             		; Если режим выбора файла, то сохраняем заголовок файла.
0381+  FB0D             		; В заголовке мы только что изменили адрес загрузки
0382+  FB0D 78          		mov	a, b
0383+  FB0E 17          		ral
0384+  FB0F 17          		ral
0385+  FB10 D2 4F D1    		jnc	fileSaveHeader
0386+  FB13             		
0387+  FB13             dlg_select:	; Загрузить файл в память
0388+  FB13 CD 4F FB    		call	fileLoadComEx
0389+  FB16 C2 B5 FE    		jnz	dlg_error
0390+  FB19 E1          		pop	h
0391+  FB1A             
0392+  FB1A C5          loc_FB05:	push	b
0393+  FB1B             		 ; Вывести имя файла
0394+  FB1B CD 06 FC    		 call	printFileHeaderName
0395+  FB1E             		 ; Сохранить информацию о загруженном файле
0396+  FB1E CD BB FB    		 call	memcpy_fd_fd2
0397+  FB21 C1          		pop	b
0398+  FB22             
0399+  FB22             loadDStartDStop:; de=v_header_stop, hl=v_header_start
0400+  FB22 2A 6C D2    		lhld	v_header_stop
0401+  FB25 EB          		xchg
0402+  FB26 2A 6A D2    		lhld	v_header_start
0403+  FB29 C9          		ret
0404+  FB2A             
0405+  FB2A             ; ---------------------------------------------------------------------------
0406+  FB2A             
0407+  FB2A             ; de = v_header_start = hl; v_header_stop = f_fileBodySize+hl;
0408+  FB2A             
0409+  FB2A 22 6A D2    fileChangeAddr: shld	v_header_start
0410+  FB2D EB          		xchg
0411+  FB2E 2A 76 D2    		lhld	f_fileBodySize
0412+  FB31 19          		dad	d
0413+  FB32 22 6C D2    		shld	v_header_stop
0414+  FB35 C9          		ret
0415+  FB36             
0416+  FB36             ; ---------------------------------------------------------------------------
0417+  FB36             
0418+  FB36             .include "fileLoad.inc"
0001++ FB36             fileLoad:	; Подменяем адрес загрузки в заголовке файла
0002++ FB36             		; de = v_header_start = hl; v_header_stop = f_fileBodySize + hl;
0003++ FB36 CD 2A FB    		call	fileChangeAddr
0004++ FB39             
0005++ FB39 C3 5E FB    		jmp	fileLoadCom
0006++ FB3C             
0007++ FB3C             ; ---------------------------------------------------------------------------
0008++ FB3C             
0009++ FB3C             #if RKS_LOADER
0010++ FB3C             fileLoadNoCheck:; bc - длина файла
0011++ FB3C             		; hl - адрес тела файла в ДОЗУ
0012++ FB3C 2A 76 D2    		lhld	f_fileBodySize
0013++ FB3F E5          		push	h
0014++ FB40 2A 70 D2    		 lhld	v_curFile ; указатель на заголовок
0015++ FB43 01 1E 00    		 lxi	b, 30	; длина заголовка
0016++ FB46 09          		 dad	b
0017++ FB47 C1          		pop	b
0018++ FB48             
0019++ FB48             		; Читаем bc байт из ДОЗУ по адресу hl в ОЗУ по адресу de
0020++ FB48 C3 9E FD    		jmp	pageReadBlock ; hl-диск,de-память,bc-длина-1
0021++ FB4B             
0022++ FB4B             ; ---------------------------------------------------------------------------
0023++ FB4B             		
0024++ FB4B 2A 6A D2    fileLoad2:	lhld	v_header_start
0025++ FB4E EB          		xchg
0026++ FB4F             #endif
0027++ FB4F             
0028++ FB4F             ; Должен быть загружен заголовок
0029++ FB4F             ; На выходе должно быть de = v_header_start
0030++ FB4F             
0031++ FB4F             fileLoadComEx:	; Вывод сообщения "Ждите!"
0032++ FB4F CD D9 FE    		call	printStringEx
0033++ FB52 8E 8B 20 D6 		.db 8Eh, 8Bh, 20h, 0D6h, 0C4h, 0C9h, 0D4h, 0C5h, 21h, 20h, 8Eh, 0
0033++ FB56 C4 C9 D4 C5 
0033++ FB5A 21 20 8E 00 
0034++ FB5E             
0035++ FB5E             fileLoadCom:
0036++ FB5E             #if RKS_LOADER
0037++ FB5E CD 3C FB    		call	fileLoadNoCheck
0038++ FB61~            #else
0039++ FB61~            		; bc - длина файла
0040++ FB61~            		; hl - адрес тела файла в ДОЗУ
0041++ FB61~            		lhld	f_fileBodySize
0042++ FB61~            		push	h
0043++ FB61~            		 lhld	v_curFile ; указатель на заголовок
0044++ FB61~            		 lxi	b, 30	; длина заголовка
0045++ FB61~            		 dad	b
0046++ FB61~            		pop	b
0047++ FB61~            
0048++ FB61~            		; Читаем bc байт из ДОЗУ по адресу hl в ОЗУ по адресу de
0049++ FB61~            		call	pageReadBlock ; hl-диск,de-память,bc-длина-1#endif
0050++ FB61             #endif
0051++ FB61             		; Расчитываем контрольную сумму от v_header_start до v_header_stop
0052++ FB61 1B          		dcx	d
0053++ FB62 2A 6A D2    		lhld	v_header_start
0054++ FB65 CD 2A C8    		call	j_calcCrc
0055++ FB68             
0056++ FB68             		; Сравнить bc и v_header_crc
0057++ FB68 C5          		push	b
0058++ FB69 D1          		pop	d		
0059++ FB6A 2A 6E D2    		lhld	v_header_crc
0060++ FB6D CD 54 C8    		call	j_cmp_hl_de
0061++ FB70             
0062++ FB70             		; de=v_header_stop, hl=v_header_start
0063++ FB70 C3 22 FB    		jmp	loadDStartDStop
0419+  FB73             
0420+  FB73             ; ---------------------------------------------------------------------------
0421+  FB73             
0422+  FB73             dlg_esc:	; Если это не режим выбора файла, ничего не делаем
0423+  FB73 78          		mov	a, b
0424+  FB74 17          		ral
0425+  FB75 17          		ral
0426+  FB76 D0          		rnc
0427+  FB77             
0428+  FB77             		; Возвращаемся в программу		
0429+  FB77 E1          		pop	h
0430+  FB78 3F          		cmc
0431+  FB79 C9          		ret
0432+  FB7A             
0433+  FB7A             ; ---------------------------------------------------------------------------
0434+  FB7A             
0435+  FB7A             .include "fileLoadHeader.inc"
0001++ FB7A             ;----------------------------------------------------------------------------
0002++ FB7A             ; RAMFOS
0003++ FB7A             ; Загрузить заголовок файла
0004++ FB7A             ;
0005++ FB7A             ; На входе
0006++ FB7A             ;   v_page          - Номер текущей страницы
0007++ FB7A             ;   hl              - Адрес текущего файла в ДОЗУ
0008++ FB7A             ;
0009++ FB7A             ; На выходе, если файл найден
0010++ FB7A             ;   b               - Текущая страница ДОЗУ
0011++ FB7A             ;   v_curFile       - Адрес текущего файла в ДОЗУ
0012++ FB7A             ;   v_header        - Заголовок файла
0013++ FB7A             ;   f_fileBodySize  - Длина файла без заголовка - 1
0014++ FB7A             ;   f_fileSize      - Длина файла с заголовком
0015++ FB7A             ;   f_nextFile      - Адрес следующего файла в ДОЗУ
0016++ FB7A             ;
0017++ FB7A             ;   Если не включено NO_BACK_LINKS, в ДОЗУ по адресу v_curFile + f_fileSize 
0018++ FB7A             ;   записывается v_curFile
0019++ FB7A             ;
0020++ FB7A             ; На выходе, если файл не найден
0021++ FB7A             ;   v_pageFreePtr, v_curFile - Адрес первого свободного байта
0022++ FB7A             ;   v_pageFreeTotal      - Свободно байт
0023++ FB7A             ;
0024++ FB7A             ; 2013-11-01 Дизассемблировано vinxru
0025++ FB7A             ;----------------------------------------------------------------------------
0026++ FB7A             
0027++ FB7A             fileLoadHeader:	; Сохраняем смещение текущего файла в v_curFile
0028++ FB7A 22 70 D2    		shld	v_curFile
0029++ FB7D             
0030++ FB7D             		; Читаем заголовок файла с диска в v_header
0031++ FB7D 11 52 D2    		lxi	d, v_header
0032++ FB80 D5          		push	d
0033++ FB81 01 1D 00    		 lxi	b, FILE_HEADER_SIZE-1
0034++ FB84 CD 9E FD    		 call	pageReadBlock
0035++ FB87 D1          		pop	d
0036++ FB88             
0037++ FB88             		; Помещаем в В текущую страницу
0038++ FB88 3A 45 D2    		lda	v_page
0039++ FB8B 47          		mov	b, a
0040++ FB8C             
0041++ FB8C             		; В начале файла должно быть D3,D3,D3
0042++ FB8C 21 75 FF    		lxi	h, a_defHeader
0043++ FB8F CD 7E FA    		call	memcmp_hl_de_3	; b не изменяет
0044++ FB92             
0045++ FB92             		; Если маркер найден, то переходим к fileLoadHeader2
0046++ FB92 CA CC FB    		jz	fileLoadHeader2
0047++ FB95             
0048++ FB95             		; Не найден маркер начала файла!
0049++ FB95             
0050++ FB95             		; Восстаналиваем заголовок в памяти
0051++ FB95 21 75 FF    		lxi	h, a_defHeader
0052++ FB98 11 52 D2    		lxi	d, v_header
0053++ FB9B CD C1 FB    		call	memcpy_de_hl_15
0054++ FB9E             
0055++ FB9E             		; Устаналиваем конец страницы
0056++ FB9E 2A 74 D2    		lhld	f_nextFile	
0057++ FBA1 22 7C D2    		shld	v_pageFreePtr
0058++ FBA4 EB          		xchg
0059++ FBA5             
0060++ FBA5             		; Получаем в HL размер страницы
0061++ FBA5 2A 1C C6    		lhld	v_aramPageEnd
0062++ FBA8 3A 59 FD    		lda	a_panelOA
0063++ FBAB FE 4F       		cpi	'O'
0064++ FBAD C2 B3 FB    		jnz	fileLoadHeader_0
0065++ FBB0 21 F0 FF    		 lxi	h, ROM_PAGE_END
0066++ FBB3             fileLoadHeader_0:	
0067++ FBB3                             ; Рассчитываем свободное место на диске
0068++ FBB3 CD EA FD    		call	sub_hl_de
0069++ FBB6 22 7A D2    		shld	v_pageFreeTotal
0070++ FBB9             
0071++ FBB9             		; ?
0072++ FBB9 0D          		dcr	c
0073++ FBBA C9          		ret0436+  FBBB             
0437+  FBBB             ; ---------------------------------------------------------------------------
0438+  FBBB             ; Скопировать имя выбранного файла с v_header2_name
0439+  FBBB             
0440+  FBBB 21 52 D2    memcpy_fd_fd2:	lxi	h, v_header
0441+  FBBE 11 F2 D1    		lxi	d, v_header2
0442+  FBC1 0E 0E       memcpy_de_hl_15:mvi	c, 14
0443+  FBC3             
0444+  FBC3             .include "memcpy_de_hl_c.inc"
0001++ FBC3 7E          memcpy_de_hl_c: mov	a, m
0002++ FBC4 12          		stax	d
0003++ FBC5 23          		inx	h
0004++ FBC6 13          		inx	d
0005++ FBC7 0D          		dcr	c
0006++ FBC8 F2 C3 FB    		jp	memcpy_de_hl_c
0007++ FBCB C9          		ret
0445+  FBCC             .include "fileLoadHeader2.inc"
0001++ FBCC             ;----------------------------------------------------------------------------
0002++ FBCC             ; RAMFOS
0003++ FBCC             ; Расчитать доп переменные загруженного заголовка файла
0004++ FBCC             ;
0005++ FBCC             ; На входе
0006++ FBCC             ;   v_curFile      - Адрес текущего файла в ДОЗУ
0007++ FBCC             ;   f_header       - Заголовок файла
0008++ FBCC             ;
0009++ FBCC             ; На выходе
0010++ FBCC             ;   f_fileBodySize - Длина файла без заголовка - 1
0011++ FBCC             ;   f_fileSize     - Длина файла с заголовком
0012++ FBCC             ;   f_nextFile     - Адрес следующего файла в ДОЗУ
0013++ FBCC             ;
0014++ FBCC             ;   Если не включено NO_BACK_LINKS, в ДОЗУ по адресу v_curFile + f_fileSize 
0015++ FBCC             ;   записывается v_curFile
0016++ FBCC             ;
0017++ FBCC             ; 2013-11-01 Дизассемблировано vinxru
0018++ FBCC             ;----------------------------------------------------------------------------
0019++ FBCC             
0020++ FBCC             fileLoadHeader2:; Длина файла без заголовка
0021++ FBCC             		; f_fileBodySize = v_header_stop - v_header_start
0022++ FBCC CD 22 FB    		call	loadDStartDStop	
0023++ FBCF EB          		xchg
0024++ FBD0 CD EA FD    		call	sub_hl_de
0025++ FBD3 22 76 D2    		shld	f_fileBodySize
0026++ FBD6             
0027++ FBD6             		; Длина файла с заголовом
0028++ FBD6             		; f_fileSize = f_fileBodySize+1
0029++ FBD6 11 1F 00    		lxi	d, FILE_HEADER_SIZE+1
0030++ FBD9 19          		dad	d
0031++ FBDA 22 78 D2    		shld	f_fileSize
0032++ FBDD             
0033++ FBDD             		; Конец файла
0034++ FBDD             		; de = v_curFile + f_fileSize
0035++ FBDD EB          		xchg
0036++ FBDE 2A 70 D2    		lhld	v_curFile
0037++ FBE1 EB          		xchg
0038++ FBE2 19          		dad	d
0039++ FBE3             
0040++ FBE3~            #if NO_BACK_LINKS
0041++ FBE3~            		inx	h
0042++ FBE3~            		inx	h
0043++ FBE3             #else
0044++ FBE3             		; Обновляем в ДОЗУ указатель на наш файл, который находится
0045++ FBE3             		; перед следующим файлом.
0046++ FBE3 4B          		mov	c, e
0047++ FBE4 CD D1 FF    		call	pageWrite
0048++ FBE7 23          		inx	h
0049++ FBE8 4A          		mov	c, d
0050++ FBE9 CD D1 FF    		call	pageWrite
0051++ FBEC 23          		inx	h
0052++ FBED             #endif
0053++ FBED             		; Адрес следующего файла
0054++ FBED             		; f_nextFile =  v_curFile + f_fileSize + 2
0055++ FBED 22 74 D2    		shld	f_nextFile
0056++ FBF0             
0057++ FBF0             		; Возвращаем ноль и Z
0058++ FBF0 AF          		xra	a
0059++ FBF1 C9          		ret0446+  FBF2             
0447+  FBF2             ; ---------------------------------------------------------------------------
0448+  FBF2             
0449+  FBF2             printFileHeaderLight:
0450+  FBF2             		; Если сделать курсор цветным, то цвет будет задевать рамку. 
0451+  FBF2             
0452+  FBF2             		; Инверсия
0453+  FBF2 3E 8B       		mvi	a, C_INVERSE
0454+  FBF4 CD 0F C8    		call	j_printCharA
0455+  FBF7             
0456+  FBF7             printFileHeaderDark:
0457+  FBF7             		; Функция сохранит положение курсора строки, но не восстановит его
0458+  FBF7             		; Выведет на экран имя файла
0459+  FBF7             		; После вывода имени функция установит темный фон
0460+  FBF7 CD FF FB    		call	printFileHeaderName2
0461+  FBFA             
0462+  FBFA             popCursorLine2:	; Восстановить курсор строки
0463+  FBFA 3E 8E       		mvi	a, C_POPCURSORL
0464+  FBFC C3 0F C8    		jmp	j_printCharA
0465+  FBFF             
0466+  FBFF             ; ---------------------------------------------------------------------------
0467+  FBFF             ; Функция сохранит положение курсора строки, но не восстановит его
0468+  FBFF             ; Выведет на экран имя файла
0469+  FBFF             ; После вывода имени функция установит темный фон
0470+  FBFF             
0471+  FBFF             printFileHeaderName2:
0472+  FBFF CD 90 FD    		call	pushCursorLine2
0473+  FC02 CD 1E C8    		call	j_getCursorPos
0474+  FC05 EB          		xchg
0475+  FC06             
0476+  FC06             printFileHeaderName:
0477+  FC06 0E 0C       		mvi	c, 12
0478+  FC08 21 55 D2    		lxi	h, v_header_name
0479+  FC0B             printFileHeaderName_0:
0480+  FC0B 7E          		 mov	a, m
0481+  FC0C 23          		 inx	h
0482+  FC0D CD 0F C8    		 call	j_printCharA
0483+  FC10 0D          		 dcr	c
0484+  FC11 C2 0B FC    		jnz	printFileHeaderName_0
0485+  FC14             
0486+  FC14             		; Установка темного фона
0487+  FC14 3E 8C       		mvi	a, C_NORMAL
0488+  FC16 C3 0F C8    		jmp	j_printCharA
0489+  FC19             
0490+  FC19             ; ---------------------------------------------------------------------------
0491+  FC19             
0492+  FC19 F5          dlg_printFile:	push	psw
0493+  FC1A CD 1E C8    		 call	j_getCursorPos
0494+  FC1D 7C          		 mov	a, h
0495+  FC1E D6 16       v_dlgOffset:	 sui	16h
0496+  FC20 E1          		pop	h
0497+  FC21             
0498+  FC21             		; if(a >= 0x16)	return;
0499+  FC21 D0          		rnc			
0500+  FC22             		
0501+  FC22             		; D272 = v_curFile
0502+  FC22 E5          		push	h
0503+  FC23             #if DLG_CURSOR_AT_TOP==0
0504+  FC23 2A 70 D2    		 lhld	v_curFile
0505+  FC26 22 72 D2    		 shld	v_printedFile
0506+  FC29             #endif		
0507+  FC29 F1          		pop	psw
0508+  FC2A             
0509+  FC2A             		; Если на входе в функцию был NZ
0510+  FC2A C2 A4 FC    		jnz	loc_FC7A
0511+  FC2D             
0512+  FC2D             		; Вывести имя файла
0513+  FC2D CD FF FB    		call	printFileHeaderName2
0514+  FC30             
0515+  FC30             		; Разделитель
0516+  FC30 CD 95 FD    		call	dlg_printSep
0517+  FC33             
0518+  FC33             		; Если файл изменен
0519+  FC33 7E          		mov	a, m
0520+  FC34 CD 0F C8    		call	j_printCharA
0521+  FC37 23          		inx	h
0522+  FC38             
0523+  FC38             		; Дата
0524+  FC38 0E 03       		mvi	c, 3
0525+  FC3A 7E          loc_FC1E:        mov	a, m
0526+  FC3B 23          		 inx	h
0527+  FC3C CD 15 C8    		 call	j_printHex
0528+  FC3F 0D          		 dcr	c
0529+  FC40             #if NICE
0530+  FC40 CA 4B FC    		 jz	loc_FC1E_
0531+  FC43 3E 2D       		 mvi	a, '-'
0532+  FC45 CD 0F C8    		 call	j_printCharA
0533+  FC48 C3 3A FC    		jmp	loc_FC1E
0534+  FC4B             loc_FC1E_:
0535+  FC4B~            #else
0536+  FC4B~            		jnz	loc_FC1E
0537+  FC4B             #endif
0538+  FC4B             		
0539+  FC4B             		; Разделитель
0540+  FC4B CD 95 FD    		call	dlg_printSep
0541+  FC4E             
0542+  FC4E             		; Информация о файле
0543+  FC4E CD 81 FC    		call	dlg_printFileInfo
0544+  FC51             
0545+  FC51             		; Выводим длину
0546+  FC51 2A 76 D2    		lhld	f_fileBodySize
0547+  FC54 23          		inx	h
0548+  FC55             
0549+  FC55             printNumber:			
0550+  FC55             		; Разделитель
0551+  FC55 CD 95 FD    		call	dlg_printSep
0552+  FC58             
0553+  FC58             		; Вывод	HL на экран в 10чном виде
0554+  FC58 11 10 27    		lxi	d, 10000	
0555+  FC5B CD BD FC    		call	divAndPrint
0556+  FC5E 11 E8 03    		lxi	d, 1000
0557+  FC61 CD BD FC    		call	divAndPrint
0558+  FC64 11 64 00    		lxi	d, 100
0559+  FC67 CD BD FC    		call	divAndPrint
0560+  FC6A 11 0A 00    		lxi	d, 10
0561+  FC6D CD BD FC    		call	divAndPrint
0562+  FC70 7D          		mov	a, l
0563+  FC71 C6 30       		adi	'0'
0564+  FC73 CD 0F C8    		call	j_printCharA
0565+  FC76             		
0566+  FC76             		; Правая граница
0567+  FC76             dlg_rightEdge:
0568+  FC76             #if ALL_CHARS
0569+  FC76 0E 0A       		mvi	c, BORDER_R1
0570+  FC78 CD A6 CB    		call	printCharAll
0571+  FC7B~            #else
0572+  FC7B~            		mvi	a, BORDER_R1
0573+  FC7B~            		call	j_printCharA
0574+  FC7B             #endif	
0575+  FC7B             		; Правый край
0576+  FC7B 21 89 FD    		lxi	h, a_rightEdge
0577+  FC7E C3 18 C8    		jmp	j_printString
0578+  FC81             
0579+  FC81             ; ---------------------------------------------------------------------------
0580+  FC81             
0581+  FC81             dlg_printFileInfo:		
0582+  FC81 CD 22 FB    		call	loadDStartDStop	; de=v_header_stop, hl=v_header_start
0583+  FC84             #if NICE
0584+  FC84 0E 2D       		mvi	c, '-'
0585+  FC86~            #else
0586+  FC86~            		mvi	c, ','
0587+  FC86             #endif
0588+  FC86 CD 99 FC    		call	printHexWord	; printHexWord(v_header_start)
0589+  FC89 EB          		xchg
0590+  FC8A             #if NICE
0591+  FC8A 0E 20       		mvi	c, ' '
0592+  FC8C~            #else
0593+  FC8C~            		inr	c		; c = '-'
0594+  FC8C             #endif
0595+  FC8C CD 99 FC    		call	printHexWord	; printHexWord(v_header_stop)
0596+  FC8F             #if NICE
0597+  FC8F 0E 19       		mvi	c, BORDER_H1
0598+  FC91 CD A6 CB    		call	printCharAll
0599+  FC94             #endif
0600+  FC94 2A 6E D2    		lhld	v_header_crc	; c = ?
0601+  FC97 0E 8C       		mvi	c, C_NORMAL
0602+  FC99             		; Продолжение на printHexWord
0603+  FC99             
0604+  FC99             ; ---------------------------------------------------------------------------
0605+  FC99             
0606+  FC99             .include "printHexWord.inc"
0001++ FC99             ;+---------------------------------------------------------------------------
0002++ FC99             ; RAMFOS
0003++ FC99             ; Вывести HL в 16-ричном виде на экран и символ из C
0004++ FC99             ;
0005++ FC99             ; На входе
0006++ FC99             ;  hl - число
0007++ FC99             ;  с  - символ
0008++ FC99             ;
0009++ FC99             ; 2013-11-01 Дизассемблировано vinxru
0010++ FC99             ;----------------------------------------------------------------------------
0011++ FC99             
0012++ FC99 7C          printHexWord:	mov	a, h
0013++ FC9A CD 15 C8    		call	j_printHex
0014++ FC9D 7D          		mov	a, l
0015++ FC9E CD 15 C8    		call	j_printHex
0016++ FCA1 C3 09 C8    		jmp	j_printChar0607+  FCA4             
0608+  FCA4             ; ---------------------------------------------------------------------------
0609+  FCA4             
0610+  FCA4             loc_FC7A:	; Функция сохранит положение курсора строки, но не восстановит его
0611+  FCA4             		; Выведет на экран имя файла
0612+  FCA4             		; После вывода имени функция установит темный фон
0613+  FCA4 CD FF FB    		call	printFileHeaderName2
0614+  FCA7             
0615+  FCA7             #if NICE
0616+  FCA7             		; 27 пробелов
0617+  FCA7 01 20 1B    		lxi	b, 1B20h	; b-колво, с-символ
0618+  FCAA~            #else
0619+  FCAA~            		; 26 пробелов
0620+  FCAA~            		lxi	b, 1A20h	; b-колво, с-символ
0621+  FCAA             #endif
0622+  FCAA CD B3 FC    		call	printChars	
0623+  FCAD             		
0624+  FCAD             		; Свободное место
0625+  FCAD 2A 7A D2    		lhld	v_pageFreeTotal
0626+  FCB0 C3 55 FC    		jmp	printNumber
0627+  FCB3             
0628+  FCB3             ; ---------------------------------------------------------------------------
0629+  FCB3             
0630+  FCB3             .include "printChars.inc"
0001++ FCB3             ;----------------------------------------------------------------------------
0002++ FCB3             ; RAMFOS
0003++ FCB3             ; Вывод на экран нескольких символов
0004++ FCB3             ;
0005++ FCB3             ; На входе:
0006++ FCB3             ;  b - кол-во
0007++ FCB3             ;  с - символ
0008++ FCB3             ;
0009++ FCB3             ; 2013-11-01 Дизассемблировано vinxru
0010++ FCB3             ;----------------------------------------------------------------------------
0011++ FCB3             
0012++ FCB3             #if ALL_CHARS
0013++ FCB3                              
0014++ FCB3 C5          printChars:	 push	b
0015++ FCB4 CD A6 CB    		  call	printCharAll
0016++ FCB7 C1          		 pop	b
0017++ FCB8 05          		 dcr	b
0018++ FCB9 C2 B3 FC    		jnz	printChars
0019++ FCBC C9          		ret
0020++ FCBD             
0021++ FCBD~            #else
0022++ FCBD~            
0023++ FCBD~            printChars:	 call	j_printChar
0024++ FCBD~            		 dcr	b
0025++ FCBD~            		 rz
0026++ FCBD~            		jmp	printChars
0027++ FCBD~            
0028++ FCBD             #endif
0631+  FCBD             
0632+  FCBD             ; ---------------------------------------------------------------------------
0633+  FCBD             
0634+  FCBD 0E 2F       divAndPrint:	mvi	c, '0'-1
0635+  FCBF 0C          loc_FC93:	 inr	c
0636+  FCC0 CD EA FD    		 call	sub_hl_de
0637+  FCC3 D2 BF FC    		jnc	loc_FC93
0638+  FCC6 19          		dad	d
0639+  FCC7 C3 09 C8    		jmp	j_printChar
0640+  FCCA             		
0641+  FCCA             ; ---------------------------------------------------------------------------
0642+  FCCA             
0643+  FCCA             .include "filesetpage.inc"
0001++ FCCA             ;+---------------------------------------------------------------------------
0002++ FCCA             ; RAMFOS
0003++ FCCA             ; Установить активную страницу
0004++ FCCA             ;
0005++ FCCA             ; На входе
0006++ FCCA             ;  b - диск
0007++ FCCA             ;
0008++ FCCA             ; На выходе
0009++ FCCA             ;  v_pageStart = v_curFile = f_nextFile = начало страницы, заголовок первого файла
0010++ FCCA             ;  hl - начало страницы
0011++ FCCA             ;
0012++ FCCA             ; 2013-11-01 Дизассемблировано vinxru
0013++ FCCA             ;----------------------------------------------------------------------------
0014++ FCCA             
0015++ FCCA             fileSetPage:	; Начало RAM-диска
0016++ FCCA 2A 1E C6    		lhld	v_aramPageStart
0017++ FCCD             
0018++ FCCD             		; Диск
0019++ FCCD 78          		mov	a, b
0020++ FCCE 32 45 D2    		sta	v_page
0021++ FCD1             
0022++ FCD1             		; У ROM-диска другое начало
0023++ FCD1             		; Обновляем надпись RAM/ROM в заголовке файловой панели
0024++ FCD1 B7          		ora	a
0025++ FCD2 3E 41       		mvi	a, 'A'
0026++ FCD4 F2 DC FC    		jp	fileSetPage_1
0027++ FCD7 3E 4F       		 mvi	a, 'O'
0028++ FCD9             		 ; Начало ROM-диска
0029++ FCD9 21 80 18    		 lxi	h, ROM_PAGE_START
0030++ FCDC 32 59 FD    fileSetPage_1:	sta	a_panelOA
0031++ FCDF             
0032++ FCDF                             ; Параметры диска
0033++ FCDF 22 43 D2    		shld	v_pageStart
0034++ FCE2 22 70 D2    		shld	v_curFile
0035++ FCE5 22 74 D2    		shld	f_nextFile
0036++ FCE8 C9          		ret		0644+  FCE9             
0645+  FCE9             ; ---------------------------------------------------------------------------
0646+  FCE9             
0647+  FCE9             dlg_f6:		
0648+  FCE9~            #if NO_MXDOS==0
0649+  FCE9~            		; Если в номере диска 7, 6 биты не установлены, запускаем MXDOS
0650+  FCE9~            		mov	a, b
0651+  FCE9~            		ani	0C0h
0652+  FCE9~            		cz	loadMxDos
0653+  FCE9             #endif
0654+  FCE9             		; Запустить не удалось, меняем на противоположный 7 бит
0655+  FCE9 78          		mov	a, b
0656+  FCEA             #if NO_ROM_SWITCH_BUG
0657+  FCEA E6 F0       		ani	0F0h
0658+  FCEC             #endif
0659+  FCEC EE 80       		xri	80h
0660+  FCEE 47          		mov	b, a
0661+  FCEF             
0662+  FCEF             dlg_pageChanged:; Устаналиваем активную страницу
0663+  FCEF CD CA FC    		call	fileSetPage
0664+  FCF2             
0665+  FCF2             dlg_drawItems:				; CODE XREF: dlg_down+Bj
0666+  FCF2 E5          		push	h
0667+  FCF3             		 ; Копируем в заголовок установленный фильтр
0668+  FCF3 21 FE D1    		 lxi	h, v_header2_ext
0669+  FCF6 11 5E FD    		 lxi	d, a_panelFilter
0670+  FCF9 0E 02       		 mvi	c, 2
0671+  FCFB CD C3 FB    		 call	memcpy_de_hl_c	; memcpy(de, hl, c+1)
0672+  FCFE             
0673+  FCFE             		 ; Копируем туда же активную страницу
0674+  FCFE 78          		 mov	a, b
0675+  FCFF~            #if ARAM_MAX_PAGE <= 7
0676+  FCFF~            		 ani	7
0677+  FCFF             #else
0678+  FCFF E6 0F       		 ani	0Fh	; Старшие биты выполняют спец функции
0679+  FD01 FE 09       		 cpi	9
0680+  FD03 DA 08 FD    		 jc	correct
0681+  FD06 C6 07       		  adi	'A'-9-'1'
0682+  FD08             correct:
0683+  FD08             #endif
0684+  FD08 C6 31       		 adi	'1'
0685+  FD0A             #if NICE
0686+  FD0A 32 5C FD    		 sta	p_pageNum
0687+  FD0D~            #else
0688+  FD0D~            		 inx	d
0689+  FD0D~            		 stax	d
0690+  FD0D             #endif
0691+  FD0D E1          		pop	h
0692+  FD0E             
0693+  FD0E             dlg_redraw:
0694+  FD0E             	        ; Выводим панель
0695+  FD0E CD D9 FE    		call	printStringEx
0696+  FD11             
0697+  FD11 8B 90       		.db C_INVERSE, C_BOTTOMLINE
0698+  FD13 20 46 31 2D 		.text " F1-COPY F2-DELETE F3-MLOAD F4-MSAVE F5-EDIT F6-DOS F7-DEBUG"
0698+  FD17 43 4F 50 59 
0698+  FD1B 20 46 32 2D 
0698+  FD1F 44 45 4C 45 
0698+  FD23 54 45 20 46 
0698+  FD27 33 2D 4D 4C 
0698+  FD2B 4F 41 44 20 
0698+  FD2F 46 34 2D 4D 
0698+  FD33 53 41 56 45 
0698+  FD37 20 46 35 2D 
0698+  FD3B 45 44 49 54 
0698+  FD3F 20 46 36 2D 
0698+  FD43 44 4F 53 20 
0698+  FD47 46 37 2D 44 
0698+  FD4B 45 42 55 47 
0699+  FD4F 8C          		.db C_NORMAL
0700+  FD50             #if NICE
0701+  FD50 B0          		.db 0B0h				; Контрастно
0702+  FD51~            #else
0703+  FD51~            		.db C_CLEARSCREEN			; очистка экрана
0704+  FD51             #endif
0705+  FD51             #if NICE
0706+  FD51 1B 59 22 28 		.db 1Bh, 'Y', 20h+2, 20h+8		; положение панели
0707+  FD55~            #else
0708+  FD55~            		.db 1Bh, 'Y', 20h+2, 20h+7		; положение панели
0709+  FD55             #endif
0710+  FD55 17 93 8B    		.db 17h, 93h, 8Bh
0711+  FD58 52          		.db 'R'
0712+  FD59 41 4D       a_panelOA:	.db "AM"
0713+  FD5B             #if NICE
0714+  FD5B 5C          		.db '\'
0715+  FD5C 30 20       p_pageNum	.text "0 "
0716+  FD5E 20 20 20 20 a_panelFilter:	.text "          "
0716+  FD62 20 20 20 20 
0716+  FD66 20 20 
0717+  FD68~            #else
0718+  FD68~            		.text "_V6.0"
0719+  FD68~            		.db 92
0720+  FD68~            a_panelFilter:	.db 92,92,92
0721+  FD68~            		.db '\'
0722+  FD68~            p_pageNum	.db "0  "
0723+  FD68             #endif
0724+  FD68 C4 C1 D4 C1 		.db 0C4h, 0C1h,	0D4h, 0C1h ; дата
0725+  FD6C 20 20 20 20 		.db  ' ', ' ', ' ', ' '
0726+  FD70 C1 C4 CE    		.db 0C1h, 0C4h, 0CEh ; "адн"
0727+  FD73 20          		.db ' '
0728+  FD74             #if NICE
0729+  FD74 20          		.db ' '
0730+  FD75 C1 C4 CB    		.db 0C1h, 0C4h, 0CBh ; "адк"
0731+  FD78 20 20 20    		.db ' ', ' ', ' '
0732+  FD7B D3 D5 CD CD 		.db 0D3h, 0D5h, 0CDh, 0CDh, 0C1h ; "сумма"
0732+  FD7F C1 
0733+  FD80 20          		.db ' '
0734+  FD81~            #else
0735+  FD81~            		.db 2Ch
0736+  FD81~            		.db 0C1h, 0C4h, 0CBh ; "адк"
0737+  FD81~            		.db ' '
0738+  FD81~            		.db 2Dh
0739+  FD81~            		.db 0D3h, 0D5h, 0CDh, 0CDh, 0C1h ; "сумма"
0740+  FD81~            		.db ' '
0741+  FD81~            		.db ' '
0742+  FD81             #endif
0743+  FD81 C4 CC C9 CE 		.db 0C4h, 0CCh, 0C9h, 0CEh, 0C1h ; "длина"
0743+  FD85 C1 
0744+  FD86 20          		.db ' '
0745+  FD87 8C          		.db 8Ch ; темный фон
0746+  FD88             #if NICE
0747+  FD88 B8          		.db 0B8h				; Серый фон
0748+  FD89             #endif
0749+  FD89 94 1A 08 1B a_rightEdge:	.db 94h, 1Ah, 8, BORDER_L, 93h, 0 ; восстановление курсора экрана, вниз, влево, |, запоминание курсора экрана
0749+  FD8D 08 93 00 
0750+  FD90~            #if NO_MXDOS==0
0751+  FD90~            		sta	IO_FLOPPY_HEAD
0752+  FD90             #endif	
0753+  FD90             pushCursorLine2:; Сохранить курсор строки
0754+  FD90 3E 8D       		mvi	a, 8Dh
0755+  FD92 C3 0F C8    		jmp	j_printCharA
0756+  FD95             
0757+  FD95             ; ---------------------------------------------------------------------------
0758+  FD95             
0759+  FD95 CD D9 FE    dlg_printSep:	call	printStringEx
0760+  FD98 8C 20 1B 19 		.db C_NORMAL, ' ', BORDER_H, 
0761+  FD9C~            #if NICE==0
0762+  FD9C~            		.db ' '
0763+  FD9C             #endif
0764+  FD9C 00          		.db 0
0765+  FD9D C9          		ret
0766+  FD9E             
0767+  FD9E             ; ---------------------------------------------------------------------------
0768+  FD9E             
0769+  FD9E             .include "pageReadBlock.inc"
0001++ FD9E             ;+---------------------------------------------------------------------------
0002++ FD9E             ; RAMFOS
0003++ FD9E             ; Чтение блока данных из ДОЗУ/ПЗУ
0004++ FD9E             ;
0005++ FD9E             ; На входе:
0006++ FD9E             ;  hl - откуда, адрес в ДОЗУ/ПЗУ
0007++ FD9E             ;  de - куда, адрес в памяти
0008++ FD9E             ;  bc - длина-1
0009++ FD9E             ;
0010++ FD9E             ; 2013-11-01 Дизассемблировано vinxru
0011++ FD9E             ;----------------------------------------------------------------------------
0012++ FD9E             
0013++ FD9E             pageReadBlock:  ; Прочитать байт 
0014++ FD9E C5          		push	b		  
0015++ FD9F CD C2 FF    		 call	pageRead
0016++ FDA2 23          		 inx	h
0017++ FDA3 79          		 mov	a, c
0018++ FDA4 C1          		pop	b
0019++ FDA5             		; Сохранить байт
0020++ FDA5 12          		stax	d
0021++ FDA6 13          		inx	d
0022++ FDA7             		; if(bc == 0) break;
0023++ FDA7 79          		mov	a, c
0024++ FDA8 B0          		ora	b
0025++ FDA9             		; bc--
0026++ FDA9 0B          		dcx	b
0027++ FDAA C2 9E FD    		jnz	pageReadBlock
0028++ FDAD C9          		ret
0770+  FDAE             
0771+  FDAE             ; ---------------------------------------------------------------------------
0772+  FDAE             
0773+  FDAE             dlg_checkMsg:	; Выйти с флагом Z, если выбрана последняя строка
0774+  FDAE D5          		push	d                
0775+  FDAF CD D9 FD    		call	dlg_isLastLine
0776+  FDB2 D1          		pop	d
0777+  FDB3 C8          		rz
0778+  FDB4             
0779+  FDB4             dlg_msg:	; Вывод сообщения
0780+  FDB4 F5          		push	psw
0781+  FDB5 CD D9 FE    		 call	printStringEx
0782+  FDB8 94 08 8B 20 		 .db C_POPCURSORS, C_LEFT, C_INVERSE, ' ', ' ', ' ', 0C6h, 0C1h, 0CAh, 0CCh ; файл тип
0782+  FDBC 20 20 C6 C1 
0782+  FDC0 CA CC 
0783+  FDC2 20 20 2E D4 		 .db ' ', ' ', 2Eh, 0D4h, 0C9h, 0D0h, ' ', 0Eh, ' ', 0
0783+  FDC6 C9 D0 20 0E 
0783+  FDCA 20 00 
0784+  FDCC             		 
0785+  FDCC EB          		 xchg
0786+  FDCD CD 18 C8    		 call	j_printString
0787+  FDD0             
0788+  FDD0 CD D9 FE    		 call	printStringEx
0789+  FDD3 3A 3F       aa:		 .text ":?"
0790+  FDD5 08 00       		 .db C_LEFT, 0
0791+  FDD7 F1          		pop	psw
0792+  FDD8 C9          		ret
0793+  FDD9             
0794+  FDD9             ; ---------------------------------------------------------------------------
0795+  FDD9             
0796+  FDD9 2A 7C D2    dlg_isLastLine:	lhld	v_pageFreePtr
0797+  FDDC EB          		xchg
0798+  FDDD 2A 70 D2    		lhld	v_curFile
0799+  FDE0 C3 54 C8    		jmp	j_cmp_hl_de
0800+  FDE3             
0801+  FDE3             ; ---------------------------------------------------------------------------
0802+  FDE3             
0803+  FDE3             .include "fileGetStartAndSize.inc"	; fileGetStartAndSize продолжается на sub_hl_de
0001++ FDE3             ;----------------------------------------------------------------------------
0002++ FDE3             ; RAMFOS
0003++ FDE3             ;
0004++ FDE3             ; 2013-11-01 vinxru
0005++ FDE3             ;----------------------------------------------------------------------------                   
0006++ FDE3             
0007++ FDE3             ; DE = v_header2_start
0008++ FDE3             ; HL = v_header2_size-1
0009++ FDE3             
0010++ FDE3             fileGetStartAndSize:
0011++ FDE3 2A 0A D2    		lhld	v_header2_start
0012++ FDE6 EB          		xchg
0013++ FDE7 2A 0C D2    		lhld	v_header2_end
0014++ FDEA             
0015++ FDEA             		; Продолжение на sub_hl_de
0804+  FDEA             .include "sub_hl_de.inc"
0001++ FDEA             ;+---------------------------------------------------------------------------
0002++ FDEA             ; RAMFOS
0003++ FDEA             ; Вычитание из HL DE
0004++ FDEA             ;
0005++ FDEA             ; 2013-11-01 Дизассемблировано vinxru
0006++ FDEA             ;----------------------------------------------------------------------------
0007++ FDEA             
0008++ FDEA 7D          sub_hl_de:	mov	a, l
0009++ FDEB 93          		sub	e
0010++ FDEC 6F          		mov	l, a
0011++ FDED 7C          		mov	a, h
0012++ FDEE 9A          		sbb	d
0013++ FDEF 67          		mov	h, a
0014++ FDF0 C9          		ret
0805+  FDF1             
0806+  FDF1             ; ---------------------------------------------------------------------------
0807+  FDF1             
0808+  FDF1             dlg_f2:		; Вывод текста "удалить"
0809+  FDF1 11 9A FF    		lxi	d, a_delete
0810+  FDF4 CD AE FD    		call	dlg_checkMsg
0811+  FDF7 CA 1B F9    		jz	dlg_f2_alt
0812+  FDFA             
0813+  FDFA             		; Пользователь должен нажать Enter
0814+  FDFA CD 80 F9    		call	dlg_yesNo
0815+  FDFD             
0816+  FDFD             		; Удалить файл
0817+  FDFD CD 11 FE    		call	fileDelete
0818+  FE00             
0819+  FE00             		; Темный фон, восстановить курсор строки, курсор вверх, скролл вверх
0820+  FE00~            #if NICE==0
0821+  FE00~            		call	printStringEx
0822+  FE00~            		.db C_NORMAL, C_POPCURSORL, 19h, C_SCROLLUPEX, 0
0823+  FE00             #endif
0824+  FE00             		; Перерисовать экран
0825+  FE00 C9          		ret
0826+  FE01             
0827+  FE01             ; ---------------------------------------------------------------------------
0828+  FE01             
0829+  FE01             .include "compareFileName.inc"
0001++ FE01             ;+---------------------------------------------------------------------------
0002++ FE01             ; RAMFOS
0003++ FE01             ; Сравнить имя текущего файла с именем заданным пользователем. 
0004++ FE01             ; И опционально, если совпало, то удалить файл.
0005++ FE01             ;
0006++ FE01             ; На входе
0007++ FE01             ;  v_header  - Файл 1, который будет удален, если b & 20h
0008++ FE01             ;  v_header2 - Файл 2
0009++ FE01             ;
0010++ FE01             ; На выходе
0011++ FE01             ;  jz        - файл найден. Но если b & 20h, то флаги неопределены.
0012++ FE01             ;
0013++ FE01             ; 2013-11-01 Дизассемблировано vinxru
0014++ FE01             ;----------------------------------------------------------------------------
0015++ FE01             
0016++ FE01             compareFileName:; Сравнить идентификаторы и имена файлов 
0017++ FE01 21 F2 D1    		lxi	h, v_header2
0018++ FE04 11 52 D2    		lxi	d, v_header
0019++ FE07 0E 0F       		mvi	c, 15
0020++ FE09 CD 80 FA    		call	memcmp_hl_de_c
0021++ FE0C C0          		rnz
0022++ FE0D             
0023++ FE0D             		; Если (b & 20h)==0 выходим (не удаляем)
0024++ FE0D 78          		mov	a, b
0025++ FE0E E6 20       		ani	20h
0026++ FE10 C8          		rz
0027++ FE11             
0028++ FE11             		; Переходим к функции fileDelete0830+  FE11             
0831+  FE11             
0832+  FE11             ; ---------------------------------------------------------------------------
0833+  FE11             
0834+  FE11             .include "fileDelete.inc"
0001++ FE11             ;+---------------------------------------------------------------------------
0002++ FE11             ; RAMFOS
0003++ FE11             ; Стандартная точка входа F851
0004++ FE11             ; Удаление файла найденного программой F84B
0005++ FE11             ;
0006++ FE11             ; Файл должен быть обязательно найден функцией fileFind (F84B), иначе
0007++ FE11             ; будет повреждена структура файлов.
0008++ FE11             ;
0009++ FE11             ; 2013-11-01 Дизассемблировано vinxru
0010++ FE11             ;----------------------------------------------------------------------------
0011++ FE11             
0012++ FE11             fileDelete:	; Расчет длины полезных данных после нашего файла, которые
0013++ FE11             		; надо сдвинуть.
0014++ FE11             		; de = v_pageFreePtr - f_nextFile - 1 
0015++ FE11 2A 74 D2    		lhld	f_nextFile
0016++ FE14 EB          		xchg
0017++ FE15 2A 7C D2    		lhld	v_pageFreePtr
0018++ FE18 2B          		dcx	h		
0019++ FE19 CD EA FD    		call	sub_hl_de
0020++ FE1C EB          		xchg
0021++ FE1D             
0022++ FE1D             		; Помещаем в стек адрес следующего файла
0023++ FE1D E5          		push	h
0024++ FE1E             
0025++ FE1E             		; Помещаем в HL адрес нашего файла
0026++ FE1E 2A 70 D2    		lhld	v_curFile
0027++ FE21             
0028++ FE21             		; Адрес следующего файла изменится после сдвига,
0029++ FE21             		; а он используется в функции compareFileName
0030++ FE21 22 74 D2    		shld	f_nextFile
0031++ FE24             
0032++ FE24             		; Если наш файл был посленим, ничего не перемещаем
0033++ FE24 DA 37 FE    		jc	fileDelete_1
0034++ FE27             
0035++ FE27             fileDelete_0:	 ; Чтение с диска
0036++ FE27 E3          		 xthl
0037++ FE28 CD C2 FF    		 call	pageRead
0038++ FE2B 23          		 inx	h
0039++ FE2C E3          		 xthl
0040++ FE2D             		 ; Запись на диск
0041++ FE2D CD D1 FF    		 call	pageWrite
0042++ FE30 23          		 inx	h
0043++ FE31             		 ; if(de==0) break;
0044++ FE31 7B          		 mov	a, e
0045++ FE32 B2          		 ora	d
0046++ FE33             		 ; de--
0047++ FE33 1B          		 dcx	d
0048++ FE34 C2 27 FE    		jnz	fileDelete_0
0049++ FE37             
0050++ FE37             fileDelete_1:	; Обновляем счетчик свободного места
0051++ FE37 E3          		xthl
0052++ FE38 E1          		pop	h
0053++ FE39 C3 DF F8    		jmp	fileChanged0835+  FE3C             .include "tapeReadHeader.inc"
0001++ FE3C             ;----------------------------------------------------------------------------
0002++ FE3C             ; RAMFOS
0003++ FE3C             ; Чтение первых 15 байт заголовка файла в v_header и вывод его на экран
0004++ FE3C             ; Потом чтение длины тела (первые 2 байта) в DE
0005++ FE3C             ;
0006++ FE3C             ; 2013-11-01 Дизассемблировано vinxru
0007++ FE3C             ;----------------------------------------------------------------------------
0008++ FE3C             
0009++ FE3C 21 52 D2    tapeReadHeader:	lxi	h, v_header
0010++ FE3F CD 50 FE    		call	tapeReadH_1
0011++ FE42             
0012++ FE42             		; Длина не контроллируется!
0013++ FE42             
0014++ FE42             		; Читаем 15 байт с магнитофона по адресу hl
0015++ FE42 1E 0F       		mvi	e, 15
0016++ FE44 CD 06 C8    tapeReadH_0:	 call	j_tapeRead
0017++ FE47 77          		 mov	m, a
0018++ FE48 23          		 inx	h
0019++ FE49 1D          		 dcr	e
0020++ FE4A C2 44 FE    		jnz	tapeReadH_0
0021++ FE4D             
0022++ FE4D             		; Выводим имя на экран
0023++ FE4D CD 06 FC    		call	printFileHeaderName
0024++ FE50             
0025++ FE50             tapeReadH_1:	; Ждем пилот тон
0026++ FE50 CD 24 C8    		call	j_tapeReadPilot
0027++ FE53             
0028++ FE53             		; Читаем слово в DE
0029++ FE53 D4 06 C8    		cnc	j_tapeRead
0030++ FE56 5F          		mov	e, a
0031++ FE57 D4 06 C8    		cnc	j_tapeRead
0032++ FE5A 57          		mov	d, a
0033++ FE5B C9          		ret
0836+  FE5C             
0837+  FE5C             ; ---------------------------------------------------------------------------
0838+  FE5C             
0839+  FE5C             dlg_f3:		; Выводим "сравнить"
0840+  FE5C 11 B0 FF    		lxi	d, a_verify
0841+  FE5F CD AE FD    		call	dlg_checkMsg
0842+  FE62             
0843+  FE62             		; Если файл не выбран
0844+  FE62 CA 80 FE    		jz	dlg_f3_alt
0845+  FE65             
0846+  FE65             		; ?
0847+  FE65 CD 80 F9    		call	dlg_yesNo
0848+  FE68             
0849+  FE68             		; Продолжение в fileVerify
0850+  FE68             
0851+  FE68             ; ---------------------------------------------------------------------------
0852+  FE68             
0853+  FE68             .include "fileVerify.inc"
0001++ FE68             ;----------------------------------------------------------------------------
0002++ FE68             ; RAMFOS
0003++ FE68             ; Сравнить текущий файл с магнитофоном
0004++ FE68             ;
0005++ FE68             ; 2013-11-01 Дизассемблировано vinxru
0006++ FE68             ;----------------------------------------------------------------------------
0007++ FE68             
0008++ FE68             		; Чтение первых 15 байт заголовка файла в v_header и вывод его на экран
0009++ FE68             		; Потом чтение длины тела (первые 2 байта) в DE
0010++ FE68 CD 3C FE    		call	tapeReadHeader
0011++ FE6B             
0012++ FE6B             		;! Длина не контроллируется
0013++ FE6B             
0014++ FE6B             		; Адрес выбранного файла на диске
0015++ FE6B 2A 70 D2    		lhld	v_curFile		 
0016++ FE6E             verifyLoop:	 ; Читаем байт с диска
0017++ FE6E CD C2 FF    		 call	pageRead
0018++ FE71             		 ; Читаем байт с магнитофона
0019++ FE71 CD 06 C8    		 call	j_tapeRead
0020++ FE74             		 ; Если байты не равны, выводим ошибку
0021++ FE74 B9          		 cmp	c
0022++ FE75 C2 B5 FE    		 jnz	dlg_error
0023++ FE78             		 ; Увеличиваем адрес на диске
0024++ FE78 23          		 inx	h
0025++ FE79             		 ; Цикл. 
0026++ FE79             		 ;! Надо поставить в начало
0027++ FE79 1B          		 dcx	d
0028++ FE7A 7B          		 mov	a, e
0029++ FE7B B2          		 ora	d
0030++ FE7C C2 6E FE    		jnz	verifyLoop
0031++ FE7F C9          		ret
0854+  FE80             
0855+  FE80             ; ---------------------------------------------------------------------------
0856+  FE80             
0857+  FE80             dlg_f3_alt:	; Вывод на экран строки "Чтение"
0858+  FE80 11 A2 FF    		lxi	d, a_load
0859+  FE83 CD 7D F9    		call	dlg_msgYesNo
0860+  FE86             
0861+  FE86             .include "fileFromTape.inc"	; fileFromTape продолжается
0001++ FE86             ;----------------------------------------------------------------------------
0002++ FE86             ; RAMFOS
0003++ FE86             ; Чтение файла с магнитофона и сохранение в выбранную страницу
0004++ FE86             ;
0005++ FE86             ; 2013-11-01 Дизассемблировано vinxru
0006++ FE86             ;----------------------------------------------------------------------------
0007++ FE86             
0008++ FE86             fileFromTape:	; Читаем заголовок с диска
0009++ FE86 CD 3C FE    		call	tapeReadHeader
0010++ FE89             
0011++ FE89             		; Выводим текст "ОШИБКА" + звуковой сигнал. 
0012++ FE89             		; Ждем нажатия ESC и выходим с установленным флагом C
0013++ FE89 DA B5 FE    		jc	fileFromTapeErr2
0014++ FE8C             
0015++ FE8C             		; Хватит ли места на диске для сохранения файла?
0016++ FE8C 2A 7A D2    		lhld	v_pageFreeTotal
0017++ FE8F 2B          		dcx	h
0018++ FE90 2B          		dcx	h
0019++ FE91 2B          		dcx	h
0020++ FE92 CD 54 C8    		call	j_cmp_hl_de
0021++ FE95             
0022++ FE95             		; Выводим текст "МАЛ ДИСК" + звуковой сигнал. 
0023++ FE95             		; Ждем нажатия ESC и выходим с установленным флагом C
0024++ FE95 DA CA FE    		jc	outOfSpace
0025++ FE98             
0026++ FE98             		; Указатель записи на диск
0027++ FE98 2A 7C D2    		lhld	v_pageFreePtr
0028++ FE9B             readLoop:	 ; Читаем байт с магнитофона
0029++ FE9B CD 06 C8    		 call	j_tapeRead		
0030++ FE9E DA AF FE    		 jc	fileFromTapeErr
0031++ FEA1             		 ; Записываем байт A на диск по адресу HL
0032++ FEA1 4F          		 mov	c, a
0033++ FEA2 CD D1 FF    		 call	pageWrite
0034++ FEA5 23          		 inx	h
0035++ FEA6             		 ; Цикл DE
0036++ FEA6 1B          		 dcx	d
0037++ FEA7 7B          		 mov	a, e
0038++ FEA8 B2          		 ora	d
0039++ FEA9 C2 9B FE    		jnz	readLoop
0040++ FEAC             
0041++ FEAC             		; Файл прочитан
0042++ FEAC C3 DD F8    		jmp	fileChanged2
0043++ FEAF             
0044++ FEAF             ; ---------------------------------------------------------------------------
0045++ FEAF             
0046++ FEAF             fileFromTapeErr:
0047++ FEAF             		; Устаналвиаем конец диска в v_curFile
0048++ FEAF 2A 70 D2    		lhld	v_curFile
0049++ FEB2 CD DF F8    		call	fileChanged
0050++ FEB5             
0051++ FEB5             fileFromTapeErr2:0862+  FEB5             
0863+  FEB5             dlg_error:	; Выводим сообщение "ОШИБКА" + звуковой сигнал
0864+  FEB5 CD D9 FE    		call	printStringEx
0865+  FEB8 CF DB C9 C2 		.db 0CFh, 0DBh,	0C9h, 0C2h, 0CBh, 0C1h,	C_BEEP, 0 ; ошибка
0865+  FEBC CB C1 07 00 
0866+  FEC0             
0867+  FEC0             waitEsc:	; Ждем, пока пользователь не нажмет ESC
0868+  FEC0 CD 72 FA    		 call	keyWaitNoCursor
0869+  FEC3             #if NICE
0870+  FEC3 FE 20       		 cpi	' '
0871+  FEC5~            #else
0872+  FEC5~            		 cpi	1Fh
0873+  FEC5             #endif
0874+  FEC5 C2 C0 FE    		jnz	waitEsc
0875+  FEC8             		; Выходим с установленным флагом C
0876+  FEC8 37          		stc
0877+  FEC9 C9          		ret
0878+  FECA             
0879+  FECA             ; ---------------------------------------------------------------------------
0880+  FECA             
0881+  FECA CD D9 FE    outOfSpace:	call	printStringEx
0882+  FECD CD C1 CC 20 		.db 0CDh, 0C1h,	0CCh, 20h, 0C4h, 0C9h, 0D3h, 0CBh, 0 ; мал диск
0882+  FED1 C4 C9 D3 CB 
0882+  FED5 00 
0883+  FED6 C3 C0 FE    		jmp	waitEsc
0884+  FED9             
0885+  FED9             ; ---------------------------------------------------------------------------
0886+  FED9             
0887+  FED9             .include "printStringEx.inc"
0001++ FED9             ;+---------------------------------------------------------------------------
0002++ FED9             ; RAMFOS
0003++ FED9             ; Вывод строки на экран
0004++ FED9             ;
0005++ FED9             ; Строка размещается сразу же после комадны вызова
0006++ FED9             ;
0007++ FED9             ; 2013-11-01 Дизассемблировано vinxru
0008++ FED9             ;----------------------------------------------------------------------------
0009++ FED9             
0010++ FED9 E3          printStringEx:	xthl
0011++ FEDA CD 18 C8    		call	j_printString
0012++ FEDD E3          		xthl
0013++ FEDE C9          		ret
0888+  FEDF             
0889+  FEDF             ; ---------------------------------------------------------------------------
0890+  FEDF             ; Соханить файл на магнитофон
0891+  FEDF             
0892+  FEDF             dlg_f4:		; Если файл не выбран, выходим
0893+  FEDF 2A 74 D2    		lhld	f_nextFile
0894+  FEE2 CD 54 C8    		call	j_cmp_hl_de
0895+  FEE5 C8          		rz
0896+  FEE6             
0897+  FEE6             		; Вывод "запись"
0898+  FEE6 11 A9 FF    		lxi	d, a_save
0899+  FEE9 CD 7D F9    		call	dlg_msgYesNo
0900+  FEEC             
0901+  FEEC CD D9 FD    		call	dlg_isLastLine
0902+  FEEF 2A 43 D2    		lhld	v_pageStart
0903+  FEF2 CA 08 FF    		jz	fileToTape
0904+  FEF5             
0905+  FEF5 0E 8C       		mvi	c, C_NORMAL
0906+  FEF7             
0907+  FEF7 2A 70 D2    		lhld	v_curFile
0908+  FEFA 11 0F 00    		lxi	d, 0Fh
0909+  FEFD 19          		dad	d
0910+  FEFE CD D1 FF    		call	pageWrite
0911+  FF01             		
0912+  FF01 2A 78 D2    		lhld	f_fileSize
0913+  FF04 EB          		xchg
0914+  FF05 2A 70 D2    		lhld	v_curFile
0915+  FF08             
0916+  FF08             .include "fileToTape.inc"
0001++ FF08             ;----------------------------------------------------------------------------
0002++ FF08             ; RAMFOS
0003++ FF08             ; Сохранить файл на магнитофон
0004++ FF08             ;
0005++ FF08             ; 2013-11-01 Дизассемблировано vinxru
0006++ FF08             ;----------------------------------------------------------------------------
0007++ FF08             
0008++ FF08             fileToTape:	; Сначала записываем только 15 байт.
0009++ FF08 E5          		push	h
0010++ FF09 D5          		 push	d
0011++ FF0A 11 0F 00    		  lxi	d, 15
0012++ FF0D CD 12 FF    		  call	fileToTape_0
0013++ FF10 D1          		 pop	d
0014++ FF11 E1          		pop	h
0015++ FF12             
0016++ FF12             		; Потом тот же блок данных, но целиком
0017++ FF12             
0018++ FF12             fileToTape_0:	; Пилот тон
0019++ FF12 CD 27 C8    		call	j_tapeWritePilot
0020++ FF15             
0021++ FF15             		; Запись длины
0022++ FF15 4B          		mov	c, e
0023++ FF16 AF          		xra	a
0024++ FF17 CD 0C C8    		call	j_tapeWrite
0025++ FF1A 4A          		mov	c, d
0026++ FF1B AF          		xra	a
0027++ FF1C CD 0C C8    		call	j_tapeWrite
0028++ FF1F             
0029++ FF1F             		; Зачем это?
0030++ FF1F 06 08       		mvi	b, 8		
0031++ FF21             fileToTape_1:	 ; Если записывать нечего, выходим
0032++ FF21 7B          		 mov	a, e
0033++ FF22 B2          		 ora	d
0034++ FF23 C8          		 rz
0035++ FF24             		 ; Читаем байт с диска
0036++ FF24 CD C2 FF    		 call	pageRead
0037++ FF27 23          		 inx	h
0038++ FF28             		 ; Уменьшаем счетчик
0039++ FF28 1B          		 dcx	d
0040++ FF29             		 ; Записываем на магнитофон
0041++ FF29 78          		 mov	a, b
0042++ FF2A CD 0C C8    		 call	j_tapeWrite
0043++ FF2D C3 21 FF    		jmp	fileToTape_10917+  FF30             
0918+  FF30             ; ---------------------------------------------------------------------------
0919+  FF30             ; Переименовать файл
0920+  FF30             
0921+  FF30             dlg_f5:		; Вывести "имя:"
0922+  FF30 11 B9 FF    		lxi	d, a_name
0923+  FF33 CD AE FD    		call	dlg_checkMsg
0924+  FF36             
0925+  FF36             		; Если файл не выбран
0926+  FF36 CA 6C FA    		jz	startEditor
0927+  FF39             
0928+  FF39             dlg_f5_retry:	; Устанавливаем курсор на имя файла
0929+  FF39 CD FA FB    		call	popCursorLine2
0930+  FF3C             
0931+  FF3C             		; Редактирование имени файла
0932+  FF3C 21 55 D2    		lxi	h, v_header_name
0933+  FF3F 11 FF 0C    		lxi	d, 0CFFh
0934+  FF42 CD 36 C8    		call	j_input
0935+  FF45             	
0936+  FF45             		; Был нажат ESC	
0937+  FF45 CA 93 F9    		jz	loc_F9D0
0938+  FF48             
0939+  FF48             		; Была нажата служебная клавиша
0940+  FF48 D2 39 FF    		jnc	dlg_f5_retry
0941+  FF4B             
0942+  FF4B             		; Имя не введено, перерисовать
0943+  FF4B F0          		rp
0944+  FF4C             
0945+  FF4C             		; Продолжение в fileSaveHeader
0946+  FF4C             
0947+  FF4C             ; ---------------------------------------------------------------------------0364   FF4C             #if RELOCATE_FILE_FUNCTIONS
0365   FF4C C3 4F D1    	jmp	fileSaveHeader
0366   FF4F~            #else
0367   FF4F~            .include "fileSaveHeader.inc"	; Їа®¤®«¦Ґ­ЁҐ ў pageWriteBlock
0368   FF4F~            .include "pageWriteBlock.inc"
0369   FF4F             #endif
0370   FF4F             .include "fileSetGetName.inc"
0001+  FF4F             ;+---------------------------------------------------------------------------
0002+  FF4F             ; RAMFOS
0003+  FF4F             ; Стандартная точка входа F845
0004+  FF4F             ; Получение имени последнего загруженного файла
0005+  FF4F             ;
0006+  FF4F             ; На входе
0007+  FF4F             ;  hl - имя файла (12 байт)
0008+  FF4F             ;
0009+  FF4F             ; 2013-11-01 Дизассемблировано vinxru
0010+  FF4F             ;----------------------------------------------------------------------------
0011+  FF4F             
0012+  FF4F E5          fileGetName:	push	h
0013+  FF50 D5          		push	d
0014+  FF51 C5          		push	b
0015+  FF52 11 F5 D1    		lxi	d, v_header2_name
0016+  FF55 EB          		xchg
0017+  FF56 C3 5F FF    		jmp	fileSetName_0
0018+  FF59             
0019+  FF59             ;----------------------------------------------------------------------------
0020+  FF59             ; RAMFOS
0021+  FF59             ; Стандартная точка входа F848
0022+  FF59             ; Установка имя для функций сохаранения/поиска
0023+  FF59             ;
0024+  FF59             ; На входе
0025+  FF59             ;  hl - имя файла (12 байт)
0026+  FF59             ;
0027+  FF59             ; 2013-11-01 Дизассемблировано vinxru
0028+  FF59             ;----------------------------------------------------------------------------
0029+  FF59             
0030+  FF59 E5          fileSetName:	push	h
0031+  FF5A D5          		push	d
0032+  FF5B C5          		push	b
0033+  FF5C 11 F5 D1    		lxi	d, v_header2_name
0034+  FF5F 0E 0B       fileSetName_0:	mvi	c, 11
0035+  FF61 C3 6C FF    		jmp	memcpy_popa0371   FF64             .include "fileSetType.inc"
0001+  FF64             ;+---------------------------------------------------------------------------
0002+  FF64             ; RAMFOS
0003+  FF64             ; Стандартная точка входа F82D
0004+  FF64             ; Установить расширение сохраняемого/загружаемого файла
0005+  FF64             ;
0006+  FF64             ; 2013-11-01 Дизассемблировано vinxru
0007+  FF64             ;----------------------------------------------------------------------------
0008+  FF64             
0009+  FF64 E5          fileSetType:	push	h
0010+  FF65 D5          		push	d
0011+  FF66 C5          		push	b
0012+  FF67 11 FE D1    		 lxi	d, v_header2_ext
0013+  FF6A 0E 02       		 mvi	c, 2	; Размер -1
0014+  FF6C F5          memcpy_popa:	 push	psw
0015+  FF6D CD C3 FB    		  call	memcpy_de_hl_c
0016+  FF70 F1          		 pop	psw
0017+  FF71 C1          		pop	b
0018+  FF72 D1          		pop	d
0019+  FF73 E1          		pop	h
0020+  FF74 C9          		ret0372   FF75             
0373   FF75             ; ===========================================================================
0374   FF75             ; Џ…ђ…Њ…ЌЌ›…
0375   FF75             
0376   FF75 D3 D3 D3    a_defHeader:	.db 0D3h, 0D3h,	0D3h	; ¬ аЄҐа ­ з «  д ©«  (§  ­Ё¬ ®Ўп§ вҐ«м­® ¤®«¦Ґ­® Ё¤вЁ 12 Їа®ЎҐ«®ў)
0377   FF78 20 20 20 20 a_12spaces:	.text "            "	; Їгбв®Ґ Ё¬п
0377   FF7C 20 20 20 20 
0377   FF80 20 20 20 20 
0378   FF84 45 58 45    a_exe:		.text "EXE"
0379   FF87 43 4F 4D    a_com:		.text "COM"
0380   FF8A CB CF D0 C9 a_copy:		.db 0CBh, 0CFh,	0D0h, 0C9h, 0D2h, 0CFh,	0D7h, 
0380   FF8E D2 CF D7 
0381   FF91 C1 D4 D8 00 		.db 0C1h, 0D4h, 0D8h, 0					; "Є®ЇЁа®ў вм"
0382   FF95 C4 C1 D4 D5 a_deleteDate:	.db 0C4h, 0C1h,	0D4h, 0D5h, 20h				; "¤ вг г¤ «Ёвм"
0382   FF99 20 
0383   FF9A D5 C4 C1 CC a_delete:	.db 0D5h, 0C4h,	0C1h, 0CCh, 0C9h, 0D4h,	0D8h, 0		; "г¤ «Ёвм"
0383   FF9E C9 D4 D8 00 
0384   FFA2 DE D4 C5 CE a_load:		.db 0DEh, 0D4h,	0C5h, 0CEh, 0C9h, 0C5h,	0		; "звҐ­ЁҐ"
0384   FFA6 C9 C5 00 
0385   FFA9 DA C1 D0 C9 a_save:		.db 0DAh, 0C1h,	0D0h, 0C9h, 0D3h, 0D8h,	0		; "§ ЇЁбм"
0385   FFAD D3 D8 00 
0386   FFB0 D3 D2 C1 D7 a_verify:	.db 0D3h, 0D2h,	0C1h, 0D7h, 0CEh, 0C9h,	0D4h, 0D8h, 0	; "ба ў­Ёвм"
0386   FFB4 CE C9 D4 D8 
0386   FFB8 00 
0387   FFB9 C9 CD D1 00 a_name:		.db 0C9h, 0CDh,	0D1h, 0	; Ё¬п
0388   FFBD             
0389   FFBD             ; ===========================================================================
0390   FFBD             ; ЋЉЌЋ ЏђЋ–…‘‘ЋђЂ
0391   FFBD             
0392   FFBD             .include "window.inc"
0001+  FFBD             ;+---------------------------------------------------------------------------
0002+  FFBD             ; RAMFOS
0003+  FFBD             ; 2013-11-01 Дизассемблировано vinxru
0004+  FFBD             ;----------------------------------------------------------------------------
0005+  FFBD             
0006+  FFBD~            #if BIG_ROM != 1
0007+  FFBD~            		
0008+  FFBD~            #if $ > 0FFB6h
0009+  FFBD~            Ошибка_часть_F800_не_влезла
0010+  FFBD~            #endif
0011+  FFBD~            .org 0FFB6h
0012+  FFBD~            
0013+  FFBD~            pageWriteROM:	sta	IO_PAGE_ROM
0014+  FFBD~            		jmp	pageWriteCom
0015+  FFBD~            
0016+  FFBD~            pageReadROM:	sta	IO_PAGE_ROM
0017+  FFBD~            		jmp	pageReadCom
0018+  FFBD~            
0019+  FFBD             #endif
0020+  FFBD             
0021+  FFBD             ; ---------------------------------------------------------------------------
0022+  FFBD             
0023+  FFBD~            #if $ > 0FFC2h
0024+  FFBD~            Ошибка_часть_F800_не_влезла
0025+  FFBD             #endif
0026+  FFC2             .org 0FFC2h
0027+  FFC2             
0028+  FFC2 3A 45 D2    pageRead:	lda	v_page
0029+  FFC5             
0030+  FFC5             ;----------------------------------------------------------------------------
0031+  FFC5             ; RAMFOS
0032+  FFC5             ; Стандартная точка входа F836
0033+  FFC5             ; Чтение байта из ДОЗУ
0034+  FFC5             ;
0035+  FFC5             ; На входе
0036+  FFC5             ;   a  - номер страницы
0037+  FFC5             ;   hl - адрес
0038+  FFC5             ;
0039+  FFC5             ; На выходе
0040+  FFC5             ;   с  - байт
0041+  FFC5             ;
0042+  FFC5             ; 2013-11-01 Дизассемблировано vinxru
0043+  FFC5             ;----------------------------------------------------------------------------
0044+  FFC5             
0045+  FFC5 B7          pageReadAny:	ora	a
0046+  FFC6             #if BIG_ROM
0047+  FFC6 FA 26 D1    		jm	bigRom
0048+  FFC9~            #else
0049+  FFC9~            		jm	pageReadROM
0050+  FFC9             #endif
0051+  FFC9 32 FD FF    disableARAM1:	sta	IO_PAGE_ARAM		
0052+  FFCC 4E          pageReadCom:	mov	c, m
0053+  FFCD 32 FC FF    		sta	IO_PAGE_RAM
0054+  FFD0 C9          		ret
0055+  FFD1             
0056+  FFD1             ; ---------------------------------------------------------------------------
0057+  FFD1             
0058+  FFD1 3A 45 D2    pageWrite:	lda	v_page
0059+  FFD4             
0060+  FFD4             ;----------------------------------------------------------------------------
0061+  FFD4             ; RAMFOS
0062+  FFD4             ; Стандартная точка входа F839
0063+  FFD4             ; Запись байта в ДОЗУ
0064+  FFD4             ;
0065+  FFD4             ; На входе
0066+  FFD4             ;   a  - номер страницы
0067+  FFD4             ;   hl - адрес
0068+  FFD4             ;   c  - байт
0069+  FFD4             ;
0070+  FFD4             ; 2013-11-01 Дизассемблировано vinxru
0071+  FFD4             ;----------------------------------------------------------------------------
0072+  FFD4             
0073+  FFD4 B7          pageWriteAny:	ora	a
0074+  FFD5             #if BIG_ROM
0075+  FFD5 FA DF FF    		jm	pageWriteRet
0076+  FFD8~            #else
0077+  FFD8~            		jm	pageWriteROM
0078+  FFD8             #endif
0079+  FFD8 32 FD FF    disableARAM2:	sta	IO_PAGE_ARAM
0080+  FFDB 71          pageWriteCom:	mov	m, c
0081+  FFDC 32 FC FF    		sta	IO_PAGE_RAM
0082+  FFDF C9          pageWriteRet:	ret0393   FFE0             
0394   FFE0             .end		tasm: Number of errors = 0
